<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mne.epochs.EvokedArray &mdash; MNE 0.11.dev0 documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.3.4/flatly/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.11.dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="MNE 0.11.dev0 documentation" href="../index.html" />

<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,400,700' rel='stylesheet' type='text/css'>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="http://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>


  </head>
  <body role="document">





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><img src="../_static/mne_logo_small.png">
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.11.dev0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../tutorials.html">Tutorials</a></li>
                <li><a href="../auto_examples/index.html">Gallery</a></li>
                <li><a href="../manual/index.html">Manual</a></li>
                <li><a href="../python_reference.html">API</a></li>
                <li><a href="../faq.html">FAQ</a></li>
                <li><a href="../cite.html">Cite</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whats_new.html">What&#8217;s new</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cite.html">Cite MNE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">Related publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../manual/index.html">Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python_reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced_setup.html">Advanced installation and setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mne_cpp.html">MNE with CPP</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">mne.epochs.EvokedArray</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/mne_logo_small.png" alt="Logo"/>
            </a></p><ul>
<li><a class="reference internal" href="#">mne.epochs.EvokedArray</a></li>
</ul>

<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-12">
      
  <div class="section" id="mne-epochs-evokedarray">
<h1>mne.epochs.EvokedArray<a class="headerlink" href="#mne-epochs-evokedarray" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="mne.epochs.EvokedArray">
<em class="property">class </em><code class="descclassname">mne.epochs.</code><code class="descname">EvokedArray</code><span class="sig-paren">(</span><em>data</em>, <em>info</em>, <em>tmin</em>, <em>comment=''</em>, <em>nave=1</em>, <em>kind='average'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Evoked object from numpy array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array of shape (n_channels, n_times)</p>
<blockquote>
<div><p>The channels&#8217; evoked response.</p>
</div></blockquote>
<p><strong>info</strong> : instance of Info</p>
<blockquote>
<div><p>Info dictionary. Consider using <code class="docutils literal"><span class="pre">create_info</span></code> to populate
this structure.</p>
</div></blockquote>
<p><strong>tmin</strong> : float</p>
<blockquote>
<div><p>Start time before event.</p>
</div></blockquote>
<p><strong>comment</strong> : string</p>
<blockquote>
<div><p>Comment on dataset. Can be the condition. Defaults to &#8216;&#8217;.</p>
</div></blockquote>
<p><strong>nave</strong> : int</p>
<blockquote>
<div><p>Number of averaged epochs. Defaults to 1.</p>
</div></blockquote>
<p><strong>kind</strong> : str</p>
<blockquote>
<div><p>Type of data, either average or standard_error. Defaults to &#8216;average&#8217;.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to raw.verbose.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.epochs.EpochsArray.html#mne.epochs.EpochsArray" title="mne.epochs.EpochsArray"><code class="xref py py-obj docutils literal"><span class="pre">EpochsArray</span></code></a>, <code class="xref py py-obj docutils literal"><span class="pre">io.RawArray</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">create_info</span></code></p>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mne.epochs.EvokedArray.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>data</em>, <em>info</em>, <em>tmin</em>, <em>comment=''</em>, <em>nave=1</em>, <em>kind='average'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.add_channels">
<code class="descname">add_channels</code><span class="sig-paren">(</span><em>add_list</em>, <em>copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.add_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Append new channels to the instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>add_list</strong> : list</p>
<blockquote>
<div><p>A list of objects to append to self. Must contain all the same
type as the current object</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>Whether to return a new instance or modify in place</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : MNE object of type(self)</p>
<blockquote class="last">
<div><p>An object with new channels appended (will be the same
object if copy==False)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.add_proj">
<code class="descname">add_proj</code><span class="sig-paren">(</span><em>projs</em>, <em>remove_existing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.add_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Add SSP projection vectors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>projs</strong> : list</p>
<blockquote>
<div><p>List with projection vectors.</p>
</div></blockquote>
<p><strong>remove_existing</strong> : bool</p>
<blockquote>
<div><p>Remove the projection vectors currently in the file.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
<blockquote class="last">
<div><p>The data container.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.apply_proj">
<code class="descname">apply_proj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.apply_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the signal space projection (SSP) operators to the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
<blockquote class="last">
<div><p>The instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Once the projectors have been applied, they can no longer be
removed. It is usually not recommended to apply the projectors at
too early stages, as they are applied automatically later on
(e.g. when computing inverse solutions).
Hint: using the copy method individual projection vectors
can be tested without affecting the original data.
With evoked data, consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">projs_a</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_proj</span><span class="p">(</span><span class="s">&#39;proj_a.fif&#39;</span><span class="p">)</span>
<span class="n">projs_b</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_proj</span><span class="p">(</span><span class="s">&#39;proj_b.fif&#39;</span><span class="p">)</span>
<span class="c"># add the first, copy, apply and see ...</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">add_proj</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c"># add the second, copy, apply and see ...</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">add_proj</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c"># drop the first and see again</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">del_proj</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span>  <span class="c"># finally keep both</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.as_type">
<code class="descname">as_type</code><span class="sig-paren">(</span><em>ch_type='grad'</em>, <em>mode='fast'</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.as_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute virtual evoked using interpolated fields in mag/grad channels.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Using virtual evoked to compute inverse can yield
unexpected results. The virtual channels have <cite>&#8216;_virtual&#8217;</cite> appended
at the end of the names to emphasize that the data contained in
them are interpolated.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_type</strong> : str</p>
<blockquote>
<div><p>The destination channel type. It can be &#8216;mag&#8217; or &#8216;grad&#8217;.</p>
</div></blockquote>
<p><strong>mode</strong> : str</p>
<blockquote>
<div><p>Either <cite>&#8216;accurate&#8217;</cite> or <cite>&#8216;fast&#8217;</cite>, determines the quality of the
Legendre polynomial expansion used. <cite>&#8216;fast&#8217;</cite> should be sufficient
for most applications.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>evoked</strong> : instance of mne.Evoked</p>
<blockquote class="last">
<div><p>The transformed evoked object containing only virtual channels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mne.epochs.EvokedArray.ch_names">
<code class="descname">ch_names</code><a class="headerlink" href="#mne.epochs.EvokedArray.ch_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Channel names</p>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the instance of evoked</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>evoked</strong> : instance of Evoked</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.crop">
<code class="descname">crop</code><span class="sig-paren">(</span><em>tmin=None</em>, <em>tmax=None</em>, <em>copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop data to a given time interval</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tmin</strong> : float | None</p>
<blockquote>
<div><p>Start time of selection in seconds.</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote>
<div><p>End time of selection in seconds.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote class="last">
<div><p>If False epochs is cropped in place.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.del_proj">
<code class="descname">del_proj</code><span class="sig-paren">(</span><em>idx</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.del_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove SSP projection vector</p>
<dl class="docutils">
<dt>Note: The projection vector can only be removed if it is inactive</dt>
<dd>(has not been applied to the data).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>idx</strong> : int</p>
<blockquote>
<div><p>Index of the projector to remove.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.detrend">
<code class="descname">detrend</code><span class="sig-paren">(</span><em>order=1</em>, <em>picks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.detrend" title="Permalink to this definition">¶</a></dt>
<dd><p>Detrend data</p>
<p>This function operates in-place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>order</strong> : int</p>
<blockquote>
<div><p>Either 0 or 1, the order of the detrending. 0 is a constant
(DC) detrend, 1 is a linear detrend.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote class="last">
<div><p>If None only MEG and EEG channels are detrended.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.drop_channels">
<code class="descname">drop_channels</code><span class="sig-paren">(</span><em>ch_names</em>, <em>copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.drop_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop some channels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_names</strong> : list</p>
<blockquote>
<div><p>The list of channels to remove.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote class="last">
<div><p>If True, returns new instance. Else, modifies in place. Defaults to
False.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.epochs.EvokedArray.pick_channels" title="mne.epochs.EvokedArray.pick_channels"><code class="xref py py-obj docutils literal"><span class="pre">pick_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.get_peak">
<code class="descname">get_peak</code><span class="sig-paren">(</span><em>ch_type=None</em>, <em>tmin=None</em>, <em>tmax=None</em>, <em>mode='abs'</em>, <em>time_as_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.get_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Get location and latency of peak amplitude</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_type</strong> : {&#8216;mag&#8217;, &#8216;grad&#8217;, &#8216;eeg&#8217;, &#8216;misc&#8217;, None}</p>
<blockquote>
<div><p>The channel type to use. Defaults to None. If more than one sensor
Type is present in the data the channel type has to be explicitly
set.</p>
</div></blockquote>
<p><strong>tmin</strong> : float | None</p>
<blockquote>
<div><p>The minimum point in time to be considered for peak getting.</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote>
<div><p>The maximum point in time to be considered for peak getting.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;pos&#8217;, &#8216;neg&#8217;, &#8216;abs&#8217;}</p>
<blockquote>
<div><p>How to deal with the sign of the data. If &#8216;pos&#8217; only positive
values will be considered. If &#8216;neg&#8217; only negative values will
be considered. If &#8216;abs&#8217; absolute values will be considered.
Defaults to &#8216;abs&#8217;.</p>
</div></blockquote>
<p><strong>time_as_index</strong> : bool</p>
<blockquote>
<div><p>Whether to return the time index instead of the latency in seconds.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ch_name</strong> : str</p>
<blockquote>
<div><p>The channel exhibiting the maximum response.</p>
</div></blockquote>
<p><strong>latency</strong> : float | int</p>
<blockquote class="last">
<div><p>The time point of the maximum response, either latency in seconds
or index.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.interpolate_bads">
<code class="descname">interpolate_bads</code><span class="sig-paren">(</span><em>reset_bads=True</em>, <em>mode='accurate'</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.interpolate_bads" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate bad MEG and EEG channels.</p>
<p>Operates in place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reset_bads</strong> : bool</p>
<blockquote>
<div><p>If True, remove the bads from info.</p>
</div></blockquote>
<p><strong>mode</strong> : str</p>
<blockquote>
<div><p>Either <cite>&#8216;accurate&#8217;</cite> or <cite>&#8216;fast&#8217;</cite>, determines the quality of the
Legendre polynomial expansion used for interpolation of MEG
channels.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : mne.io.Raw, mne.Epochs or mne.Evoked</p>
<blockquote class="last">
<div><p>The interpolated data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.pick_channels">
<code class="descname">pick_channels</code><span class="sig-paren">(</span><em>ch_names</em>, <em>copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.pick_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_names</strong> : list</p>
<blockquote>
<div><p>The list of channels to select.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote class="last">
<div><p>If True, returns new instance. Else, modifies in place. Defaults to
False.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.epochs.EvokedArray.drop_channels" title="mne.epochs.EvokedArray.drop_channels"><code class="xref py py-obj docutils literal"><span class="pre">drop_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.pick_types">
<code class="descname">pick_types</code><span class="sig-paren">(</span><em>meg=True</em>, <em>eeg=False</em>, <em>stim=False</em>, <em>eog=False</em>, <em>ecg=False</em>, <em>emg=False</em>, <em>ref_meg='auto'</em>, <em>misc=False</em>, <em>resp=False</em>, <em>chpi=False</em>, <em>exci=False</em>, <em>ias=False</em>, <em>syst=False</em>, <em>seeg=False</em>, <em>include=[]</em>, <em>exclude='bads'</em>, <em>selection=None</em>, <em>copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.pick_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels by type and names</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>meg</strong> : bool | str</p>
<blockquote>
<div><p>If True include all MEG channels. If False include None
If string it can be &#8216;mag&#8217;, &#8216;grad&#8217;, &#8216;planar1&#8217; or &#8216;planar2&#8217; to select
only magnetometers, all gradiometers, or a specific type of
gradiometer.</p>
</div></blockquote>
<p><strong>eeg</strong> : bool</p>
<blockquote>
<div><p>If True include EEG channels.</p>
</div></blockquote>
<p><strong>stim</strong> : bool</p>
<blockquote>
<div><p>If True include stimulus channels.</p>
</div></blockquote>
<p><strong>eog</strong> : bool</p>
<blockquote>
<div><p>If True include EOG channels.</p>
</div></blockquote>
<p><strong>ecg</strong> : bool</p>
<blockquote>
<div><p>If True include ECG channels.</p>
</div></blockquote>
<p><strong>emg</strong> : bool</p>
<blockquote>
<div><p>If True include EMG channels.</p>
</div></blockquote>
<p><strong>ref_meg: bool | str</strong> :</p>
<blockquote>
<div><p>If True include CTF / 4D reference channels. If &#8216;auto&#8217;, the
reference channels are only included if compensations are present.</p>
</div></blockquote>
<p><strong>misc</strong> : bool</p>
<blockquote>
<div><p>If True include miscellaneous analog channels.</p>
</div></blockquote>
<p><strong>resp</strong> : bool</p>
<blockquote>
<div><p>If True include response-trigger channel. For some MEG systems this
is separate from the stim channel.</p>
</div></blockquote>
<p><strong>chpi</strong> : bool</p>
<blockquote>
<div><p>If True include continuous HPI coil channels.</p>
</div></blockquote>
<p><strong>exci</strong> : bool</p>
<blockquote>
<div><p>Flux excitation channel used to be a stimulus channel.</p>
</div></blockquote>
<p><strong>ias</strong> : bool</p>
<blockquote>
<div><p>Internal Active Shielding data (maybe on Triux only).</p>
</div></blockquote>
<p><strong>syst</strong> : bool</p>
<blockquote>
<div><p>System status channel information (on Triux systems only).</p>
</div></blockquote>
<p><strong>seeg</strong> : bool</p>
<blockquote>
<div><p>Stereotactic EEG channels.</p>
</div></blockquote>
<p><strong>include</strong> : list of string</p>
<blockquote>
<div><p>List of additional channels to include. If empty do not include
any.</p>
</div></blockquote>
<p><strong>exclude</strong> : list of string | str</p>
<blockquote>
<div><p>List of channels to exclude. If &#8216;bads&#8217; (default), exclude channels
in <code class="docutils literal"><span class="pre">info['bads']</span></code>.</p>
</div></blockquote>
<p><strong>selection</strong> : list of string</p>
<blockquote>
<div><p>Restrict sensor channels (MEG, EEG) to this list of channel names.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote class="last">
<div><p>If True, returns new instance. Else, modifies in place. Defaults to
False.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>picks=None</em>, <em>exclude='bads'</em>, <em>unit=True</em>, <em>show=True</em>, <em>ylim=None</em>, <em>xlim='tight'</em>, <em>proj=False</em>, <em>hline=None</em>, <em>units=None</em>, <em>scalings=None</em>, <em>titles=None</em>, <em>axes=None</em>, <em>gfp=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot evoked data as butterfly plots</p>
<p>Left click to a line shows the channel name. Selecting an area by
clicking and holding left mouse button plots a topographic map of the
painted area.</p>
<p>Note: If bad channels are not excluded they are shown in red.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>The indices of channels to plot. If None show all.</p>
</div></blockquote>
<p><strong>exclude</strong> : list of str | &#8216;bads&#8217;</p>
<blockquote>
<div><p>Channels names to exclude from being shown. If &#8216;bads&#8217;, the
bad channels are excluded.</p>
</div></blockquote>
<p><strong>unit</strong> : bool</p>
<blockquote>
<div><p>Scale plot with channel (SI) unit.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Call pyplot.show() at the end or not.</p>
</div></blockquote>
<p><strong>ylim</strong> : dict</p>
<blockquote>
<div><p>ylim for plots. e.g. ylim = dict(eeg=[-200e-6, 200e-6])
Valid keys are eeg, mag, grad</p>
</div></blockquote>
<p><strong>xlim</strong> : &#8216;tight&#8217; | tuple | None</p>
<blockquote>
<div><p>xlim for plots.</p>
</div></blockquote>
<p><strong>proj</strong> : bool | &#8216;interactive&#8217;</p>
<blockquote>
<div><p>If true SSP projections are applied before display. If
&#8216;interactive&#8217;, a check box for reversible selection of SSP
projection vectors will be shown.</p>
</div></blockquote>
<p><strong>hline</strong> : list of floats | None</p>
<blockquote>
<div><p>The values at which show an horizontal line.</p>
</div></blockquote>
<p><strong>units</strong> : dict | None</p>
<blockquote>
<div><p>The units of the channel types used for axes lables. If None,
defaults to <cite>dict(eeg=&#8217;uV&#8217;, grad=&#8217;fT/cm&#8217;, mag=&#8217;fT&#8217;)</cite>.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>The scalings of the channel types to be applied for plotting.
If None, defaults to <cite>dict(eeg=1e6, grad=1e13, mag=1e15)</cite>.</p>
</div></blockquote>
<p><strong>titles</strong> : dict | None</p>
<blockquote>
<div><p>The titles associated with the channels. If None, defaults to
<cite>dict(eeg=&#8217;EEG&#8217;, grad=&#8217;Gradiometers&#8217;, mag=&#8217;Magnetometers&#8217;)</cite>.</p>
</div></blockquote>
<p><strong>axes</strong> : instance of Axes | list | None</p>
<blockquote>
<div><p>The axes to plot to. If list, the list must be a list of Axes of
the same length as the number of channel types. If instance of
Axes, there must be only one channel type plotted.</p>
</div></blockquote>
<p><strong>gfp</strong> : bool | &#8216;only&#8217;</p>
<blockquote class="last">
<div><p>Plot GFP in green if True or &#8220;only&#8221;. If &#8220;only&#8221;, then the individual
channel traces will not be shown.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.plot_field">
<code class="descname">plot_field</code><span class="sig-paren">(</span><em>surf_maps</em>, <em>time=None</em>, <em>time_label='t = %0.0f ms'</em>, <em>n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.plot_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot MEG/EEG fields on head surface and helmet in 3D</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>surf_maps</strong> : list</p>
<blockquote>
<div><p>The surface mapping information obtained with make_field_map.</p>
</div></blockquote>
<p><strong>time</strong> : float | None</p>
<blockquote>
<div><p>The time point at which the field map shall be displayed. If None,
the average peak latency (across sensor types) is used.</p>
</div></blockquote>
<p><strong>time_label</strong> : str</p>
<blockquote>
<div><p>How to print info about the time instant visualized.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int</p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of mlab.Figure</p>
<blockquote class="last">
<div><p>The mayavi figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.plot_image">
<code class="descname">plot_image</code><span class="sig-paren">(</span><em>picks=None</em>, <em>exclude='bads'</em>, <em>unit=True</em>, <em>show=True</em>, <em>clim=None</em>, <em>xlim='tight'</em>, <em>proj=False</em>, <em>units=None</em>, <em>scalings=None</em>, <em>titles=None</em>, <em>axes=None</em>, <em>cmap='RdBu_r'</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.plot_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot evoked data as images</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>The indices of channels to plot. If None show all.</p>
</div></blockquote>
<p><strong>exclude</strong> : list of str | &#8216;bads&#8217;</p>
<blockquote>
<div><p>Channels names to exclude from being shown. If &#8216;bads&#8217;, the
bad channels are excluded.</p>
</div></blockquote>
<p><strong>unit</strong> : bool</p>
<blockquote>
<div><p>Scale plot with channel (SI) unit.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Call pyplot.show() at the end or not.</p>
</div></blockquote>
<p><strong>clim</strong> : dict</p>
<blockquote>
<div><p>clim for images. e.g. clim = dict(eeg=[-200e-6, 200e6])
Valid keys are eeg, mag, grad</p>
</div></blockquote>
<p><strong>xlim</strong> : &#8216;tight&#8217; | tuple | None</p>
<blockquote>
<div><p>xlim for plots.</p>
</div></blockquote>
<p><strong>proj</strong> : bool | &#8216;interactive&#8217;</p>
<blockquote>
<div><p>If true SSP projections are applied before display. If
&#8216;interactive&#8217;, a check box for reversible selection of SSP
projection vectors will be shown.</p>
</div></blockquote>
<p><strong>units</strong> : dict | None</p>
<blockquote>
<div><p>The units of the channel types used for axes lables. If None,
defaults to <cite>dict(eeg=&#8217;uV&#8217;, grad=&#8217;fT/cm&#8217;, mag=&#8217;fT&#8217;)</cite>.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>The scalings of the channel types to be applied for plotting.
If None, defaults to <cite>dict(eeg=1e6, grad=1e13, mag=1e15)</cite>.</p>
</div></blockquote>
<p><strong>titles</strong> : dict | None</p>
<blockquote>
<div><p>The titles associated with the channels. If None, defaults to
<cite>dict(eeg=&#8217;EEG&#8217;, grad=&#8217;Gradiometers&#8217;, mag=&#8217;Magnetometers&#8217;)</cite>.</p>
</div></blockquote>
<p><strong>axes</strong> : instance of Axes | list | None</p>
<blockquote>
<div><p>The axes to plot to. If list, the list must be a list of Axes of
the same length as the number of channel types. If instance of
Axes, there must be only one channel type plotted.</p>
</div></blockquote>
<p><strong>cmap</strong> : matplotlib colormap</p>
<blockquote class="last">
<div><p>Colormap.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.plot_projs_topomap">
<code class="descname">plot_projs_topomap</code><span class="sig-paren">(</span><em>ch_type=None</em>, <em>layout=None</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.plot_projs_topomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot SSP vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_type</strong> : &#8216;mag&#8217; | &#8216;grad&#8217; | &#8216;planar1&#8217; | &#8216;planar2&#8217; | &#8216;eeg&#8217; | None | List</p>
<blockquote>
<div><p>The channel type to plot. For &#8216;grad&#8217;, the gradiometers are collec-
ted in pairs and the RMS for each pair is plotted. If None
(default), it will return all channel types present. If a list of
ch_types is provided, it will return multiple figures.</p>
</div></blockquote>
<p><strong>layout</strong> : None | Layout | List of Layouts</p>
<blockquote>
<div><p>Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct
layout file is inferred from the data; if no appropriate layout
file was found, the layout is automatically generated from the
sensor locations. Or a list of Layout if projections
are from different sensor types.</p>
</div></blockquote>
<p><strong>axes</strong> : instance of Axes | list | None</p>
<blockquote>
<div><p>The axes to plot to. If list, the list must be a list of Axes of
the same length as the number of projectors. If instance of Axes,
there must be only one projector. Defaults to None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure distributing one image per channel across sensor topography.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.plot_topo">
<code class="descname">plot_topo</code><span class="sig-paren">(</span><em>layout=None, layout_scale=0.945, color=None, border='none', ylim=None, scalings=None, title=None, proj=False, vline=[0.0], fig_facecolor='k', fig_background=None, axis_facecolor='k', font_color='w', show=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.plot_topo" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot 2D topography of evoked responses.</p>
<p>Clicking on the plot of an individual sensor opens a new figure showing
the evoked response for the selected sensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>layout</strong> : instance of Layout | None</p>
<blockquote>
<div><p>Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct layout is
inferred from the data.</p>
</div></blockquote>
<p><strong>layout_scale: float</strong> :</p>
<blockquote>
<div><p>Scaling factor for adjusting the relative size of the layout
on the canvas</p>
</div></blockquote>
<p><strong>color</strong> : list of color objects | color object | None</p>
<blockquote>
<div><p>Everything matplotlib accepts to specify colors. If not list-like,
the color specified will be repeated. If None, colors are
automatically drawn.</p>
</div></blockquote>
<p><strong>border</strong> : str</p>
<blockquote>
<div><p>matplotlib borders style to be used for each sensor plot.</p>
</div></blockquote>
<p><strong>ylim</strong> : dict | None</p>
<blockquote>
<div><p>ylim for plots. The value determines the upper and lower subplot
limits. e.g. ylim = dict(eeg=[-200e-6, 200e6]). Valid keys are eeg,
mag, grad, misc. If None, the ylim parameter for each channel is
determined by the maximum absolute peak.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>The scalings of the channel types to be applied for plotting. If
None, defaults to <cite>dict(eeg=1e6, grad=1e13, mag=1e15)</cite>.</p>
</div></blockquote>
<p><strong>title</strong> : str</p>
<blockquote>
<div><p>Title of the figure.</p>
</div></blockquote>
<p><strong>proj</strong> : bool | &#8216;interactive&#8217;</p>
<blockquote>
<div><p>If true SSP projections are applied before display. If
&#8216;interactive&#8217;, a check box for reversible selection of SSP
projection vectors will be shown.</p>
</div></blockquote>
<p><strong>vline</strong> : list of floats | None</p>
<blockquote>
<div><p>The values at which to show a vertical line.</p>
</div></blockquote>
<p><strong>fig_facecolor</strong> : str | obj</p>
<blockquote>
<div><p>The figure face color. Defaults to black.</p>
</div></blockquote>
<p><strong>fig_background</strong> : None | numpy ndarray</p>
<blockquote>
<div><p>A background image for the figure. This must work with a call to
plt.imshow. Defaults to None.</p>
</div></blockquote>
<p><strong>axis_facecolor</strong> : str | obj</p>
<blockquote>
<div><p>The face color to be used for each sensor plot. Defaults to black.</p>
</div></blockquote>
<p><strong>font_color</strong> : str | obj</p>
<blockquote>
<div><p>The color of text in the colorbar and title. Defaults to white.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Instance of matplotlib.figure.Figure</p>
<blockquote>
<div><p>Images of evoked responses at sensor locations</p>
</div></blockquote>
<p class="last"><strong>.. versionadded:: 0.10.0</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.plot_topomap">
<code class="descname">plot_topomap</code><span class="sig-paren">(</span><em>times='auto'</em>, <em>ch_type=None</em>, <em>layout=None</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>cmap='RdBu_r'</em>, <em>sensors=True</em>, <em>colorbar=True</em>, <em>scale=None</em>, <em>scale_time=1000.0</em>, <em>unit=None</em>, <em>res=64</em>, <em>size=1</em>, <em>cbar_fmt='%3.1f'</em>, <em>time_format='%01d ms'</em>, <em>proj=False</em>, <em>show=True</em>, <em>show_names=False</em>, <em>title=None</em>, <em>mask=None</em>, <em>mask_params=None</em>, <em>outlines='head'</em>, <em>contours=6</em>, <em>image_interp='bilinear'</em>, <em>average=None</em>, <em>head_pos=None</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.plot_topomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot topographic maps of specific time points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : float | array of floats | &#8220;auto&#8221; | &#8220;peaks&#8221;.</p>
<blockquote>
<div><p>The time point(s) to plot. If &#8220;auto&#8221;, the number of <code class="docutils literal"><span class="pre">axes</span></code>
determines the amount of time point(s). If <code class="docutils literal"><span class="pre">axes</span></code> is also None,
10 topographies will be shown with a regular time spacing between
the first and last time instant. If &#8220;peaks&#8221;, finds time points
automatically by checking for local maxima in Global Field Power.</p>
</div></blockquote>
<p><strong>ch_type</strong> : &#8216;mag&#8217; | &#8216;grad&#8217; | &#8216;planar1&#8217; | &#8216;planar2&#8217; | &#8216;eeg&#8217; | None</p>
<blockquote>
<div><p>The channel type to plot. For &#8216;grad&#8217;, the gradiometers are collec-
ted in pairs and the RMS for each pair is plotted.
If None, then channels are chosen in the order given above.</p>
</div></blockquote>
<p><strong>layout</strong> : None | Layout</p>
<blockquote>
<div><p>Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct
layout file is inferred from the data; if no appropriate layout
file was found, the layout is automatically generated from the
sensor locations.</p>
</div></blockquote>
<p><strong>vmin</strong> : float | callable</p>
<blockquote>
<div><p>The value specfying the lower bound of the color range.
If None, and vmax is None, -vmax is used. Else np.min(data).
If callable, the output equals vmin(data).</p>
</div></blockquote>
<p><strong>vmax</strong> : float | callable</p>
<blockquote>
<div><p>The value specfying the upper bound of the color range.
If None, the maximum absolute value is used. If vmin is None,
but vmax is not, defaults to np.max(data).
If callable, the output equals vmax(data).</p>
</div></blockquote>
<p><strong>cmap</strong> : matplotlib colormap</p>
<blockquote>
<div><p>Colormap. Defaults to &#8216;RdBu_r&#8217;.</p>
</div></blockquote>
<p><strong>sensors</strong> : bool | str</p>
<blockquote>
<div><p>Add markers for sensor locations to the plot. Accepts matplotlib
plot format string (e.g., &#8216;r+&#8217; for red plusses). If True, a circle
will be used (via .add_artist). Defaults to True.</p>
</div></blockquote>
<p><strong>colorbar</strong> : bool</p>
<blockquote>
<div><p>Plot a colorbar.</p>
</div></blockquote>
<p><strong>scale</strong> : dict | float | None</p>
<blockquote>
<div><p>Scale the data for plotting. If None, defaults to 1e6 for eeg, 1e13
for grad and 1e15 for mag.</p>
</div></blockquote>
<p><strong>scale_time</strong> : float | None</p>
<blockquote>
<div><p>Scale the time labels. Defaults to 1e3 (ms).</p>
</div></blockquote>
<p><strong>unit</strong> : dict | str | None</p>
<blockquote>
<div><p>The unit of the channel type used for colorbar label. If
scale is None the unit is automatically determined.</p>
</div></blockquote>
<p><strong>res</strong> : int</p>
<blockquote>
<div><p>The resolution of the topomap image (n pixels along each side).</p>
</div></blockquote>
<p><strong>size</strong> : scalar</p>
<blockquote>
<div><p>Side length of the topomaps in inches (only applies when plotting
multiple topomaps at a time).</p>
</div></blockquote>
<p><strong>cbar_fmt</strong> : str</p>
<blockquote>
<div><p>String format for colorbar values.</p>
</div></blockquote>
<p><strong>time_format</strong> : str</p>
<blockquote>
<div><p>String format for topomap values. Defaults to <code class="docutils literal"><span class="pre">&quot;%01d</span> <span class="pre">ms&quot;</span></code>.</p>
</div></blockquote>
<p><strong>proj</strong> : bool | &#8216;interactive&#8217;</p>
<blockquote>
<div><p>If true SSP projections are applied before display. If
&#8216;interactive&#8217;, a check box for reversible selection of SSP
projection vectors will be shown.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Call pyplot.show() at the end.</p>
</div></blockquote>
<p><strong>show_names</strong> : bool | callable</p>
<blockquote>
<div><p>If True, show channel names on top of the map. If a callable is
passed, channel names will be formatted using the callable; e.g.,
to delete the prefix &#8216;MEG &#8216; from all channel names, pass the
function
lambda x: x.replace(&#8216;MEG &#8216;, &#8216;&#8217;). If <cite>mask</cite> is not None, only
significant sensors will be shown.</p>
</div></blockquote>
<p><strong>title</strong> : str | None</p>
<blockquote>
<div><p>Title. If None (default), no title is displayed.</p>
</div></blockquote>
<p><strong>mask</strong> : ndarray of bool, shape (n_channels, n_times) | None</p>
<blockquote>
<div><p>The channels to be marked as significant at a given time point.
Indicies set to <cite>True</cite> will be considered. Defaults to None.</p>
</div></blockquote>
<p><strong>mask_params</strong> : dict | None</p>
<blockquote>
<div><p>Additional plotting parameters for plotting significant sensors.
Default (None) equals:
<code class="docutils literal"><span class="pre">dict(marker='o',</span> <span class="pre">markerfacecolor='w',</span> <span class="pre">markeredgecolor='k',</span>
<span class="pre">linewidth=0,</span> <span class="pre">markersize=4)</span></code>.</p>
</div></blockquote>
<p><strong>outlines</strong> : &#8216;head&#8217; | &#8216;skirt&#8217; | dict | None</p>
<blockquote>
<div><p>The outlines to be drawn. If &#8216;head&#8217;, the default head scheme will
be drawn. If &#8216;skirt&#8217; the head scheme will be drawn, but sensors are
allowed to be plotted outside of the head circle. If dict, each key
refers to a tuple of x and y positions, the values in &#8216;mask_pos&#8217;
will serve as image mask, and the &#8216;autoshrink&#8217; (bool) field will
trigger automated shrinking of the positions due to points outside
the outline. Alternatively, a matplotlib patch object can be passed
for advanced masking options, either directly or as a function that
returns patches (required for multi-axis plots). If None, nothing
will be drawn. Defaults to &#8216;head&#8217;.</p>
</div></blockquote>
<p><strong>contours</strong> : int | False | None</p>
<blockquote>
<div><p>The number of contour lines to draw. If 0, no contours will be
drawn.</p>
</div></blockquote>
<p><strong>image_interp</strong> : str</p>
<blockquote>
<div><p>The image interpolation to be used. All matplotlib options are
accepted.</p>
</div></blockquote>
<p><strong>average</strong> : float | None</p>
<blockquote>
<div><p>The time window around a given time to be used for averaging
(seconds). For example, 0.01 would translate into window that
starts 5 ms before and ends 5 ms after a given time point.
Defaults to None, which means no averaging.</p>
</div></blockquote>
<p><strong>head_pos</strong> : dict | None</p>
<blockquote>
<div><p>If None (default), the sensors are positioned such that they span
the head circle. If dict, can have entries &#8216;center&#8217; (tuple) and
&#8216;scale&#8217; (tuple) for what the center and scale of the head should be
relative to the electrode locations.</p>
</div></blockquote>
<p><strong>axes</strong> : instance of Axes | list | None</p>
<blockquote class="last">
<div><p>The axes to plot to. If list, the list must be a list of Axes of
the same length as <code class="docutils literal"><span class="pre">times</span></code> (unless <code class="docutils literal"><span class="pre">times</span></code> is None). If
instance of Axes, <code class="docutils literal"><span class="pre">times</span></code> must be a float or a list of one float.
Defaults to None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.plot_white">
<code class="descname">plot_white</code><span class="sig-paren">(</span><em>noise_cov</em>, <em>show=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.plot_white" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot whitened evoked response</p>
<p>Plots the whitened evoked response and the whitened GFP as described in
<a class="reference internal" href="#r12" id="id1">[R12]</a>. If one single covariance object is passed, the GFP panel (bottom)
will depict different sensor types. If multiple covariance objects are
passed as a list, the left column will display the whitened evoked
responses for each channel based on the whitener from the noise
covariance that has the highest log-likelihood. The left column will
depict the whitened GFPs based on each estimator separately for each
sensor type. Instead of numbers of channels the GFP display shows the
estimated rank. The rank estimation will be printed by the logger for
each noise covariance estimator that is passed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>noise_cov</strong> : list | instance of Covariance | str</p>
<blockquote>
<div><p>The noise covariance as computed by <code class="docutils literal"><span class="pre">mne.cov.compute_covariance</span></code>.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Whether to show the figure or not. Defaults to True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib.figure.Figure</p>
<blockquote class="last">
<div><p>The figure object containing the plot.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R12]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> Engemann D. and Gramfort A. (2015) Automated model selection in
covariance estimation and spatial whitening of MEG and EEG
signals, vol. 108, 328-342, NeuroImage.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.rename_channels">
<code class="descname">rename_channels</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.rename_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mapping</strong> : dict | callable</p>
<blockquote class="last">
<div><p>a dictionary mapping the old channel to a new channel name
e.g. {&#8216;EEG061&#8217; : &#8216;EEG161&#8217;}. Can also be a callable function
that takes and returns a string (new in version 0.10.0).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.resample">
<code class="descname">resample</code><span class="sig-paren">(</span><em>sfreq</em>, <em>npad=100</em>, <em>window='boxcar'</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample data</p>
<p>This function operates in-place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sfreq</strong> : float</p>
<blockquote>
<div><p>New sample rate to use</p>
</div></blockquote>
<p><strong>npad</strong> : int</p>
<blockquote>
<div><p>Amount to pad the start and end of the data.</p>
</div></blockquote>
<p><strong>window</strong> : string or tuple</p>
<blockquote class="last">
<div><p>Window to use in resampling. See scipy.signal.resample.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save dataset to file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fname</strong> : string</p>
<blockquote class="last">
<div><p>Name of the file where to save the data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.savgol_filter">
<code class="descname">savgol_filter</code><span class="sig-paren">(</span><em>h_freq</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.savgol_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter the data using Savitzky-Golay polynomial method</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>h_freq</strong> : float</p>
<blockquote class="last">
<div><p>Approximate high cut-off frequency in Hz. Note that this
is not an exact cutoff, since Savitzky-Golay filtering <a class="reference internal" href="#r13" id="id3">[R13]</a> is
done using polynomial fits instead of FIR/IIR filtering.
This parameter is thus used to determine the length of the
window over which a 5th-order polynomial smoothing is used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal"><span class="pre">mne.io.Raw.filter</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Data are modified in-place.</p>
<p>For Savitzky-Golay low-pass approximation, see:</p>
<blockquote>
<div><a class="reference external" href="https://gist.github.com/Eric89GXL/bbac101d50176611136b">https://gist.github.com/Eric89GXL/bbac101d50176611136b</a></div></blockquote>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R13]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> Savitzky, A., Golay, M.J.E. (1964). &#8220;Smoothing and
Differentiation of Data by Simplified Least Squares
Procedures&#8221;. Analytical Chemistry 36 (8): 1627-39.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mne</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">path</span> <span class="k">as</span> <span class="n">op</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked_fname</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mne</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">data_path</span><span class="p">(),</span> <span class="s">&#39;MEG&#39;</span><span class="p">,</span> <span class="s">&#39;sample&#39;</span><span class="p">,</span> <span class="s">&#39;sample_audvis-ave.fif&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_evokeds</span><span class="p">(</span><span class="n">evoked_fname</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="mf">10.</span><span class="p">)</span>  <span class="c"># low-pass at around 10 Hz </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.set_channel_types">
<code class="descname">set_channel_types</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.set_channel_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the sensor type of channels.</p>
<dl class="docutils">
<dt>Note: The following sensor types are accepted:</dt>
<dd>ecg, eeg, emg, eog, exci, ias, misc, resp, seeg, stim, syst</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mapping</strong> : dict</p>
<blockquote class="last">
<div><p>a dictionary mapping a channel to a sensor type (str)
{&#8216;EEG061&#8217;: &#8216;eog&#8217;}.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.set_montage">
<code class="descname">set_montage</code><span class="sig-paren">(</span><em>montage</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.set_montage" title="Permalink to this definition">¶</a></dt>
<dd><p>Set EEG sensor configuration</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>montage</strong> : instance of Montage or DigMontage</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Operates in place.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.shift_time">
<code class="descname">shift_time</code><span class="sig-paren">(</span><em>tshift</em>, <em>relative=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.shift_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift time scale in evoked data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tshift</strong> : float</p>
<blockquote>
<div><p>The amount of time shift to be applied if relative is True
else the first time point. When relative is True, positive value
of tshift moves the data forward while negative tshift moves it
backward.</p>
</div></blockquote>
<p><strong>relative</strong> : bool</p>
<blockquote class="last">
<div><p>If true, move the time backwards or forwards by specified amount.
Else, set the starting time point to the value of tshift.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Maximum accuracy of time shift is 1 / evoked.info[&#8216;sfreq&#8217;]</p>
</dd></dl>

<dl class="method">
<dt id="mne.epochs.EvokedArray.to_data_frame">
<code class="descname">to_data_frame</code><span class="sig-paren">(</span><em>picks=None</em>, <em>index=None</em>, <em>scale_time=1000.0</em>, <em>scalings=None</em>, <em>copy=True</em>, <em>start=None</em>, <em>stop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.epochs.EvokedArray.to_data_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Export data in tabular structure as a pandas DataFrame.</p>
<p>Columns and indices will depend on the object being converted.
Generally this will include as much relevant information as
possible for the data type being converted. This makes it easy
to convert data for use in packages that utilize dataframes,
such as statsmodels or seaborn.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>If None only MEG and EEG channels are kept
otherwise the channels indices in picks are kept.</p>
</div></blockquote>
<p><strong>index</strong> : tuple of str | None</p>
<blockquote>
<div><p>Column to be used as index for the data. Valid string options
are &#8216;epoch&#8217;, &#8216;time&#8217; and &#8216;condition&#8217;. If None, all three info
columns will be included in the table as categorial data.</p>
</div></blockquote>
<p><strong>scale_time</strong> : float</p>
<blockquote>
<div><p>Scaling to be applied to time units.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>Scaling to be applied to the channels picked. If None, defaults to
<code class="docutils literal"><span class="pre">scalings=dict(eeg=1e6,</span> <span class="pre">grad=1e13,</span> <span class="pre">mag=1e15,</span> <span class="pre">misc=1.0)</span></code>.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>If true, data will be copied. Else data may be modified in place.</p>
</div></blockquote>
<p><strong>start</strong> : int | None</p>
<blockquote>
<div><p>If it is a Raw object, this defines a starting index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</div></blockquote>
<p><strong>stop</strong> : int | None</p>
<blockquote>
<div><p>If it is a Raw object, this defines a stop index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>df</strong> : instance of pandas.core.DataFrame</p>
<blockquote class="last">
<div><p>A dataframe suitable for usage with other
statistical/plotting/analysis packages. Column/Index values will
depend on the object type being converted, but should be
human-readable.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2012-2015, MNE Developers.<br/>
    </p>
  </div>
</footer>
  </body>
</html>