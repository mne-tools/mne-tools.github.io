<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mne.io.RawArray &mdash; MNE 0.9.dev0 documentation</title>
    
    <link rel="stylesheet" href="../_static/navy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.9.dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="MNE 0.9.dev0 documentation" href="../index.html" />
    <link rel="up" title="API Reference" href="../python_reference.html" />
    <link rel="next" title="mne.create_info" href="mne.create_info.html" />
    <link rel="prev" title="mne.EpochsArray" href="mne.EpochsArray.html" />

    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="http://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>


  </head>
  <body>

<div style="background-color: white; text-align: left; padding: 10px 7px 15px 15px; min-width: 910px">
<div style="float: left">
<a href="../index.html"><img src="../_static/mne_logo.png" border="0" alt="py4sci"/></a>
</div>

<div style="float: right">
<a href="../index.html"><img src="../_static/institutions.png" border="0" alt="py4sci"/></a>
</div>
<br style="clear:both"/>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../np-modindex.html" title="Python Module Index"
             >modules</a></li>
        <li class="right" >
          <a href="mne.create_info.html" title="mne.create_info"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mne.EpochsArray.html" title="mne.EpochsArray"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Home</a>&nbsp;|&nbsp;</li>
        <li><a href="../manual.html">Manual</a>&nbsp;|&nbsp;</li>
        <li><a href="../mne-python.html">Python</a>&nbsp;|&nbsp;</li>
        <li><a href="../cite.html">Cite MNE</a>&nbsp;|&nbsp;</li>
        <!-- <li><a href="../search.html">Search</a></li> -->

          <li><a href="../mne-python.html" >MNE with Python</a> &raquo;</li>
          <li><a href="../python_reference.html" accesskey="U">API Reference</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../manual.html">Manual</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../mne-python.html">MNE with Python</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../getting_started.html">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../advanced_setup.html">Advanced installation and setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python_tutorial.html">Tutorial: MEG and EEG data processing with MNE and Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mne_report_tutorial.html">Tutorial: Getting started with MNE report command</a></li>
<li class="toctree-l2"><a class="reference internal" href="../auto_examples/index.html">Examples</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../python_reference.html">API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../whats_new.html">What&#8217;s new</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributing.html">Contributing to <em>mne-python</em> source code</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../mne-cpp.html">MNE with CPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cite.html">Cite MNE and MNE-Python</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><h3>Versions</h3>
<ul class="current">
    <li class="toctree-l1"><a href=http://martinos.org/mne/stable>Stable</a></li>
    <li class="toctree-l1"><a href=http://martinos.org/mne/dev>Development</a></li>
</ul>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="mne-io-rawarray">
<h1>mne.io.RawArray<a class="headerlink" href="#mne-io-rawarray" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="mne.io.RawArray">
<em class="property">class </em><tt class="descclassname">mne.io.</tt><tt class="descname">RawArray</tt><big>(</big><em>data</em>, <em>info</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Raw object from numpy array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array, shape (n_channels, n_times)</p>
<blockquote>
<div><p>The channels&#8217; time series.</p>
</div></blockquote>
<p><strong>info</strong> : instance of Info</p>
<blockquote>
<div><p>Info dictionary. Consider using <tt class="docutils literal"><span class="pre">create_info</span></tt> to populate
this structure.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.add_events" title="mne.io.RawArray.add_events"><tt class="xref py py-obj docutils literal"><span class="pre">add_events</span></tt></a>(events[,&nbsp;stim_channel])</td>
<td>Add events to stim channel</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.add_proj" title="mne.io.RawArray.add_proj"><tt class="xref py py-obj docutils literal"><span class="pre">add_proj</span></tt></a>(projs[,&nbsp;remove_existing])</td>
<td>Add SSP projection vectors</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.anonymize" title="mne.io.RawArray.anonymize"><tt class="xref py py-obj docutils literal"><span class="pre">anonymize</span></tt></a>()</td>
<td>Anonymize data</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.append" title="mne.io.RawArray.append"><tt class="xref py py-obj docutils literal"><span class="pre">append</span></tt></a>(raws[,&nbsp;preload])</td>
<td>Concatenate raw instances as if they were continuous</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.apply_function" title="mne.io.RawArray.apply_function"><tt class="xref py py-obj docutils literal"><span class="pre">apply_function</span></tt></a>(fun,&nbsp;picks,&nbsp;dtype,&nbsp;n_jobs,&nbsp;...)</td>
<td>Apply a function to a subset of channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.apply_hilbert" title="mne.io.RawArray.apply_hilbert"><tt class="xref py py-obj docutils literal"><span class="pre">apply_hilbert</span></tt></a>(picks[,&nbsp;envelope,&nbsp;n_jobs,&nbsp;verbose])</td>
<td>Compute analytic signal or envelope for a subset of channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.apply_proj" title="mne.io.RawArray.apply_proj"><tt class="xref py py-obj docutils literal"><span class="pre">apply_proj</span></tt></a>()</td>
<td>Apply the signal space projection (SSP) operators to the data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.as_data_frame" title="mne.io.RawArray.as_data_frame"><tt class="xref py py-obj docutils literal"><span class="pre">as_data_frame</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>DEPRECATED: &#8216;as_data_frame&#8217; will be removed in v0.10.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.close" title="mne.io.RawArray.close"><tt class="xref py py-obj docutils literal"><span class="pre">close</span></tt></a>()</td>
<td>Clean up the object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.copy" title="mne.io.RawArray.copy"><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt></a>()</td>
<td>Return copy of Raw instance</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.crop" title="mne.io.RawArray.crop"><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt></a>([tmin,&nbsp;tmax,&nbsp;copy])</td>
<td>Crop raw data file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.del_proj" title="mne.io.RawArray.del_proj"><tt class="xref py py-obj docutils literal"><span class="pre">del_proj</span></tt></a>(idx)</td>
<td>Remove SSP projection vector</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.drop_channels" title="mne.io.RawArray.drop_channels"><tt class="xref py py-obj docutils literal"><span class="pre">drop_channels</span></tt></a>(ch_names[,&nbsp;copy])</td>
<td>Drop some channels</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.estimate_rank" title="mne.io.RawArray.estimate_rank"><tt class="xref py py-obj docutils literal"><span class="pre">estimate_rank</span></tt></a>([tstart,&nbsp;tstop,&nbsp;tol,&nbsp;...])</td>
<td>Estimate rank of the raw data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.filter" title="mne.io.RawArray.filter"><tt class="xref py py-obj docutils literal"><span class="pre">filter</span></tt></a>(l_freq,&nbsp;h_freq[,&nbsp;picks,&nbsp;...])</td>
<td>Filter a subset of channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.index_as_time" title="mne.io.RawArray.index_as_time"><tt class="xref py py-obj docutils literal"><span class="pre">index_as_time</span></tt></a>(index[,&nbsp;use_first_samp])</td>
<td>Convert indices to time</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.interpolate_bads" title="mne.io.RawArray.interpolate_bads"><tt class="xref py py-obj docutils literal"><span class="pre">interpolate_bads</span></tt></a>([reset_bads,&nbsp;mode])</td>
<td>Interpolate bad MEG and EEG channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.load_bad_channels" title="mne.io.RawArray.load_bad_channels"><tt class="xref py py-obj docutils literal"><span class="pre">load_bad_channels</span></tt></a>([bad_file,&nbsp;force])</td>
<td>Mark channels as bad from a text file, in the style</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.notch_filter" title="mne.io.RawArray.notch_filter"><tt class="xref py py-obj docutils literal"><span class="pre">notch_filter</span></tt></a>(freqs[,&nbsp;picks,&nbsp;filter_length,&nbsp;...])</td>
<td>Notch filter a subset of channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.pick_channels" title="mne.io.RawArray.pick_channels"><tt class="xref py py-obj docutils literal"><span class="pre">pick_channels</span></tt></a>(ch_names[,&nbsp;copy])</td>
<td>Pick some channels</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.pick_types" title="mne.io.RawArray.pick_types"><tt class="xref py py-obj docutils literal"><span class="pre">pick_types</span></tt></a>([meg,&nbsp;eeg,&nbsp;stim,&nbsp;eog,&nbsp;ecg,&nbsp;emg,&nbsp;...])</td>
<td>Pick some channels by type and names</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.plot" title="mne.io.RawArray.plot"><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt></a>([events,&nbsp;duration,&nbsp;start,&nbsp;n_channels,&nbsp;...])</td>
<td>Plot raw data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.plot_projs_topomap" title="mne.io.RawArray.plot_projs_topomap"><tt class="xref py py-obj docutils literal"><span class="pre">plot_projs_topomap</span></tt></a>([ch_type,&nbsp;layout])</td>
<td>Plot SSP vector</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.plot_psd" title="mne.io.RawArray.plot_psd"><tt class="xref py py-obj docutils literal"><span class="pre">plot_psd</span></tt></a>([tmin,&nbsp;tmax,&nbsp;fmin,&nbsp;fmax,&nbsp;proj,&nbsp;...])</td>
<td>Plot the power spectral density across channels</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.plot_psds" title="mne.io.RawArray.plot_psds"><tt class="xref py py-obj docutils literal"><span class="pre">plot_psds</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>Plot the power spectral density across channels</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.preload_data" title="mne.io.RawArray.preload_data"><tt class="xref py py-obj docutils literal"><span class="pre">preload_data</span></tt></a>([verbose])</td>
<td>Preload raw data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.rename_channels" title="mne.io.RawArray.rename_channels"><tt class="xref py py-obj docutils literal"><span class="pre">rename_channels</span></tt></a>(mapping)</td>
<td>Rename channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.resample" title="mne.io.RawArray.resample"><tt class="xref py py-obj docutils literal"><span class="pre">resample</span></tt></a>(sfreq[,&nbsp;npad,&nbsp;window,&nbsp;stim_picks,&nbsp;...])</td>
<td>Resample data channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.save" title="mne.io.RawArray.save"><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt></a>(fname[,&nbsp;picks,&nbsp;tmin,&nbsp;tmax,&nbsp;...])</td>
<td>Save raw data to file</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.set_channel_types" title="mne.io.RawArray.set_channel_types"><tt class="xref py py-obj docutils literal"><span class="pre">set_channel_types</span></tt></a>(mapping)</td>
<td>Define the sensor type of channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.set_montage" title="mne.io.RawArray.set_montage"><tt class="xref py py-obj docutils literal"><span class="pre">set_montage</span></tt></a>(montage)</td>
<td>Set EEG sensor configuration</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.time_as_index" title="mne.io.RawArray.time_as_index"><tt class="xref py py-obj docutils literal"><span class="pre">time_as_index</span></tt></a>(times[,&nbsp;use_first_samp])</td>
<td>Convert time to indices</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.to_data_frame" title="mne.io.RawArray.to_data_frame"><tt class="xref py py-obj docutils literal"><span class="pre">to_data_frame</span></tt></a>([picks,&nbsp;index,&nbsp;scale_time,&nbsp;...])</td>
<td>Export data in tabular structure as a pandas DataFrame.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.to_nitime" title="mne.io.RawArray.to_nitime"><tt class="xref py py-obj docutils literal"><span class="pre">to_nitime</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>DEPRECATED: to_nitime will be removed in v0.10</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mne.io.RawArray.__init__">
<tt class="descname">__init__</tt><big>(</big><em>data</em>, <em>info</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.add_events">
<tt class="descname">add_events</tt><big>(</big><em>events</em>, <em>stim_channel=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.add_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Add events to stim channel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>events</strong> : ndarray, shape (n_events, 3)</p>
<blockquote>
<div><p>Events to add. The first column specifies the sample number of
each event, the second column is ignored, and the third column
provides the event value. If events already exist in the Raw
instance at the given sample numbers, the event values will be
added together.</p>
</div></blockquote>
<p><strong>stim_channel</strong> : str | None</p>
<blockquote class="last">
<div><p>Name of the stim channel to add to. If None, the config variable
&#8216;MNE_STIM_CHANNEL&#8217; is used. If this is not found, it will default
to &#8216;STI 014&#8217;.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Data must be preloaded in order to add events.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.add_proj">
<tt class="descname">add_proj</tt><big>(</big><em>projs</em>, <em>remove_existing=False</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.add_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Add SSP projection vectors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>projs</strong> : list</p>
<blockquote>
<div><p>List with projection vectors.</p>
</div></blockquote>
<p><strong>remove_existing</strong> : bool</p>
<blockquote>
<div><p>Remove the projection vectors currently in the file.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
<blockquote class="last">
<div><p>The data container.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.anonymize">
<tt class="descname">anonymize</tt><big>(</big><big>)</big><a class="headerlink" href="#mne.io.RawArray.anonymize" title="Permalink to this definition">¶</a></dt>
<dd><p>Anonymize data</p>
<p>This function will remove info[&#8216;subject_info&#8217;] if it exists.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.append">
<tt class="descname">append</tt><big>(</big><em>raws</em>, <em>preload=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate raw instances as if they were continuous</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>raws</strong> : list, or Raw instance</p>
<blockquote>
<div><p>list of Raw instances to concatenate to the current instance
(in order), or a single raw instance to concatenate.</p>
</div></blockquote>
<p><strong>preload</strong> : bool, str, or None (default None)</p>
<blockquote class="last">
<div><p>Preload data into memory for data manipulation and faster indexing.
If True, the data will be preloaded into memory (fast, requires
large amount of memory). If preload is a string, preload is the
file name of a memory-mapped file which is used to store the data
on the hard drive (slower, requires less memory). If preload is
None, preload=True or False is inferred using the preload status
of the raw files passed in.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.apply_function">
<tt class="descname">apply_function</tt><big>(</big><em>fun</em>, <em>picks</em>, <em>dtype</em>, <em>n_jobs</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.apply_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function to a subset of channels.</p>
<p>The function &#8220;fun&#8221; is applied to the channels defined in &#8220;picks&#8221;. The
data of the Raw object is modified inplace. If the function returns
a different data type (e.g. numpy.complex) it must be specified using
the dtype parameter, which causes the data type used for representing
the raw data to change.</p>
<p>The Raw object has to be constructed using preload=True (or string).</p>
<dl class="docutils">
<dt>Note: If n_jobs &gt; 1, more memory is required as &#8220;len(picks) * n_times&#8221;</dt>
<dd>additional time points need to be temporaily stored in memory.</dd>
<dt>Note: If the data type changes (dtype != None), more memory is required</dt>
<dd>since the original and the converted data needs to be stored in
memory.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fun</strong> : function</p>
<blockquote>
<div><p>A function to be applied to the channels. The first argument of
fun has to be a timeseries (numpy.ndarray). The function must
return an numpy.ndarray with the same size as the input.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>Indices of channels to apply the function to. If None, all
M-EEG channels are used.</p>
</div></blockquote>
<p><strong>dtype</strong> : numpy.dtype</p>
<blockquote>
<div><p>Data type to use for raw data after applying the function. If None
the data type is not modified.</p>
</div></blockquote>
<p><strong>n_jobs: int</strong> :</p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
<p><strong>*args :</strong> :</p>
<blockquote>
<div><p>Additional positional arguments to pass to fun (first pos. argument
of fun is the timeseries of a channel).</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote class="last">
<div><p>Keyword arguments to pass to fun. Note that if &#8220;verbose&#8221; is passed
as a member of <tt class="docutils literal"><span class="pre">kwargs</span></tt>, it will be consumed and will override
the default mne-python verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.apply_hilbert">
<tt class="descname">apply_hilbert</tt><big>(</big><em>picks</em>, <em>envelope=False</em>, <em>n_jobs=1</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.apply_hilbert" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute analytic signal or envelope for a subset of channels.</p>
<p>If envelope=False, the analytic signal for the channels defined in
&#8220;picks&#8221; is computed and the data of the Raw object is converted to
a complex representation (the analytic signal is complex valued).</p>
<p>If envelope=True, the absolute value of the analytic signal for the
channels defined in &#8220;picks&#8221; is computed, resulting in the envelope
signal.</p>
<dl class="docutils">
<dt>Note: DO NOT use envelope=True if you intend to compute an inverse</dt>
<dd>solution from the raw data. If you want to compute the
envelope in source space, use envelope=False and compute the
envelope after the inverse solution has been obtained.</dd>
<dt>Note: If envelope=False, more memory is required since the original</dt>
<dd>raw data as well as the analytic signal have temporarily to
be stored in memory.</dd>
<dt>Note: If n_jobs &gt; 1 and envelope=True, more memory is required as</dt>
<dd>&#8220;len(picks) * n_times&#8221; additional time points need to be
temporaily stored in memory.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int</p>
<blockquote>
<div><p>Indices of channels to apply the function to.</p>
</div></blockquote>
<p><strong>envelope</strong> : bool (default: False)</p>
<blockquote>
<div><p>Compute the envelope signal of each channel.</p>
</div></blockquote>
<p><strong>n_jobs: int</strong> :</p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The analytic signal &#8220;x_a(t)&#8221; of &#8220;x(t)&#8221; is:</p>
<div class="highlight-python"><div class="highlight"><pre>x_a = F^{-1}(F(x) 2U) = x + i y
</pre></div>
</div>
<p>where &#8220;F&#8221; is the Fourier transform, &#8220;U&#8221; the unit step function,
and &#8220;y&#8221; the Hilbert transform of &#8220;x&#8221;. One usage of the analytic
signal is the computation of the envelope signal, which is given by
&#8220;e(t) = abs(x_a(t))&#8221;. Due to the linearity of Hilbert transform and the
MNE inverse solution, the enevlope in source space can be obtained
by computing the analytic signal in sensor space, applying the MNE
inverse, and computing the envelope in source space.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.apply_proj">
<tt class="descname">apply_proj</tt><big>(</big><big>)</big><a class="headerlink" href="#mne.io.RawArray.apply_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the signal space projection (SSP) operators to the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
<blockquote class="last">
<div><p>The instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Once the projectors have been applied, they can no longer be
removed. It is usually not recommended to apply the projectors at
too early stages, as they are applied automatically later on
(e.g. when computing inverse solutions).
Hint: using the copy method individual projection vectors
can be tested without affecting the original data.
With evoked data, consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">projs_a</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_proj</span><span class="p">(</span><span class="s">&#39;proj_a.fif&#39;</span><span class="p">)</span>
<span class="n">projs_b</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_proj</span><span class="p">(</span><span class="s">&#39;proj_b.fif&#39;</span><span class="p">)</span>
<span class="c"># add the first, copy, apply and see ...</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">add_proj</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c"># add the second, copy, apply and see ...</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">add_proj</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c"># drop the first and see again</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">del_proj</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span>  <span class="c"># finally keep both</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.as_data_frame">
<tt class="descname">as_data_frame</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.as_data_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>DEPRECATED: &#8216;as_data_frame&#8217; will be removed in v0.10. Use &#8216;to_data_frame&#8217; instead.</p>
<p>Get the epochs as Pandas DataFrame</p>
<blockquote>
<div><p>Export raw data in tabular structure with MEG channels.</p>
<p>Caveat! To save memory, depending on selected data size consider
setting copy to False.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><blockquote>
<div><p>If None only MEG and EEG channels are kept
otherwise the channels indices in picks are kept.</p>
</div></blockquote>
<dl class="docutils">
<dt>start <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd><p class="first last">Data-extraction start index. If None, data will be exported from
the first sample.</p>
</dd>
<dt>stop <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd><p class="first last">Data-extraction stop index. If None, data will be exported to the
last index.</p>
</dd>
<dt>scale_time <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Scaling to be applied to time units.</p>
</dd>
<dt>scalings <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">Scaling to be applied to the channels picked. If None, defaults to
<tt class="docutils literal"><span class="pre">scalings=dict(eeg=1e6,</span> <span class="pre">grad=1e13,</span> <span class="pre">mag=1e15,</span> <span class="pre">misc=1.0)</span></tt>.</p>
</dd>
<dt>use_time_index <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If False, times will be included as in the data table, else it will
be used as index object.</p>
</dd>
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If true, data will be copied. Else data may be modified in place.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>df</strong> : instance of pandas.core.DataFrame</p>
<blockquote class="last">
<div><p>Raw data exported into tabular data structure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mne.io.RawArray.ch_names">
<tt class="descname">ch_names</tt><a class="headerlink" href="#mne.io.RawArray.ch_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Channel names</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#mne.io.RawArray.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up the object.</p>
<p>Does nothing for objects that close their file descriptors.
Things like RawFIF will override this method.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#mne.io.RawArray.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return copy of Raw instance</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.crop">
<tt class="descname">crop</tt><big>(</big><em>tmin=0.0</em>, <em>tmax=None</em>, <em>copy=True</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop raw data file.</p>
<p>Limit the data from the raw file to go between specific times. Note
that the new tmin is assumed to be t=0 for all subsequently called
functions (e.g., time_as_index, or Epochs). New first_samp and
last_samp are set accordingly. And data are modified in-place when
called with copy=False.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tmin</strong> : float</p>
<blockquote>
<div><p>New start time in seconds (must be &gt;= 0).</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote>
<div><p>New end time in seconds of the data (cannot exceed data duration).</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>If False Raw is cropped in place.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw</strong> : instance of Raw</p>
<blockquote class="last">
<div><p>The cropped raw object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.del_proj">
<tt class="descname">del_proj</tt><big>(</big><em>idx</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.del_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove SSP projection vector</p>
<dl class="docutils">
<dt>Note: The projection vector can only be removed if it is inactive</dt>
<dd>(has not been applied to the data).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>idx</strong> : int</p>
<blockquote>
<div><p>Index of the projector to remove.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.drop_channels">
<tt class="descname">drop_channels</tt><big>(</big><em>ch_names</em>, <em>copy=False</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.drop_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop some channels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_names</strong> : list</p>
<blockquote>
<div><p>The list of channels to remove.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote class="last">
<div><p>If True, returns new instance. Else, modifies in place. Defaults to
False.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.estimate_rank">
<tt class="descname">estimate_rank</tt><big>(</big><em>tstart=0.0</em>, <em>tstop=30.0</em>, <em>tol=0.0001</em>, <em>return_singular=False</em>, <em>picks=None</em>, <em>scalings='norm'</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.estimate_rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate rank of the raw data</p>
<p>This function is meant to provide a reasonable estimate of the rank.
The true rank of the data depends on many factors, so use at your
own risk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tstart</strong> : float</p>
<blockquote>
<div><p>Start time to use for rank estimation. Default is 0.0.</p>
</div></blockquote>
<p><strong>tstop</strong> : float | None</p>
<blockquote>
<div><p>End time to use for rank estimation. Default is 30.0.
If None, the end time of the raw file is used.</p>
</div></blockquote>
<p><strong>tol</strong> : float</p>
<blockquote>
<div><p>Tolerance for singular values to consider non-zero in
calculating the rank. The singular values are calculated
in this method such that independent data are expected to
have singular value around one.</p>
</div></blockquote>
<p><strong>return_singular</strong> : bool</p>
<blockquote>
<div><p>If True, also return the singular values that were used
to determine the rank.</p>
</div></blockquote>
<p><strong>picks</strong> : array_like of int, shape (n_selected_channels,)</p>
<blockquote>
<div><p>The channels to be considered for rank estimation.
If None (default) meg and eeg channels are included.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | &#8216;norm&#8217;</p>
<blockquote>
<div><p>To achieve reliable rank estimation on multiple sensors,
sensors have to be rescaled. This parameter controls the
rescaling. If dict, it will update the
following dict of defaults:</p>
<blockquote>
<div><p>dict(mag=1e11, grad=1e9, eeg=1e5)</p>
</div></blockquote>
<p>If &#8216;norm&#8217; data will be scaled by internally computed
channel-wise norms.
Defaults to &#8216;norm&#8217;.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rank</strong> : int</p>
<blockquote>
<div><p>Estimated rank of the data.</p>
</div></blockquote>
<p><strong>s</strong> : array</p>
<blockquote class="last">
<div><p>If return_singular is True, the singular values that were
thresholded to determine the rank are also returned.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If data are not pre-loaded, the appropriate data will be loaded
by this function (can be memory intensive).</p>
<p>Projectors are not taken into account unless they have been applied
to the data using apply_proj(), since it is not always possible
to tell whether or not projectors have been applied previously.</p>
<p>Bad channels will be excluded from calculations.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.filter">
<tt class="descname">filter</tt><big>(</big><em>l_freq</em>, <em>h_freq</em>, <em>picks=None</em>, <em>filter_length='10s'</em>, <em>l_trans_bandwidth=0.5</em>, <em>h_trans_bandwidth=0.5</em>, <em>n_jobs=1</em>, <em>method='fft'</em>, <em>iir_params=None</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter a subset of channels.</p>
<p>Applies a zero-phase low-pass, high-pass, band-pass, or band-stop
filter to the channels selected by &#8220;picks&#8221;. The data of the Raw
object is modified inplace.</p>
<p>The Raw object has to be constructed using preload=True (or string).</p>
<p>l_freq and h_freq are the frequencies below which and above which,
respectively, to filter out of the data. Thus the uses are:</p>
<blockquote>
<div>l_freq &lt; h_freq: band-pass filter
l_freq &gt; h_freq: band-stop filter
l_freq is not None, h_freq is None: high-pass filter
l_freq is None, h_freq is not None: low-pass filter</div></blockquote>
<p>If n_jobs &gt; 1, more memory is required as &#8220;len(picks) * n_times&#8221;
additional time points need to be temporarily stored in memory.</p>
<p>self.info[&#8216;lowpass&#8217;] and self.info[&#8216;highpass&#8217;] are only updated
with picks=None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>l_freq</strong> : float | None</p>
<blockquote>
<div><p>Low cut-off frequency in Hz. If None the data are only low-passed.</p>
</div></blockquote>
<p><strong>h_freq</strong> : float | None</p>
<blockquote>
<div><p>High cut-off frequency in Hz. If None the data are only
high-passed.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>Indices of channels to filter. If None only the data (MEG/EEG)
channels will be filtered.</p>
</div></blockquote>
<p><strong>filter_length</strong> : str (Default: &#8216;10s&#8217;) | int | None</p>
<blockquote>
<div><p>Length of the filter to use. If None or &#8220;len(x) &lt; filter_length&#8221;,
the filter length used is len(x). Otherwise, if int, overlap-add
filtering with a filter of the specified length in samples) is
used (faster for long signals). If str, a human-readable time in
units of &#8220;s&#8221; or &#8220;ms&#8221; (e.g., &#8220;10s&#8221; or &#8220;5500ms&#8221;) will be converted
to the shortest power-of-two length at least that duration.
Not used for &#8216;iir&#8217; filters.</p>
</div></blockquote>
<p><strong>l_trans_bandwidth</strong> : float</p>
<blockquote>
<div><p>Width of the transition band at the low cut-off frequency in Hz
(high pass or cutoff 1 in bandpass). Not used if &#8216;order&#8217; is
specified in iir_params.</p>
</div></blockquote>
<p><strong>h_trans_bandwidth</strong> : float</p>
<blockquote>
<div><p>Width of the transition band at the high cut-off frequency in Hz
(low pass or cutoff 2 in bandpass). Not used if &#8216;order&#8217; is
specified in iir_params.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int | str</p>
<blockquote>
<div><p>Number of jobs to run in parallel. Can be &#8216;cuda&#8217; if scikits.cuda
is installed properly, CUDA is initialized, and method=&#8217;fft&#8217;.</p>
</div></blockquote>
<p><strong>method</strong> : str</p>
<blockquote>
<div><p>&#8216;fft&#8217; will use overlap-add FIR filtering, &#8216;iir&#8217; will use IIR
forward-backward filtering (via filtfilt).</p>
</div></blockquote>
<p><strong>iir_params</strong> : dict | None</p>
<blockquote>
<div><p>Dictionary of parameters to use for IIR filtering.
See mne.filter.construct_iir_filter for details. If iir_params
is None and method=&#8221;iir&#8221;, 4th order Butterworth will be used.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.index_as_time">
<tt class="descname">index_as_time</tt><big>(</big><em>index</em>, <em>use_first_samp=False</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.index_as_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert indices to time</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>index</strong> : list-like | int</p>
<blockquote>
<div><p>List of ints or int representing points in time.</p>
</div></blockquote>
<p><strong>use_first_samp</strong> : boolean</p>
<blockquote>
<div><p>If True, the time returned is relative to the session onset, else
relative to the recording onset.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>times</strong> : ndarray</p>
<blockquote class="last">
<div><p>Times corresponding to the index supplied.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.interpolate_bads">
<tt class="descname">interpolate_bads</tt><big>(</big><em>reset_bads=True</em>, <em>mode='accurate'</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.interpolate_bads" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate bad MEG and EEG channels.</p>
<p>Operates in place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reset_bads</strong> : bool</p>
<blockquote>
<div><p>If True, remove the bads from info.</p>
</div></blockquote>
<p><strong>mode</strong> : str</p>
<blockquote>
<div><p>Either <cite>&#8216;accurate&#8217;</cite> or <cite>&#8216;fast&#8217;</cite>, determines the quality of the
Legendre polynomial expansion used for interpolation of MEG
channels.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : mne.io.Raw, mne.Epochs or mne.Evoked</p>
<blockquote class="last">
<div><p>The interpolated data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.load_bad_channels">
<tt class="descname">load_bad_channels</tt><big>(</big><em>bad_file=None</em>, <em>force=False</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.load_bad_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark channels as bad from a text file, in the style
(mostly) of the C function mne_mark_bad_channels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bad_file</strong> : string</p>
<blockquote>
<div><p>File name of the text file containing bad channels
If bad_file = None, bad channels are cleared, but this
is more easily done directly as raw.info[&#8216;bads&#8217;] = [].</p>
</div></blockquote>
<p><strong>force</strong> : boolean</p>
<blockquote class="last">
<div><p>Whether or not to force bad channel marking (of those
that exist) if channels are not found, instead of
raising an error.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mne.io.RawArray.n_times">
<tt class="descname">n_times</tt><a class="headerlink" href="#mne.io.RawArray.n_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of time points</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.notch_filter">
<tt class="descname">notch_filter</tt><big>(</big><em>freqs</em>, <em>picks=None</em>, <em>filter_length='10s'</em>, <em>notch_widths=None</em>, <em>trans_bandwidth=1.0</em>, <em>n_jobs=1</em>, <em>method='fft'</em>, <em>iir_params=None</em>, <em>mt_bandwidth=None</em>, <em>p_value=0.05</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.notch_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Notch filter a subset of channels.</p>
<p>Applies a zero-phase notch filter to the channels selected by
&#8220;picks&#8221;. The data of the Raw object is modified inplace.</p>
<p>The Raw object has to be constructed using preload=True (or string).</p>
<dl class="docutils">
<dt>Note: If n_jobs &gt; 1, more memory is required as &#8220;len(picks) * n_times&#8221;</dt>
<dd>additional time points need to be temporaily stored in memory.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>freqs</strong> : float | array of float | None</p>
<blockquote>
<div><p>Specific frequencies to filter out from data, e.g.,
np.arange(60, 241, 60) in the US or np.arange(50, 251, 50) in
Europe. None can only be used with the mode &#8216;spectrum_fit&#8217;,
where an F test is used to find sinusoidal components.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>Indices of channels to filter. If None only the data (MEG/EEG)
channels will be filtered.</p>
</div></blockquote>
<p><strong>filter_length</strong> : str (Default: &#8216;10s&#8217;) | int | None</p>
<blockquote>
<div><p>Length of the filter to use. If None or &#8220;len(x) &lt; filter_length&#8221;,
the filter length used is len(x). Otherwise, if int, overlap-add
filtering with a filter of the specified length in samples) is
used (faster for long signals). If str, a human-readable time in
units of &#8220;s&#8221; or &#8220;ms&#8221; (e.g., &#8220;10s&#8221; or &#8220;5500ms&#8221;) will be converted
to the shortest power-of-two length at least that duration.
Not used for &#8216;iir&#8217; filters.</p>
</div></blockquote>
<p><strong>notch_widths</strong> : float | array of float | None</p>
<blockquote>
<div><p>Width of each stop band (centred at each freq in freqs) in Hz.
If None, freqs / 200 is used.</p>
</div></blockquote>
<p><strong>trans_bandwidth</strong> : float</p>
<blockquote>
<div><p>Width of the transition band in Hz.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int | str</p>
<blockquote>
<div><p>Number of jobs to run in parallel. Can be &#8216;cuda&#8217; if scikits.cuda
is installed properly, CUDA is initialized, and method=&#8217;fft&#8217;.</p>
</div></blockquote>
<p><strong>method</strong> : str</p>
<blockquote>
<div><p>&#8216;fft&#8217; will use overlap-add FIR filtering, &#8216;iir&#8217; will use IIR
forward-backward filtering (via filtfilt). &#8216;spectrum_fit&#8217; will
use multi-taper estimation of sinusoidal components.</p>
</div></blockquote>
<p><strong>iir_params</strong> : dict | None</p>
<blockquote>
<div><p>Dictionary of parameters to use for IIR filtering.
See mne.filter.construct_iir_filter for details. If iir_params
is None and method=&#8221;iir&#8221;, 4th order Butterworth will be used.</p>
</div></blockquote>
<p><strong>mt_bandwidth</strong> : float | None</p>
<blockquote>
<div><p>The bandwidth of the multitaper windowing function in Hz.
Only used in &#8216;spectrum_fit&#8217; mode.</p>
</div></blockquote>
<p><strong>p_value</strong> : float</p>
<blockquote>
<div><p>p-value to use in F-test thresholding to determine significant
sinusoidal components to remove when method=&#8217;spectrum_fit&#8217; and
freqs=None. Note that this will be Bonferroni corrected for the
number of frequencies, so large p-values may be justified.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For details, see mne.filter.notch_filter.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.pick_channels">
<tt class="descname">pick_channels</tt><big>(</big><em>ch_names</em>, <em>copy=False</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.pick_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_names</strong> : list</p>
<blockquote>
<div><p>The list of channels to select.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote class="last">
<div><p>If True, returns new instance. Else, modifies in place. Defaults to
False.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.pick_types">
<tt class="descname">pick_types</tt><big>(</big><em>meg=True</em>, <em>eeg=False</em>, <em>stim=False</em>, <em>eog=False</em>, <em>ecg=False</em>, <em>emg=False</em>, <em>ref_meg='auto'</em>, <em>misc=False</em>, <em>resp=False</em>, <em>chpi=False</em>, <em>exci=False</em>, <em>ias=False</em>, <em>syst=False</em>, <em>seeg=False</em>, <em>include=</em>, <span class="optional">[</span><span class="optional">]</span><em>exclude='bads'</em>, <em>selection=None</em>, <em>copy=False</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.pick_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels by type and names</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>meg</strong> : bool | str</p>
<blockquote>
<div><p>If True include all MEG channels. If False include None
If string it can be &#8216;mag&#8217;, &#8216;grad&#8217;, &#8216;planar1&#8217; or &#8216;planar2&#8217; to select
only magnetometers, all gradiometers, or a specific type of
gradiometer.</p>
</div></blockquote>
<p><strong>eeg</strong> : bool</p>
<blockquote>
<div><p>If True include EEG channels.</p>
</div></blockquote>
<p><strong>stim</strong> : bool</p>
<blockquote>
<div><p>If True include stimulus channels.</p>
</div></blockquote>
<p><strong>eog</strong> : bool</p>
<blockquote>
<div><p>If True include EOG channels.</p>
</div></blockquote>
<p><strong>ecg</strong> : bool</p>
<blockquote>
<div><p>If True include ECG channels.</p>
</div></blockquote>
<p><strong>emg</strong> : bool</p>
<blockquote>
<div><p>If True include EMG channels.</p>
</div></blockquote>
<p><strong>ref_meg: bool | str</strong> :</p>
<blockquote>
<div><p>If True include CTF / 4D reference channels. If &#8216;auto&#8217;, the
reference channels are only included if compensations are present.</p>
</div></blockquote>
<p><strong>misc</strong> : bool</p>
<blockquote>
<div><p>If True include miscellaneous analog channels.</p>
</div></blockquote>
<p><strong>resp</strong> : bool</p>
<blockquote>
<div><p>If True include response-trigger channel. For some MEG systems this
is separate from the stim channel.</p>
</div></blockquote>
<p><strong>chpi</strong> : bool</p>
<blockquote>
<div><p>If True include continuous HPI coil channels.</p>
</div></blockquote>
<p><strong>exci</strong> : bool</p>
<blockquote>
<div><p>Flux excitation channel used to be a stimulus channel.</p>
</div></blockquote>
<p><strong>ias</strong> : bool</p>
<blockquote>
<div><p>Internal Active Shielding data (maybe on Triux only).</p>
</div></blockquote>
<p><strong>syst</strong> : bool</p>
<blockquote>
<div><p>System status channel information (on Triux systems only).</p>
</div></blockquote>
<p><strong>seeg</strong> : bool</p>
<blockquote>
<div><p>Stereotactic EEG channels.</p>
</div></blockquote>
<p><strong>include</strong> : list of string</p>
<blockquote>
<div><p>List of additional channels to include. If empty do not include
any.</p>
</div></blockquote>
<p><strong>exclude</strong> : list of string | str</p>
<blockquote>
<div><p>List of channels to exclude. If &#8216;bads&#8217; (default), exclude channels
in <tt class="docutils literal"><span class="pre">info['bads']</span></tt>.</p>
</div></blockquote>
<p><strong>selection</strong> : list of string</p>
<blockquote>
<div><p>Restrict sensor channels (MEG, EEG) to this list of channel names.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote class="last">
<div><p>If True, returns new instance. Else, modifies in place. Defaults to
False.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.plot">
<tt class="descname">plot</tt><big>(</big><em>events=None</em>, <em>duration=10.0</em>, <em>start=0.0</em>, <em>n_channels=20</em>, <em>bgcolor='w'</em>, <em>color=None</em>, <em>bad_color=(0.8</em>, <em>0.8</em>, <em>0.8)</em>, <em>event_color='cyan'</em>, <em>scalings=None</em>, <em>remove_dc=True</em>, <em>order='type'</em>, <em>show_options=False</em>, <em>title=None</em>, <em>show=True</em>, <em>block=False</em>, <em>highpass=None</em>, <em>lowpass=None</em>, <em>filtorder=4</em>, <em>clipping=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot raw data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>events</strong> : array | None</p>
<blockquote>
<div><p>Events to show with vertical bars.</p>
</div></blockquote>
<p><strong>duration</strong> : float</p>
<blockquote>
<div><p>Time window (sec) to plot in a given time.</p>
</div></blockquote>
<p><strong>start</strong> : float</p>
<blockquote>
<div><p>Initial time to show (can be changed dynamically once plotted).</p>
</div></blockquote>
<p><strong>n_channels</strong> : int</p>
<blockquote>
<div><p>Number of channels to plot at once.</p>
</div></blockquote>
<p><strong>bgcolor</strong> : color object</p>
<blockquote>
<div><p>Color of the background.</p>
</div></blockquote>
<p><strong>color</strong> : dict | color object | None</p>
<blockquote>
<div><p>Color for the data traces. If None, defaults to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">dict</span><span class="p">(</span><span class="n">mag</span><span class="o">=</span><span class="s">&#39;darkblue&#39;</span><span class="p">,</span> <span class="n">grad</span><span class="o">=</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">eeg</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="n">ecg</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">,</span>
     <span class="n">emg</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="n">ref_meg</span><span class="o">=</span><span class="s">&#39;steelblue&#39;</span><span class="p">,</span> <span class="n">misc</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">,</span>
     <span class="n">resp</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="n">chpi</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>bad_color</strong> : color object</p>
<blockquote>
<div><p>Color to make bad channels.</p>
</div></blockquote>
<p><strong>event_color</strong> : color object</p>
<blockquote>
<div><p>Color to use for events.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>Scale factors for the traces. If None, defaults to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">dict</span><span class="p">(</span><span class="n">mag</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">grad</span><span class="o">=</span><span class="mf">4e-11</span><span class="p">,</span> <span class="n">eeg</span><span class="o">=</span><span class="mf">20e-6</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="mf">150e-6</span><span class="p">,</span> <span class="n">ecg</span><span class="o">=</span><span class="mf">5e-4</span><span class="p">,</span>
     <span class="n">emg</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">ref_meg</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">misc</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
     <span class="n">resp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">chpi</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>remove_dc</strong> : bool</p>
<blockquote>
<div><p>If True remove DC component when plotting data.</p>
</div></blockquote>
<p><strong>order</strong> : &#8216;type&#8217; | &#8216;original&#8217; | array</p>
<blockquote>
<div><p>Order in which to plot data. &#8216;type&#8217; groups by channel type,
&#8216;original&#8217; plots in the order of ch_names, array gives the
indices to use in plotting.</p>
</div></blockquote>
<p><strong>show_options</strong> : bool</p>
<blockquote>
<div><p>If True, a dialog for options related to projection is shown.</p>
</div></blockquote>
<p><strong>title</strong> : str | None</p>
<blockquote>
<div><p>The title of the window. If None, and either the filename of the
raw object or &#8216;&lt;unknown&gt;&#8217; will be displayed as title.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figures if True</p>
</div></blockquote>
<p><strong>block</strong> : bool</p>
<blockquote>
<div><p>Whether to halt program execution until the figure is closed.
Useful for setting bad channels on the fly (click on line).
May not work on all systems / platforms.</p>
</div></blockquote>
<p><strong>highpass</strong> : float | None</p>
<blockquote>
<div><p>Highpass to apply when displaying data.</p>
</div></blockquote>
<p><strong>lowpass</strong> : float | None</p>
<blockquote>
<div><p>Lowpass to apply when displaying data.</p>
</div></blockquote>
<p><strong>filtorder</strong> : int</p>
<blockquote>
<div><p>Filtering order. Note that for efficiency and simplicity,
filtering during plotting uses forward-backward IIR filtering,
so the effective filter order will be twice <tt class="docutils literal"><span class="pre">filtorder</span></tt>.
Filtering the lines for display may also produce some edge
artifacts (at the left and right edges) of the signals
during display. Filtering requires scipy &gt;= 0.10.</p>
</div></blockquote>
<p><strong>clipping</strong> : str | None</p>
<blockquote>
<div><p>If None, channels are allowed to exceed their designated bounds in
the plot. If &#8220;clamp&#8221;, then values are clamped to the appropriate
range for display, creating step-like artifacts. If &#8220;transparent&#8221;,
then excessive values are not shown, creating gaps in the traces.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Instance of matplotlib.figure.Figure</p>
<blockquote class="last">
<div><p>Raw traces.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The arrow keys (up/down/left/right) can typically be used to navigate
between channels and time ranges, but this depends on the backend
matplotlib is configured to use (e.g., mpl.use(&#8216;TkAgg&#8217;) should work).
To mark or un-mark a channel as bad, click on the rather flat segments
of a channel&#8217;s time series. The changes will be reflected immediately
in the raw object&#8217;s <tt class="docutils literal"><span class="pre">raw.info['bads']</span></tt> entry.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.plot_projs_topomap">
<tt class="descname">plot_projs_topomap</tt><big>(</big><em>ch_type=None</em>, <em>layout=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.plot_projs_topomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot SSP vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_type</strong> : &#8216;mag&#8217; | &#8216;grad&#8217; | &#8216;planar1&#8217; | &#8216;planar2&#8217; | &#8216;eeg&#8217; | None | List</p>
<blockquote>
<div><p>The channel type to plot. For &#8216;grad&#8217;, the gradiometers are collec-
ted in pairs and the RMS for each pair is plotted. If None
(default), it will return all channel types present. If a list of
ch_types is provided, it will return multiple figures.</p>
</div></blockquote>
<p><strong>layout</strong> : None | Layout | List of Layouts</p>
<blockquote>
<div><p>Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct
layout file is inferred from the data; if no appropriate layout
file was found, the layout is automatically generated from the
sensor locations. Or a list of Layout if projections
are from different sensor types.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure distributing one image per channel across sensor topography.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.plot_psd">
<tt class="descname">plot_psd</tt><big>(</big><em>tmin=0.0</em>, <em>tmax=60.0</em>, <em>fmin=0</em>, <em>fmax=inf</em>, <em>proj=False</em>, <em>n_fft=2048</em>, <em>picks=None</em>, <em>ax=None</em>, <em>color='black'</em>, <em>area_mode='std'</em>, <em>area_alpha=0.33</em>, <em>n_overlap=0</em>, <em>dB=True</em>, <em>show=True</em>, <em>n_jobs=1</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.plot_psd" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the power spectral density across channels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tmin</strong> : float</p>
<blockquote>
<div><p>Start time for calculations.</p>
</div></blockquote>
<p><strong>tmax</strong> : float</p>
<blockquote>
<div><p>End time for calculations.</p>
</div></blockquote>
<p><strong>fmin</strong> : float</p>
<blockquote>
<div><p>Start frequency to consider.</p>
</div></blockquote>
<p><strong>fmax</strong> : float</p>
<blockquote>
<div><p>End frequency to consider.</p>
</div></blockquote>
<p><strong>proj</strong> : bool</p>
<blockquote>
<div><p>Apply projection.</p>
</div></blockquote>
<p><strong>n_fft</strong> : int</p>
<blockquote>
<div><p>Number of points to use in Welch FFT calculations.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>List of channels to use. Cannot be None if <cite>ax</cite> is supplied. If
both <cite>picks</cite> and <cite>ax</cite> are None, separate subplots will be created
for each standard channel type (<cite>mag</cite>, <cite>grad</cite>, and <cite>eeg</cite>).</p>
</div></blockquote>
<p><strong>ax</strong> : instance of matplotlib Axes | None</p>
<blockquote>
<div><p>Axes to plot into. If None, axes will be created.</p>
</div></blockquote>
<p><strong>color</strong> : str | tuple</p>
<blockquote>
<div><p>A matplotlib-compatible color to use.</p>
</div></blockquote>
<p><strong>area_mode</strong> : str | None</p>
<blockquote>
<div><p>How to plot area. If &#8216;std&#8217;, the mean +/- 1 STD (across channels)
will be plotted. If &#8216;range&#8217;, the min and max (across channels)
will be plotted. Bad channels will be excluded from these
calculations. If None, no area will be plotted.</p>
</div></blockquote>
<p><strong>area_alpha</strong> : float</p>
<blockquote>
<div><p>Alpha for the area.</p>
</div></blockquote>
<p><strong>n_overlap</strong> : int</p>
<blockquote>
<div><p>The number of points of overlap between blocks. The default value
is 0 (no overlap).</p>
</div></blockquote>
<p><strong>dB</strong> : bool</p>
<blockquote>
<div><p>If True, transform data to decibels.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Call pyplot.show() at the end.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int</p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure distributing one image per channel across sensor topography.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.plot_psds">
<tt class="descname">plot_psds</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.plot_psds" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the power spectral density across channels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tmin</strong> : float</p>
<blockquote>
<div><p>Start time for calculations.</p>
</div></blockquote>
<p><strong>tmax</strong> : float</p>
<blockquote>
<div><p>End time for calculations.</p>
</div></blockquote>
<p><strong>fmin</strong> : float</p>
<blockquote>
<div><p>Start frequency to consider.</p>
</div></blockquote>
<p><strong>fmax</strong> : float</p>
<blockquote>
<div><p>End frequency to consider.</p>
</div></blockquote>
<p><strong>proj</strong> : bool</p>
<blockquote>
<div><p>Apply projection.</p>
</div></blockquote>
<p><strong>n_fft</strong> : int</p>
<blockquote>
<div><p>Number of points to use in Welch FFT calculations.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>List of channels to use. Cannot be None if <cite>ax</cite> is supplied. If
both <cite>picks</cite> and <cite>ax</cite> are None, separate subplots will be created
for each standard channel type (<cite>mag</cite>, <cite>grad</cite>, and <cite>eeg</cite>).</p>
</div></blockquote>
<p><strong>ax</strong> : instance of matplotlib Axes | None</p>
<blockquote>
<div><p>Axes to plot into. If None, axes will be created.</p>
</div></blockquote>
<p><strong>color</strong> : str | tuple</p>
<blockquote>
<div><p>A matplotlib-compatible color to use.</p>
</div></blockquote>
<p><strong>area_mode</strong> : str | None</p>
<blockquote>
<div><p>How to plot area. If &#8216;std&#8217;, the mean +/- 1 STD (across channels)
will be plotted. If &#8216;range&#8217;, the min and max (across channels)
will be plotted. Bad channels will be excluded from these
calculations. If None, no area will be plotted.</p>
</div></blockquote>
<p><strong>area_alpha</strong> : float</p>
<blockquote>
<div><p>Alpha for the area.</p>
</div></blockquote>
<p><strong>n_overlap</strong> : int</p>
<blockquote>
<div><p>The number of points of overlap between blocks. The default value
is 0 (no overlap).</p>
</div></blockquote>
<p><strong>dB</strong> : bool</p>
<blockquote>
<div><p>If True, transform data to decibels.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Call pyplot.show() at the end.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int</p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure distributing one image per channel across sensor topography.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.preload_data">
<tt class="descname">preload_data</tt><big>(</big><em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.preload_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Preload raw data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function will preload raw data if it was not already preloaded.
If data were already preloaded, it will do nothing.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.rename_channels">
<tt class="descname">rename_channels</tt><big>(</big><em>mapping</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.rename_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename channels.</p>
<p>Note : The ability to change sensor types has been deprecated in favor
of <cite>set_channel_types</cite>. Please use this function if you would changing
or defining sensor type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mapping</strong> : dict</p>
<blockquote class="last">
<div><p>a dictionary mapping the old channel to a new channel name
e.g. {&#8216;EEG061&#8217; : &#8216;EEG161&#8217;}.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.resample">
<tt class="descname">resample</tt><big>(</big><em>sfreq</em>, <em>npad=100</em>, <em>window='boxcar'</em>, <em>stim_picks=None</em>, <em>n_jobs=1</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample data channels.</p>
<p>Resamples all channels. The data of the Raw object is modified inplace.</p>
<p>The Raw object has to be constructed using preload=True (or string).</p>
<p>WARNING: The intended purpose of this function is primarily to speed
up computations (e.g., projection calculation) when precise timing
of events is not required, as downsampling raw data effectively
jitters trigger timings. It is generally recommended not to epoch
downsampled data, but instead epoch and then downsample, as epoching
downsampled data jitters triggers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sfreq</strong> : float</p>
<blockquote>
<div><p>New sample rate to use.</p>
</div></blockquote>
<p><strong>npad</strong> : int</p>
<blockquote>
<div><p>Amount to pad the start and end of the data.</p>
</div></blockquote>
<p><strong>window</strong> : string or tuple</p>
<blockquote>
<div><p>Window to use in resampling. See scipy.signal.resample.</p>
</div></blockquote>
<p><strong>stim_picks</strong> : array of int | None</p>
<blockquote>
<div><p>Stim channels. These channels are simply subsampled or
supersampled (without applying any filtering). This reduces
resampling artifacts in stim channels, but may lead to missing
triggers. If None, stim channels are automatically chosen using
mne.pick_types(raw.info, meg=False, stim=True, exclude=[]).</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int | str</p>
<blockquote>
<div><p>Number of jobs to run in parallel. Can be &#8216;cuda&#8217; if scikits.cuda
is installed properly and CUDA is initialized.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For some data, it may be more accurate to use npad=0 to reduce
artifacts. This is dataset dependent &#8211; check your data!</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.save">
<tt class="descname">save</tt><big>(</big><em>fname</em>, <em>picks=None</em>, <em>tmin=0</em>, <em>tmax=None</em>, <em>buffer_size_sec=10</em>, <em>drop_small_buffer=False</em>, <em>proj=False</em>, <em>fmt='single'</em>, <em>overwrite=False</em>, <em>split_size='2GB'</em>, <em>format=None</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save raw data to file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fname</strong> : string</p>
<blockquote>
<div><p>File name of the new dataset. This has to be a new filename
unless data have been preloaded. Filenames should end with
raw.fif, raw.fif.gz, raw_sss.fif, raw_sss.fif.gz, raw_tsss.fif
or raw_tsss.fif.gz.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>Indices of channels to include. If None all channels are kept.</p>
</div></blockquote>
<p><strong>tmin</strong> : float | None</p>
<blockquote>
<div><p>Time in seconds of first sample to save. If None first sample
is used.</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote>
<div><p>Time in seconds of last sample to save. If None last sample
is used.</p>
</div></blockquote>
<p><strong>buffer_size_sec</strong> : float | None</p>
<blockquote>
<div><p>Size of data chunks in seconds. If None, the buffer size of
the original file is used.</p>
</div></blockquote>
<p><strong>drop_small_buffer</strong> : bool</p>
<blockquote>
<div><p>Drop or not the last buffer. It is required by maxfilter (SSS)
that only accepts raw files with buffers of the same size.</p>
</div></blockquote>
<p><strong>proj</strong> : bool</p>
<blockquote>
<div><p>If True the data is saved with the projections applied (active).
Note: If apply_proj() was used to apply the projections,
the projectons will be active even if proj is False.</p>
</div></blockquote>
<p><strong>fmt</strong> : str</p>
<blockquote>
<div><p>Format to use to save raw data. Valid options are &#8216;double&#8217;,
&#8216;single&#8217;, &#8216;int&#8217;, and &#8216;short&#8217; for 64- or 32-bit float, or 32- or
16-bit integers, respectively. It is <strong>strongly</strong> recommended to
use &#8216;single&#8217;, as this is backward-compatible, and is standard for
maintaining precision. Note that using &#8216;short&#8217; or &#8216;int&#8217; may result
in loss of precision, complex data cannot be saved as &#8216;short&#8217;,
and neither complex data types nor real data stored as &#8216;double&#8217;
can be loaded with the MNE command-line tools. See raw.orig_format
to determine the format the original data were stored in.</p>
</div></blockquote>
<p><strong>overwrite</strong> : bool</p>
<blockquote>
<div><p>If True, the destination file (if it exists) will be overwritten.
If False (default), an error will be raised if the file exists.</p>
</div></blockquote>
<p><strong>split_size</strong> : string | int</p>
<blockquote>
<div><p>Large raw files are automatically split into multiple pieces. This
parameter specifies the maximum size of each piece. If the
parameter is an integer, it specifies the size in Bytes. It is
also possible to pass a human-readable string, e.g., 100MB.
Note: Due to FIFF file limitations, the maximum split size is 2GB.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If Raw is a concatenation of several raw files, <strong>be warned</strong> that
only the measurement information from the first raw file is stored.
This likely means that certain operations with external tools may not
work properly on a saved concatenated file (e.g., probably some
or all forms of SSS). It is recommended not to concatenate and
then save raw files for this reason.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.set_channel_types">
<tt class="descname">set_channel_types</tt><big>(</big><em>mapping</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.set_channel_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the sensor type of channels.</p>
<dl class="docutils">
<dt>Note: The following sensor types are accepted:</dt>
<dd>ecg, eeg, emg, eog, exci, ias, misc, resp, seeg, stim, syst</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mapping</strong> : dict</p>
<blockquote class="last">
<div><p>a dictionary mapping a channel to a sensor type (str)
{&#8216;EEG061&#8217;: &#8216;eog&#8217;}.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.set_montage">
<tt class="descname">set_montage</tt><big>(</big><em>montage</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.set_montage" title="Permalink to this definition">¶</a></dt>
<dd><p>Set EEG sensor configuration</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>montage</strong> : instance of Montage or DigMontage</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Operates in place.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.time_as_index">
<tt class="descname">time_as_index</tt><big>(</big><em>times</em>, <em>use_first_samp=False</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.time_as_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert time to indices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : list-like | float | int</p>
<blockquote>
<div><p>List of numbers or a number representing points in time.</p>
</div></blockquote>
<p><strong>use_first_samp</strong> : boolean</p>
<blockquote>
<div><p>If True, time is treated as relative to the session onset, else
as relative to the recording onset.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>index</strong> : ndarray</p>
<blockquote class="last">
<div><p>Indices corresponding to the times supplied.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mne.io.RawArray.times">
<tt class="descname">times</tt><a class="headerlink" href="#mne.io.RawArray.times" title="Permalink to this definition">¶</a></dt>
<dd><p>Time points</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.to_data_frame">
<tt class="descname">to_data_frame</tt><big>(</big><em>picks=None</em>, <em>index=None</em>, <em>scale_time=1000.0</em>, <em>scalings=None</em>, <em>copy=True</em>, <em>start=None</em>, <em>stop=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.to_data_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Export data in tabular structure as a pandas DataFrame.</p>
<p>Columns and indices will depend on the object being converted.
Generally this will include as much relevant information as
possible for the data type being converted. This makes it easy
to convert data for use in packages that utilize dataframes,
such as statsmodels or seaborn.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>If None only MEG and EEG channels are kept
otherwise the channels indices in picks are kept.</p>
</div></blockquote>
<p><strong>index</strong> : tuple of str | None</p>
<blockquote>
<div><p>Column to be used as index for the data. Valid string options
are &#8216;epoch&#8217;, &#8216;time&#8217; and &#8216;condition&#8217;. If None, all three info
columns will be included in the table as categorial data.</p>
</div></blockquote>
<p><strong>scale_time</strong> : float</p>
<blockquote>
<div><p>Scaling to be applied to time units.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>Scaling to be applied to the channels picked. If None, defaults to
<tt class="docutils literal"><span class="pre">scalings=dict(eeg=1e6,</span> <span class="pre">grad=1e13,</span> <span class="pre">mag=1e15,</span> <span class="pre">misc=1.0)</span></tt>.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>If true, data will be copied. Else data may be modified in place.</p>
</div></blockquote>
<p><strong>start</strong> : int | None</p>
<blockquote>
<div><p>If it is a Raw object, this defines a starting index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</div></blockquote>
<p><strong>stop</strong> : int | None</p>
<blockquote>
<div><p>If it is a Raw object, this defines a stop index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>df</strong> : instance of pandas.core.DataFrame</p>
<blockquote class="last">
<div><p>A dataframe suitable for usage with other
statistical/plotting/analysis packages. Column/Index values will
depend on the object type being converted, but should be
human-readable.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.to_nitime">
<tt class="descname">to_nitime</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.to_nitime" title="Permalink to this definition">¶</a></dt>
<dd><p>DEPRECATED: to_nitime will be removed in v0.10</p>
<p>Raw data as nitime TimeSeries</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><blockquote>
<div><p>Indices of channels to apply. If None, all channels will be
exported.</p>
</div></blockquote>
<dl class="docutils">
<dt>start <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd><p class="first last">Data-extraction start index. If None, data will be exported from
the first sample.</p>
</dd>
<dt>stop <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd><p class="first last">Data-extraction stop index. If None, data will be exported to the
last index.</p>
</dd>
<dt>use_first_samp: bool</dt>
<dd><p class="first last">If True, the time returned is relative to the session onset, else
relative to the recording onset.</p>
</dd>
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to copy the raw data or not.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>raw_ts</strong> : instance of nitime.TimeSeries</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2015, MNE Developers.
      Last updated on May 14, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>