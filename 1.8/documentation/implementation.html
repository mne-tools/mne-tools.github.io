
<!DOCTYPE html>


<html lang="en" data-content_root="../" data-theme="auto">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Algorithms and other implementation details &#8212; MNE 1.8.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "auto";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "auto";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css?v=241c0d9d" />
  
  <!-- So that users can add custom icons -->
  <script src="../_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="../_static/documentation_options.js?v=371fd5e7"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=fd10adb8"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-5TBCPCRB6X"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-5TBCPCRB6X');
            </script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-5TBCPCRB6X');
            </script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'documentation/implementation';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.16.0';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://mne.tools/dev/_static/versions.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '1.8';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = false;
        </script>
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Design philosophy" href="design_philosophy.html" />
    <link rel="prev" title="Glossary" href="glossary.html" />
    <link rel="canonical" href="https://mne.tools/stable/index.html" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="1.8" />

  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="auto">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/mne_logo_small.svg" class="logo__image only-light" alt="MNE 1.8.0 documentation - Home"/>
    <img src="../_static/mne_logo_small.svg" class="logo__image only-dark pst-js-only" alt="MNE 1.8.0 documentation - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../install/index.html">
    Install
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="index.html">
    Documentation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../api/python_reference.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../help/index.html">
    Get help
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../development/index.html">
    Development
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-2"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-2"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-2"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-2">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="External Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://discord.gg/rKfvxTuATa" title="Discord" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-discord fa-fw fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Discord</span></a>
        </li>
        <li class="nav-item">
            
          
          
          
          
          
          
          
          
          
          <a href="https://fosstodon.org/@mne" title="Mastodon" class="nav-link pst-navbar-icon" rel="me" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-mastodon fa-fw fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Mastodon</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://mne.discourse.group/" title="Forum" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-discourse fa-fw fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Forum</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/mne-tools/mne-python" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-fw fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../install/index.html">
    Install
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="index.html">
    Documentation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../api/python_reference.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../help/index.html">
    Get help
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../development/index.html">
    Development
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-3"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-3"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-3"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-3">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="External Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://discord.gg/rKfvxTuATa" title="Discord" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-discord fa-fw fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Discord</span></a>
        </li>
        <li class="nav-item">
            
          
          
          
          
          
          
          
          
          
          <a href="https://fosstodon.org/@mne" title="Mastodon" class="nav-link pst-navbar-icon" rel="me" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-mastodon fa-fw fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Mastodon</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://mne.discourse.group/" title="Forum" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-discourse fa-fw fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Forum</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/mne-tools/mne-python" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-fw fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../auto_tutorials/index.html">Tutorials</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_tutorials/intro/index.html">Introductory tutorials</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/intro/10_overview.html">Overview of MEG/EEG analysis with MNE-Python</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/intro/15_inplace.html">Modifying data in-place</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/intro/20_events_from_raw.html">Parsing events from raw data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/intro/30_info.html">The Info data structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/intro/40_sensor_locations.html">Working with sensor locations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/intro/50_configure_mne.html">Configuring MNE-Python</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/intro/70_report.html">Getting started with mne.Report</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_tutorials/io/index.html">Reading data for different recording systems</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/io/10_reading_meg_data.html">Importing data from MEG devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/io/20_reading_eeg_data.html">Importing data from EEG devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/io/30_reading_fnirs_data.html">Importing data from fNIRS devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/io/60_ctf_bst_auditory.html">Working with CTF data: the Brainstorm auditory dataset</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/io/70_reading_eyetracking_data.html">Importing Data from Eyetracking devices</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_tutorials/raw/index.html">Working with continuous data</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/raw/10_raw_overview.html">The Raw data structure: continuous data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/raw/20_event_arrays.html">Working with events</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/raw/30_annotate_raw.html">Annotating continuous data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/raw/40_visualize_raw.html">Built-in plotting methods for Raw objects</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_tutorials/preprocessing/index.html">Preprocessing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/preprocessing/10_preprocessing_overview.html">Overview of artifact detection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/preprocessing/15_handling_bad_channels.html">Handling bad channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/preprocessing/20_rejecting_bad_data.html">Rejecting bad data spans and breaks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/preprocessing/25_background_filtering.html">Background information on filtering</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/preprocessing/30_filtering_resampling.html">Filtering and resampling data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/preprocessing/35_artifact_correction_regression.html">Repairing artifacts with regression</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/preprocessing/40_artifact_correction_ica.html">Repairing artifacts with ICA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/preprocessing/45_projectors_background.html">Background on projectors and projections</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/preprocessing/50_artifact_correction_ssp.html">Repairing artifacts with SSP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/preprocessing/55_setting_eeg_reference.html">Setting the EEG reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/preprocessing/59_head_positions.html">Extracting and visualizing subject head movement</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/preprocessing/60_maxwell_filtering_sss.html">Signal-space separation (SSS) and Maxwell filtering</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/preprocessing/70_fnirs_processing.html">Preprocessing functional near-infrared spectroscopy (fNIRS) data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/preprocessing/80_opm_processing.html">Preprocessing optically pumped magnetometer (OPM) MEG data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/preprocessing/90_eyetracking_data.html">Working with eye tracker data in MNE-Python</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_tutorials/epochs/index.html">Segmenting continuous data into epochs</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/epochs/10_epochs_overview.html">The Epochs data structure: discontinuous data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/epochs/15_baseline_regression.html">Regression-based baseline correction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/epochs/20_visualize_epochs.html">Visualizing epoched data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/epochs/30_epochs_metadata.html">Working with Epoch metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/epochs/40_autogenerate_metadata.html">Auto-generating Epochs metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/epochs/50_epochs_to_data_frame.html">Exporting Epochs to Pandas DataFrames</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/epochs/60_make_fixed_length_epochs.html">Divide continuous data into equally-spaced epochs</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_tutorials/evoked/index.html">Estimating evoked responses</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/evoked/10_evoked_overview.html">The Evoked data structure: evoked/averaged data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/evoked/20_visualize_evoked.html">Visualizing Evoked data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/evoked/30_eeg_erp.html">EEG analysis - Event-Related Potentials (ERPs)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/evoked/40_whitened.html">Plotting whitened data</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_tutorials/time-freq/index.html">Time-frequency analysis</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/time-freq/10_spectrum_class.html">The Spectrum and EpochsSpectrum classes: frequency-domain data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/time-freq/20_sensors_time_frequency.html">Frequency and time-frequency sensor analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/time-freq/50_ssvep.html">Frequency-tagging: Basic analysis of an SSVEP/vSSR dataset</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_tutorials/forward/index.html">Forward models and source spaces</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/forward/10_background_freesurfer.html">FreeSurfer MRI reconstruction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/forward/20_source_alignment.html">Source alignment and coordinate frames</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/forward/25_automated_coreg.html">Using an automated approach to coregistration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/forward/30_forward.html">Head model and forward computation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/forward/35_eeg_no_mri.html">EEG forward operator with a template MRI</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/forward/50_background_freesurfer_mne.html">How MNE uses FreeSurfer’s outputs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/forward/80_fix_bem_in_blender.html">Fixing BEM and head surfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/forward/90_compute_covariance.html">Computing a covariance matrix</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_tutorials/inverse/index.html">Source localization and inverses</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/inverse/10_stc_class.html">The SourceEstimate data structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/inverse/20_dipole_fit.html">Source localization with equivalent current dipole (ECD) fit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/inverse/30_mne_dspm_loreta.html">Source localization with MNE, dSPM, sLORETA, and eLORETA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/inverse/35_dipole_orientations.html">The role of dipole orientations in distributed source localization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/inverse/40_mne_fixed_free.html">Computing various MNE solutions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/inverse/50_beamformer_lcmv.html">Source reconstruction using an LCMV beamformer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/inverse/60_visualize_stc.html">Visualize source time courses (stcs)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/inverse/70_eeg_mri_coords.html">EEG source localization given electrode locations on an MRI</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/inverse/80_brainstorm_phantom_elekta.html">Brainstorm Elekta phantom dataset tutorial</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/inverse/85_brainstorm_phantom_ctf.html">Brainstorm CTF phantom dataset tutorial</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/inverse/90_phantom_4DBTi.html">4D Neuroimaging/BTi phantom dataset tutorial</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/inverse/95_phantom_KIT.html">KIT phantom dataset tutorial</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_tutorials/stats-sensor-space/index.html">Statistical analysis of sensor data</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/stats-sensor-space/10_background_stats.html">Statistical inference</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/stats-sensor-space/20_erp_stats.html">Visualising statistical significance thresholds on EEG data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/stats-sensor-space/40_cluster_1samp_time_freq.html">Non-parametric 1 sample cluster statistic on single trial power</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/stats-sensor-space/50_cluster_between_time_freq.html">Non-parametric between conditions cluster statistic on single trial power</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/stats-sensor-space/70_cluster_rmANOVA_time_freq.html">Mass-univariate twoway repeated measures ANOVA on single trial power</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/stats-sensor-space/75_cluster_ftest_spatiotemporal.html">Spatiotemporal permutation F-test on full sensor data</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_tutorials/stats-source-space/index.html">Statistical analysis of source estimates</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/stats-source-space/20_cluster_1samp_spatiotemporal.html">Permutation t-test on source data with spatio-temporal clustering</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/stats-source-space/30_cluster_ftest_spatiotemporal.html">2 samples permutation test on source data with spatio-temporal clustering</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/stats-source-space/60_cluster_rmANOVA_spatiotemporal.html">Repeated measures ANOVA on source data with spatio-temporal clustering</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_tutorials/machine-learning/index.html">Machine learning models of neural activity</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/machine-learning/30_strf.html">Spectro-temporal receptive field (STRF) estimation on continuous data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/machine-learning/50_decoding.html">Decoding (MVPA)</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_tutorials/clinical/index.html">Clinical applications</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/clinical/20_seeg.html">Working with sEEG data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/clinical/30_ecog.html">Working with ECoG data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/clinical/60_sleep.html">Sleep stage classification from polysomnography (PSG) data</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_tutorials/simulation/index.html">Simulation</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/simulation/10_array_objs.html">Creating MNE-Python data structures from scratch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/simulation/70_point_spread.html">Corrupt known signal with point spread</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/simulation/80_dics.html">DICS for power mapping</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_tutorials/visualization/index.html">Visualization tutorials</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/visualization/10_publication_figure.html">Make figures more publication ready</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_tutorials/visualization/20_ui_events.html">Using the event system to link figures</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../auto_examples/index.html">Examples</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_examples/io/index.html">Input/Output</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/io/elekta_epochs.html">Getting averaging info from .fif files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/io/read_neo_format.html">How to use data in neural ensemble (NEO) format</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/io/read_noise_covariance_matrix.html">Reading/Writing a noise covariance matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/io/read_xdf.html">Reading XDF EEG data</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_examples/simulation/index.html">Data Simulation</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/simulation/plot_stc_metrics.html">Compare simulated and estimated source activity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/simulation/simulate_evoked_data.html">Generate simulated evoked data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/simulation/simulate_raw_data.html">Generate simulated raw data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/simulation/simulated_raw_data_using_subject_anatomy.html">Simulate raw data using subject anatomy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/simulation/source_simulator.html">Generate simulated source data</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_examples/preprocessing/index.html">Preprocessing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/contralateral_referencing.html">Using contralateral referencing for EEG</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/css.html">Cortical Signal Suppression (CSS) for removal of cortical signals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/define_target_events.html">Define target events based on time lag, plot evoked response</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/eeg_bridging.html">Identify EEG Electrodes Bridged by too much Gel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/eeg_csd.html">Transform EEG data using current source density (CSD)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/eog_artifact_histogram.html">Show EOG artifact timing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/eog_regression.html">Reduce EOG artifacts through regression</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/epochs_metadata.html">Automated epochs metadata generation with variable time windows</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/find_ref_artifacts.html">Find MEG reference channel artifacts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/fnirs_artifact_removal.html">Visualise NIRS artifact correction methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/ica_comparison.html">Compare the different ICA algorithms in MNE</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/interpolate_bad_channels.html">Interpolate bad channels for MEG/EEG channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/movement_compensation.html">Maxwell filter data with movement compensation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/movement_detection.html">Annotate movement artifacts and reestimate dev_head_t</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/muscle_detection.html">Annotate muscle artifacts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/muscle_ica.html">Removing muscle ICA components</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/otp.html">Plot sensor denoising using oversampled temporal projection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/shift_evoked.html">Shifting time-scale in evoked data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/virtual_evoked.html">Remap MEG channel types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/preprocessing/xdawn_denoising.html">XDAWN Denoising</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_examples/visualization/index.html">Visualization</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/3d_to_2d.html">How to convert 3D electrode positions to a 2D image</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/brain.html">Plotting with <code class="docutils literal notranslate"><span class="pre">mne.viz.Brain</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/channel_epochs_image.html">Visualize channel over epochs as an image</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/eeg_on_scalp.html">Plotting EEG sensors on the scalp</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/evoked_arrowmap.html">Plotting topographic arrowmaps of evoked data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/evoked_topomap.html">Plotting topographic maps of evoked data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/evoked_whitening.html">Whitening evoked data with a noise covariance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/eyetracking_plot_heatmap.html">Plotting eye-tracking heatmaps in MNE-Python</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/meg_sensors.html">Plotting sensor layouts of MEG systems</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/mne_helmet.html">Plot the MNE brain and helmet</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/montage_sgskip.html">Plotting sensor layouts of EEG systems</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/parcellation.html">Plot a cortical parcellation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/roi_erpimage_by_rt.html">Plot single trial activity, grouped by ROI and sorted by RT</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/ssp_projs_sensitivity_map.html">Sensitivity map of SSP projections</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/topo_compare_conditions.html">Compare evoked responses for different conditions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/topo_customized.html">Plot custom topographies for MEG sensors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/visualization/xhemi.html">Cross-hemisphere comparison</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_examples/time_frequency/index.html">Time-Frequency Examples</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/time_frequency/compute_csd.html">Compute a cross-spectral density (CSD) matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/time_frequency/compute_source_psd_epochs.html">Compute Power Spectral Density of inverse solution from single epochs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/time_frequency/source_label_time_frequency.html">Compute power and phase lock in label of the source space</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/time_frequency/source_power_spectrum.html">Compute source power spectral density (PSD) in a label</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/time_frequency/source_power_spectrum_opm.html">Compute source power spectral density (PSD) of VectorView and OPM data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/time_frequency/source_space_time_frequency.html">Compute induced power in the source space with dSPM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/time_frequency/temporal_whitening.html">Temporal whitening with AR model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/time_frequency/time_frequency_erds.html">Compute and visualize ERDS maps</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/time_frequency/time_frequency_global_field_power.html">Explore event-related dynamics for specific frequency bands</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/time_frequency/time_frequency_simulated.html">Time-frequency on simulated data (Multitaper vs. Morlet vs. Stockwell vs. Hilbert)</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_examples/stats/index.html">Statistics Examples</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/stats/cluster_stats_evoked.html">Permutation F-test on sensor data with 1D cluster level</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/stats/fdr_stats_evoked.html">FDR correction on T-test on sensor data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/stats/linear_regression_raw.html">Regression on continuous data (rER[P/F])</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/stats/sensor_permutation_test.html">Permutation T-test on sensor data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/stats/sensor_regression.html">Analysing continuous features with binning and regression in sensor space</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_examples/decoding/index.html">Machine Learning (Decoding, Encoding, and MVPA)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/decoding/decoding_csp_eeg.html">Motor imagery decoding from EEG data using the Common Spatial Pattern (CSP)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/decoding/decoding_csp_timefreq.html">Decoding in time-frequency space using Common Spatial Patterns (CSP)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/decoding/decoding_rsa_sgskip.html">Representational Similarity Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/decoding/decoding_spatio_temporal_source.html">Decoding source space data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/decoding/decoding_spoc_CMC.html">Continuous Target Decoding with SPoC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/decoding/decoding_time_generalization_conditions.html">Decoding sensor space data with generalization across time and conditions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/decoding/decoding_unsupervised_spatial_filter.html">Analysis of evoked response using ICA and PCA reduction techniques</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/decoding/decoding_xdawn_eeg.html">XDAWN Decoding From EEG data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/decoding/ems_filtering.html">Compute effect-matched-spatial filtering (EMS)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/decoding/linear_model_patterns.html">Linear classifier on sensor data with plot patterns and filters</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/decoding/receptive_field_mtrf.html">Receptive Field Estimation and Prediction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/decoding/ssd_spatial_filters.html">Compute Spectro-Spatial Decomposition (SSD) spatial filters</a></li>
</ul>
</details></li>
<li class="toctree-l2"><a class="reference internal" href="../auto_examples/connectivity/index.html">Connectivity Analysis Examples</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_examples/forward/index.html">Forward modeling</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/forward/forward_sensitivity_maps.html">Display sensitivity maps for EEG and MEG sensors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/forward/left_cerebellum_volume_source.html">Generate a left cerebellum volume source space</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/forward/source_space_morphing.html">Use source space morphing</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_examples/inverse/index.html">Inverse problem and source analysis</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/compute_mne_inverse_epochs_in_label.html">Compute MNE-dSPM inverse solution on single epochs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/compute_mne_inverse_raw_in_label.html">Compute sLORETA inverse solution on raw data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/compute_mne_inverse_volume.html">Compute MNE-dSPM inverse solution on evoked data in volume source space</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/custom_inverse_solver.html">Source localization with a custom inverse solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/dics_epochs.html">Compute source level time-frequency timecourses using a DICS beamformer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/dics_source_power.html">Compute source power using DICS beamformer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/evoked_ers_source_power.html">Compute evoked ERS source power using DICS, LCMV beamformer, and dSPM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/gamma_map_inverse.html">Compute a sparse inverse solution using the Gamma-MAP empirical Bayesian method</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/label_activation_from_stc.html">Extracting time course from source_estimate object</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/label_from_stc.html">Generate a functional label from source estimates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/label_source_activations.html">Extracting the time series of activations in a label</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/mixed_norm_inverse.html">Compute sparse inverse solution with mixed norm: MxNE and irMxNE</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/mixed_source_space_inverse.html">Compute MNE inverse solution on evoked data with a mixed source space</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/mne_cov_power.html">Compute source power estimate by projecting the covariance with MNE</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/morph_surface_stc.html">Morph surface source estimate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/morph_volume_stc.html">Morph volumetric source estimate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/multi_dipole_model.html">Computing source timecourses with an XFit-like multi-dipole model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/multidict_reweighted_tfmxne.html">Compute iterative reweighted TF-MxNE with multiscale time-frequency dictionary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/psf_ctf_label_leakage.html">Visualize source leakage among labels using a circular graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/psf_ctf_vertices.html">Plot point-spread functions (PSFs) and cross-talk functions (CTFs)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/psf_ctf_vertices_lcmv.html">Compute cross-talk functions for LCMV beamformers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/psf_volume.html">Plot point-spread functions (PSFs) for a volume</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/rap_music.html">Compute Rap-Music on evoked data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/read_inverse.html">Reading an inverse operator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/read_stc.html">Reading an STC file</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/resolution_metrics.html">Compute spatial resolution metrics in source space</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/resolution_metrics_eegmeg.html">Compute spatial resolution metrics to compare MEG with EEG+MEG</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/snr_estimate.html">Estimate data SNR using an inverse</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/source_space_snr.html">Computing source space SNR</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/time_frequency_mixed_norm_inverse.html">Compute MxNE with time-frequency sparse prior</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/trap_music.html">Compute Trap-Music on evoked data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/inverse/vector_mne_solution.html">Plotting the full vector-valued MNE solution</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../auto_examples/datasets/index.html">Examples on open datasets</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/datasets/brainstorm_data.html">Brainstorm raw (median nerve) dataset</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/datasets/hf_sef_data.html">HF-SEF dataset</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/datasets/kernel_phantom.html">Kernel OPM phantom data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/datasets/limo_data.html">Single trial linear regression analysis with the LIMO dataset</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/datasets/opm_data.html">Optically pumped magnetometer (OPM) data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto_examples/datasets/spm_faces_dataset.html">From raw data to dSPM on SPM Faces dataset</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Implementation details</a></li>
<li class="toctree-l1"><a class="reference internal" href="design_philosophy.html">Design philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="datasets.html">Example datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/commands.html">Command-line tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../help/migrating.html">Migrating from other analysis software</a></li>
<li class="toctree-l1"><a class="reference internal" href="cookbook.html">The typical M/EEG workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="cite.html">How to cite MNE-Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="cited.html">Papers citing MNE-Python</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none"></div>
              
              
<div>
  
  <section id="algorithms-and-other-implementation-details">
<span id="implementation"></span><h1>Algorithms and other implementation details<a class="headerlink" href="#algorithms-and-other-implementation-details" title="Link to this heading">#</a></h1>
<p>This page describes some of the technical details of MNE-Python implementation.</p>
<section id="internal-representation-units">
<span id="units"></span><h2>Internal representation (units)<a class="headerlink" href="#internal-representation-units" title="Link to this heading">#</a></h2>
<p>Irrespective of the units used in your manufacturer’s format, when importing
data, MNE-Python will always convert measurements to the same standard units.
Thus the in-memory representation of data are always in:</p>
<ul class="simple">
<li><p>Volts (eeg, eog, seeg, emg, ecg, bio, ecog, dbs)</p></li>
<li><p>Teslas (magnetometers)</p></li>
<li><p>Teslas/meter (gradiometers)</p></li>
<li><p>Amperes*meter (dipole fits, minimum-norm estimates, etc.)</p></li>
<li><p>Moles/liter (“molar”; fNIRS data: oxyhemoglobin (hbo), deoxyhemoglobin (hbr))</p></li>
<li><p>Arbitrary units (various derived unitless quantities)</p></li>
</ul>
<p>Note, however, that most MNE-Python plotting functions will scale the data when
plotted to yield nice-looking axis annotations in a sensible range; for
example, <a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw.plot_psd" title="mne.io.Raw.plot_psd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mne.io.Raw.plot_psd()</span></code></a> will convert teslas to femtoteslas (fT)
and volts to microvolts (µV) when plotting MEG and EEG data.</p>
<p>The units used in internal data representation are particularly important to
remember when extracting data from MNE-Python objects and manipulating it
outside MNE-Python (e.g., when using methods like <a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw.get_data" title="mne.io.Raw.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_data()</span></code></a>
or <a class="reference internal" href="../generated/mne.Epochs.html#mne.Epochs.to_data_frame" title="mne.Epochs.to_data_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_data_frame()</span></code></a> to convert data to <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">NumPy</span> <span class="pre">arrays</span></code></a> or <a class="reference external" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html#pandas.DataFrame" title="(in pandas v2.2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pandas</span> <span class="pre">DataFrames</span></code></a> for analysis
or plotting with other Python modules).</p>
</section>
<section id="floating-point-precision">
<span id="precision"></span><h2>Floating-point precision<a class="headerlink" href="#floating-point-precision" title="Link to this heading">#</a></h2>
<p>MNE-Python performs all computation in memory using the double-precision 64-bit
floating point format. This means that the data is typecast into float64 format
as soon as it is read into memory. The reason for this is that operations such
as filtering and preprocessing are more accurate when using the 64-bit format.
However, for backward compatibility, MNE-Python writes <code class="file docutils literal notranslate"><span class="pre">.fif</span></code> files in a
32-bit format by default. This reduces file size when saving data to disk, but
beware that <em>saving intermediate results to disk and re-loading them from disk
later may lead to loss in precision</em>. If you would like to ensure 64-bit
precision, there are two possibilities:</p>
<ul class="simple">
<li><p>Chain the operations in memory and avoid saving intermediate results.</p></li>
<li><p>Save intermediate results but change the <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dtype</span></code></a> used for
saving, by using the <code class="docutils literal notranslate"><span class="pre">fmt</span></code> parameter of <a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw.save" title="mne.io.Raw.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mne.io.Raw.save()</span></code></a> (or
<a class="reference internal" href="../generated/mne.Epochs.html#mne.Epochs.save" title="mne.Epochs.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mne.Epochs.save()</span></code></a>, etc). However, note that this may render the
<code class="file docutils literal notranslate"><span class="pre">.fif</span></code> files unreadable in software packages other than MNE-Python.</p></li>
</ul>
</section>
<section id="supported-channel-types">
<span id="channel-types"></span><h2>Supported channel types<a class="headerlink" href="#supported-channel-types" title="Link to this heading">#</a></h2>
<p>Channel types are represented in MNE-Python with shortened or abbreviated
names. This page lists all supported channel types, their abbreviated names,
and the measurement unit used to represent data of that type. Where channel
types occur in two or more sub-types, the sub-type abbreviations are given in
parentheses. More information about measurement units is given in the
<a class="reference internal" href="#units"><span class="std std-ref">Internal representation (units)</span></a> section.</p>
<div class="pst-scrollable-table-container"><table class="table-bordered midvalign table">
<thead>
<tr class="row-odd"><th class="head"><p>Channel type</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Measurement unit</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>eeg</p></td>
<td><p>scalp electroencephalography (EEG)</p></td>
<td><p>Volts</p></td>
</tr>
<tr class="row-odd"><td><p>meg (mag)</p></td>
<td><p>Magnetoencephalography (magnetometers)</p></td>
<td><p>Teslas</p></td>
</tr>
<tr class="row-even"><td><p>meg (grad)</p></td>
<td><p>Magnetoencephalography (gradiometers)</p></td>
<td><p>Teslas/meter</p></td>
</tr>
<tr class="row-odd"><td><p>ecg</p></td>
<td><p>Electrocardiography (ECG)</p></td>
<td><p>Volts</p></td>
</tr>
<tr class="row-even"><td><p>seeg</p></td>
<td><p>Stereotactic EEG channels</p></td>
<td><p>Volts</p></td>
</tr>
<tr class="row-odd"><td><p>dbs</p></td>
<td><p>Deep brain stimulation (DBS)</p></td>
<td><p>Volts</p></td>
</tr>
<tr class="row-even"><td><p>ecog</p></td>
<td><p>Electrocorticography (ECoG)</p></td>
<td><p>Volts</p></td>
</tr>
<tr class="row-odd"><td><p>fnirs (hbo)</p></td>
<td><p>Functional near-infrared spectroscopy
(oxyhemoglobin)</p></td>
<td><p>Moles/liter</p></td>
</tr>
<tr class="row-even"><td><p>fnirs (hbr)</p></td>
<td><p>Functional near-infrared spectroscopy
(deoxyhemoglobin)</p></td>
<td><p>Moles/liter</p></td>
</tr>
<tr class="row-odd"><td><p>emg</p></td>
<td><p>Electromyography (EMG)</p></td>
<td><p>Volts</p></td>
</tr>
<tr class="row-even"><td><p>eog</p></td>
<td><p>Electrooculography  (EOG)</p></td>
<td><p>Volts</p></td>
</tr>
<tr class="row-odd"><td><p>bio</p></td>
<td><p>Miscellaneous biological channels (e.g.,
skin conductance)</p></td>
<td><p>Arbitrary units</p></td>
</tr>
<tr class="row-even"><td><p>stim</p></td>
<td><p>stimulus (a.k.a. trigger) channels</p></td>
<td><p>Arbitrary units</p></td>
</tr>
<tr class="row-odd"><td><p>resp</p></td>
<td><p>respiration monitoring channel</p></td>
<td><p>Volts</p></td>
</tr>
<tr class="row-even"><td><p>chpi</p></td>
<td><p>continuous head position indicator
(HPI) coil channels</p></td>
<td><p>Teslas</p></td>
</tr>
<tr class="row-odd"><td><p>exci</p></td>
<td><p>Flux excitation channel</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ias</p></td>
<td><p>Internal Active Shielding data
(Triux systems only?)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>syst</p></td>
<td><p>System status channel information
(Triux systems only)</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>temperature</p></td>
<td><p>Temperature</p></td>
<td><p>Degrees Celsius</p></td>
</tr>
<tr class="row-odd"><td><p>gsr</p></td>
<td><p>Galvanic skin response</p></td>
<td><p>Siemens</p></td>
</tr>
<tr class="row-even"><td><p>ref_meg</p></td>
<td><p>Reference Magnetometers</p></td>
<td><p>Teslas</p></td>
</tr>
<tr class="row-odd"><td><p>dipole</p></td>
<td><p>Dipole amplitude</p></td>
<td><p>Amperes</p></td>
</tr>
<tr class="row-even"><td><p>gof</p></td>
<td><p>Goodness of fit (GOF)</p></td>
<td><p>Goodness-of-fit</p></td>
</tr>
<tr class="row-odd"><td><p>cw-nirs (amp)</p></td>
<td><p>Continuous-wave functional near-infrared
spectroscopy (CW-fNIRS) (CW amplitude)</p></td>
<td><p>Volts</p></td>
</tr>
<tr class="row-even"><td><p>fd-nirs (ac amp)</p></td>
<td><p>Frequency-domain near-infrared
spectroscopy (FD-NIRS AC amplitude)</p></td>
<td><p>Volts</p></td>
</tr>
<tr class="row-odd"><td><p>fd-nirs (phase)</p></td>
<td><p>Frequency-domain near-infrared
spectroscopy (FD-NIRS phase)</p></td>
<td><p>Radians</p></td>
</tr>
<tr class="row-even"><td><p>fnirs (od)</p></td>
<td><p>Functional near-infrared spectroscopy
(optical density)</p></td>
<td><p>Volts</p></td>
</tr>
<tr class="row-odd"><td><p>csd</p></td>
<td><p>Current source density</p></td>
<td><p>Volts per square
meter</p></td>
</tr>
<tr class="row-even"><td><p>eyegaze</p></td>
<td><p>Eye-tracking (gaze position)</p></td>
<td><p>Arbitrary units</p></td>
</tr>
<tr class="row-odd"><td><p>pupil</p></td>
<td><p>Eye-tracking (pupil size)</p></td>
<td><p>Arbitrary units</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="supported-data-formats">
<span id="data-formats"></span><h2>Supported data formats<a class="headerlink" href="#supported-data-formats" title="Link to this heading">#</a></h2>
<p>When MNE-Python loads sensor data, the data are stored in a Python object of
type <a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw" title="mne.io.Raw"><code class="xref py py-class docutils literal notranslate"><span class="pre">mne.io.Raw</span></code></a>. Specialized loading functions are provided for the
raw data file formats from a variety of equipment manufacturers. All raw data
input/output functions in MNE-Python are found in <a class="reference internal" href="../api/reading_raw_data.html#module-mne.io" title="mne.io"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mne.io</span></code></a> and start
with <code class="samp docutils literal notranslate"><span class="pre">read_raw_</span><em><span class="pre">*</span></em></code>; see the documentation for each reader function for
more info on reading specific file types.</p>
<p>As seen in the table below, there are also a few formats defined by other
neuroimaging analysis software packages that are supported (EEGLAB,
FieldTrip). Like the equipment-specific loading functions, these will also
return an object of class <a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw" title="mne.io.Raw"><code class="xref py py-class docutils literal notranslate"><span class="pre">Raw</span></code></a>; additional functions are
available for reading data that has already been epoched or averaged (see
table).</p>
<div class="pst-scrollable-table-container"><table class="table-bordered midvalign table">
<thead>
<tr class="row-odd"><th class="head"><p>Data type</p></th>
<th class="head"><p>File format</p></th>
<th class="head"><p>Extension</p></th>
<th class="head"><p>MNE-Python function</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>MEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/10_reading_meg_data.html#import-artemis"><span class="std std-ref">Artemis123</span></a></p></td>
<td><p>.bin</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_artemis123.html#mne.io.read_raw_artemis123" title="mne.io.read_raw_artemis123"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_artemis123()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>MEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/10_reading_meg_data.html#import-bti"><span class="std std-ref">4-D Neuroimaging / BTi</span></a></p></td>
<td><p>&lt;dir&gt;</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_bti.html#mne.io.read_raw_bti" title="mne.io.read_raw_bti"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_bti()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>MEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/10_reading_meg_data.html#import-ctf"><span class="std std-ref">CTF</span></a></p></td>
<td><p>&lt;dir&gt;</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_ctf.html#mne.io.read_raw_ctf" title="mne.io.read_raw_ctf"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_ctf()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>MEG and EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/10_reading_meg_data.html#import-neuromag"><span class="std std-ref">Elekta Neuromag</span></a></p></td>
<td><p>.fif</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_fif.html#mne.io.read_raw_fif" title="mne.io.read_raw_fif"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_fif()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>MEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/10_reading_meg_data.html#import-fil"><span class="std std-ref">FIL OPM MEG</span></a></p></td>
<td><p>.bin</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_fil.html#mne.io.read_raw_fil" title="mne.io.read_raw_fil"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_fil()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>MEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/10_reading_meg_data.html#import-kit"><span class="std std-ref">KIT</span></a></p></td>
<td><p>.sqd</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_kit.html#mne.io.read_raw_kit" title="mne.io.read_raw_kit"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_kit()</span></code></a>,
<a class="reference internal" href="../generated/mne.read_epochs_kit.html#mne.read_epochs_kit" title="mne.read_epochs_kit"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.read_epochs_kit()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>MEG and EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/10_reading_meg_data.html#import-fieldtrip"><span class="std std-ref">FieldTrip</span></a></p></td>
<td><p>.mat</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_fieldtrip.html#mne.io.read_raw_fieldtrip" title="mne.io.read_raw_fieldtrip"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_fieldtrip()</span></code></a>,
<a class="reference internal" href="../generated/mne.read_epochs_fieldtrip.html#mne.read_epochs_fieldtrip" title="mne.read_epochs_fieldtrip"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.read_epochs_fieldtrip()</span></code></a>,
<a class="reference internal" href="../generated/mne.read_evoked_fieldtrip.html#mne.read_evoked_fieldtrip" title="mne.read_evoked_fieldtrip"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.read_evoked_fieldtrip()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/20_reading_eeg_data.html#import-bv"><span class="std std-ref">Brainvision</span></a></p></td>
<td><p>.vhdr</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_brainvision.html#mne.io.read_raw_brainvision" title="mne.io.read_raw_brainvision"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_brainvision()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/20_reading_eeg_data.html#import-biosemi"><span class="std std-ref">Biosemi data format</span></a></p></td>
<td><p>.bdf</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_bdf.html#mne.io.read_raw_bdf" title="mne.io.read_raw_bdf"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_bdf()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/20_reading_eeg_data.html#import-cnt"><span class="std std-ref">Neuroscan CNT</span></a></p></td>
<td><p>.cnt</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_cnt.html#mne.io.read_raw_cnt" title="mne.io.read_raw_cnt"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_cnt()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/20_reading_eeg_data.html#import-edf"><span class="std std-ref">European data format</span></a></p></td>
<td><p>.edf</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_edf.html#mne.io.read_raw_edf" title="mne.io.read_raw_edf"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_edf()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/20_reading_eeg_data.html#import-set"><span class="std std-ref">EEGLAB</span></a></p></td>
<td><p>.set</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_eeglab.html#mne.io.read_raw_eeglab" title="mne.io.read_raw_eeglab"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_eeglab()</span></code></a>,
<a class="reference internal" href="../generated/mne.read_epochs_eeglab.html#mne.read_epochs_eeglab" title="mne.read_epochs_eeglab"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.read_epochs_eeglab()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/20_reading_eeg_data.html#import-egi"><span class="std std-ref">EGI simple binary</span></a></p></td>
<td><p>.egi</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_egi.html#mne.io.read_raw_egi" title="mne.io.read_raw_egi"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_egi()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/20_reading_eeg_data.html#import-mff"><span class="std std-ref">EGI MFF format</span></a></p></td>
<td><p>.mff</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_egi.html#mne.io.read_raw_egi" title="mne.io.read_raw_egi"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_egi()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/20_reading_eeg_data.html#import-nxe"><span class="std std-ref">eXimia</span></a></p></td>
<td><p>.nxe</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_eximia.html#mne.io.read_raw_eximia" title="mne.io.read_raw_eximia"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_eximia()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/20_reading_eeg_data.html#import-gdf"><span class="std std-ref">General data format</span></a></p></td>
<td><p>.gdf</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_gdf.html#mne.io.read_raw_gdf" title="mne.io.read_raw_gdf"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_gdf()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/20_reading_eeg_data.html#import-nicolet"><span class="std std-ref">Nicolet</span></a></p></td>
<td><p>.data</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_nicolet.html#mne.io.read_raw_nicolet" title="mne.io.read_raw_nicolet"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_nicolet()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/20_reading_eeg_data.html#import-persyst"><span class="std std-ref">Persyst</span></a></p></td>
<td><p>.lay</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_persyst.html#mne.io.read_raw_persyst" title="mne.io.read_raw_persyst"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_persyst()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>NIRS</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/30_reading_fnirs_data.html#import-nirx"><span class="std std-ref">NIRx</span></a></p></td>
<td><p>directory</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_nirx.html#mne.io.read_raw_nirx" title="mne.io.read_raw_nirx"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_nirx()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>NIRS</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/30_reading_fnirs_data.html#import-boxy"><span class="std std-ref">BOXY</span></a></p></td>
<td><p>directory</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_boxy.html#mne.io.read_raw_boxy" title="mne.io.read_raw_boxy"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_boxy()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>EYETRACK</p></td>
<td><p>SR eyelink ASCII files</p></td>
<td><p>.asc</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_eyelink.html#mne.io.read_raw_eyelink" title="mne.io.read_raw_eyelink"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_eyelink()</span></code></a></p></td>
</tr>
</tbody>
</table>
</div>
<p>More details are provided in the tutorials in the <a class="reference internal" href="../auto_tutorials/io/index.html#tut-data-formats"><span class="std std-ref">Reading data for different recording systems</span></a>
section.</p>
</section>
<section id="supported-formats-for-digitized-3d-locations">
<span id="dig-formats"></span><h2>Supported formats for digitized 3D locations<a class="headerlink" href="#supported-formats-for-digitized-3d-locations" title="Link to this heading">#</a></h2>
<p>MNE-Python can load 3D point locations obtained by digitization systems.
Such files allow to obtain a <a class="reference internal" href="../generated/mne.channels.DigMontage.html#mne.channels.DigMontage" title="mne.channels.DigMontage"><code class="xref py py-class docutils literal notranslate"><span class="pre">montage</span></code></a>
that can then be added to <a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw" title="mne.io.Raw"><code class="xref py py-class docutils literal notranslate"><span class="pre">Raw</span></code></a> objects with the
<a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw.set_montage" title="mne.io.Raw.set_montage"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_montage()</span></code></a>. See the documentation for each reader
function for more info on reading specific file types.</p>
<div class="pst-scrollable-table-container"><table class="table-bordered midvalign table">
<thead>
<tr class="row-odd"><th class="head"><p>Vendor</p></th>
<th class="head"><p>Extension(s)</p></th>
<th class="head"><p>MNE-Python function</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Neuromag</p></td>
<td><p>.fif</p></td>
<td><p><a class="reference internal" href="../generated/mne.channels.read_dig_fif.html#mne.channels.read_dig_fif" title="mne.channels.read_dig_fif"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.read_dig_fif()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>Polhemus ISOTRAK</p></td>
<td><p>.hsp, .elp, .eeg</p></td>
<td><p><a class="reference internal" href="../generated/mne.channels.read_dig_polhemus_isotrak.html#mne.channels.read_dig_polhemus_isotrak" title="mne.channels.read_dig_polhemus_isotrak"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.read_dig_polhemus_isotrak()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>EGI</p></td>
<td><p>.xml</p></td>
<td><p><a class="reference internal" href="../generated/mne.channels.read_dig_egi.html#mne.channels.read_dig_egi" title="mne.channels.read_dig_egi"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.read_dig_egi()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>MNE-C</p></td>
<td><p>.hpts</p></td>
<td><p><a class="reference internal" href="../generated/mne.channels.read_dig_hpts.html#mne.channels.read_dig_hpts" title="mne.channels.read_dig_hpts"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.read_dig_hpts()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>Brain Products</p></td>
<td><p>.bvct</p></td>
<td><p><a class="reference internal" href="../generated/mne.channels.read_dig_captrak.html#mne.channels.read_dig_captrak" title="mne.channels.read_dig_captrak"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.read_dig_captrak()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>Compumedics</p></td>
<td><p>.dat</p></td>
<td><p><a class="reference internal" href="../generated/mne.channels.read_dig_dat.html#mne.channels.read_dig_dat" title="mne.channels.read_dig_dat"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.read_dig_dat()</span></code></a></p></td>
</tr>
</tbody>
</table>
</div>
<p>To load Polhemus FastSCAN files you can use
<a class="reference internal" href="../generated/mne.channels.read_polhemus_fastscan.html#mne.channels.read_polhemus_fastscan" title="mne.channels.read_polhemus_fastscan"><code class="xref py py-func docutils literal notranslate"><span class="pre">montage</span></code></a>.</p>
<p>It is also possible to make a <a class="reference internal" href="../generated/mne.channels.DigMontage.html#mne.channels.DigMontage" title="mne.channels.DigMontage"><code class="xref py py-class docutils literal notranslate"><span class="pre">montage</span></code></a>
from arrays with <a class="reference internal" href="../generated/mne.channels.make_dig_montage.html#mne.channels.make_dig_montage" title="mne.channels.make_dig_montage"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.make_dig_montage()</span></code></a>.</p>
</section>
<section id="memory-efficient-i-o">
<span id="memory"></span><h2>Memory-efficient I/O<a class="headerlink" href="#memory-efficient-i-o" title="Link to this heading">#</a></h2>
<section id="preloading-continuous-raw-data">
<h3>Preloading continuous (raw) data<a class="headerlink" href="#preloading-continuous-raw-data" title="Link to this heading">#</a></h3>
<p>MNE-Python can read data on-demand using the <code class="docutils literal notranslate"><span class="pre">preload</span></code> option provided in
raw reading functions. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mne</span> <span class="kn">import</span> <span class="n">io</span>
<span class="kn">from</span> <span class="nn">mne.datasets</span> <span class="kn">import</span> <span class="n">sample</span>
<span class="n">data_path</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">data_path</span><span class="p">()</span>
<span class="n">raw_fname</span> <span class="o">=</span> <span class="n">data_path</span> <span class="o">/</span> <span class="s1">&#39;MEG&#39;</span> <span class="o">/</span> <span class="s1">&#39;sample&#39;</span> <span class="o">/</span> <span class="s1">&#39;sample_audvis_filt-0-40_raw.fif&#39;</span>
<span class="n">raw</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">read_raw_fif</span><span class="p">(</span><span class="n">raw_fname</span><span class="p">,</span> <span class="n">preload</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Filtering, resampling and dropping or selecting channels does not
work with <code class="docutils literal notranslate"><span class="pre">preload=False</span></code>.</p>
</div>
</section>
<section id="preloading-epoched-data">
<h3>Preloading epoched data<a class="headerlink" href="#preloading-epoched-data" title="Link to this heading">#</a></h3>
<p>Similarly, epochs can also be be read from disk on-demand. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mne</span>
<span class="n">events</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">find_events</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>
<span class="n">event_id</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span>
<span class="n">picks</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">pick_types</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">meg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">eeg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">epochs</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">Epochs</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="n">picks</span><span class="p">,</span>
                    <span class="n">baseline</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">reject</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">eeg</span><span class="o">=</span><span class="mf">80e-6</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="mf">150e-6</span><span class="p">),</span>
                    <span class="n">preload</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">preload=False</span></code>, the epochs data is loaded from the disk on-demand. Note
that <code class="docutils literal notranslate"><span class="pre">preload=False</span></code> for epochs will work even if the <code class="docutils literal notranslate"><span class="pre">raw</span></code> object has been
loaded with <code class="docutils literal notranslate"><span class="pre">preload=True</span></code>. Preloading is also supported for
<a class="reference internal" href="../generated/mne.read_epochs.html#mne.read_epochs" title="mne.read_epochs"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.read_epochs()</span></code></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This comes with a caveat. When <code class="docutils literal notranslate"><span class="pre">preload=False</span></code>, data rejection
based on peak-to-peak thresholds is executed when the data is
loaded from disk, <em>not</em> when the <code class="docutils literal notranslate"><span class="pre">Epochs</span></code> object is created.</p>
</div>
<p>To explicitly reject artifacts with <code class="docutils literal notranslate"><span class="pre">preload=False</span></code>, use the function <a class="reference internal" href="../generated/mne.Epochs.html#mne.Epochs.drop_bad" title="mne.Epochs.drop_bad"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.Epochs.drop_bad()</span></code></a>.</p>
</section>
<section id="loading-data-explicitly">
<h3>Loading data explicitly<a class="headerlink" href="#loading-data-explicitly" title="Link to this heading">#</a></h3>
<p>To load the data if <code class="docutils literal notranslate"><span class="pre">preload=False</span></code> was initially selected, use the functions <a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw.load_data" title="mne.io.Raw.load_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.Raw.load_data()</span></code></a> and <a class="reference internal" href="../generated/mne.Epochs.html#mne.Epochs.load_data" title="mne.Epochs.load_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.Epochs.load_data()</span></code></a>.</p>
</section>
<section id="accessing-data-as-numpy-arrays">
<h3>Accessing data as NumPy arrays<a class="headerlink" href="#accessing-data-as-numpy-arrays" title="Link to this heading">#</a></h3>
<p>If you just want your raw data as a <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Numpy</span> <span class="pre">array</span></code></a> to
work with it in a different framework you can use slicing syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">first_channel_data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
<span class="n">channels_3_and_4</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="p">:]</span>
</pre></div>
</div>
</section>
</section>
<section id="bad-channel-repair-via-interpolation">
<span id="channel-interpolation"></span><h2>Bad channel repair via interpolation<a class="headerlink" href="#bad-channel-repair-via-interpolation" title="Link to this heading">#</a></h2>
<p>In short, data repair using spherical spline interpolation <a class="footnote-reference brackets" href="#footcite-perrinetal1989" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> consists of the following steps:</p>
<ul class="simple">
<li><p>Project the good and bad electrodes onto a unit sphere</p></li>
<li><p>Compute a mapping matrix that maps <span class="math notranslate nohighlight">\(N\)</span> good channels to <span class="math notranslate nohighlight">\(M\)</span> bad channels</p></li>
<li><p>Use this mapping matrix to compute interpolated data in the bad channels</p></li>
</ul>
<p>Spherical splines assume that the potential <span class="math notranslate nohighlight">\(V(\boldsymbol{r_i})\)</span> at any point <span class="math notranslate nohighlight">\(\boldsymbol{r_i}\)</span> on the surface of the sphere can be represented by:</p>
<div class="math notranslate nohighlight" id="model">
<span id="equation-model"></span><span class="eqno">(1)<a class="headerlink" href="#model" title="Link to this equation">#</a></span>\[V(\boldsymbol{r_i}) = c_0 + \sum_{j=1}^{N}c_{i}g_{m}(cos(\boldsymbol{r_i}, \boldsymbol{r_{j}}))\]</div>
<p>where the <span class="math notranslate nohighlight">\(C = (c_{1}, ..., c_{N})^{T}\)</span> are constants which must be estimated. The function <span class="math notranslate nohighlight">\(g_{m}(\cdot)\)</span> of order <span class="math notranslate nohighlight">\(m\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[g_{m}(x) = \frac{1}{4 \pi}\sum_{n=1}^{\infty} \frac{2n + 1}{(n(n + 1))^m}P_{n}(x)\]</div>
<p>where <span class="math notranslate nohighlight">\(P_{n}(x)\)</span> are <a class="reference external" href="https://en.wikipedia.org/wiki/Legendre_polynomials">Legendre polynomials</a> of order <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>To estimate the constants <span class="math notranslate nohighlight">\(C\)</span>, we must solve the following two equations simultaneously:</p>
<div class="math notranslate nohighlight" id="matrix-form">
<span id="equation-matrix-form"></span><span class="eqno">(2)<a class="headerlink" href="#matrix-form" title="Link to this equation">#</a></span>\[G_{ss}C + T_{s}c_0 = X\]</div>
<div class="math notranslate nohighlight" id="constraint">
<span id="equation-constraint"></span><span class="eqno">(3)<a class="headerlink" href="#constraint" title="Link to this equation">#</a></span>\[{T_s}^{T}C = 0\]</div>
<p>where <span class="math notranslate nohighlight">\(G_{ss} \in R^{N \times N}\)</span> is a matrix whose entries are <span class="math notranslate nohighlight">\(G_{ss}[i, j] = g_{m}(cos(\boldsymbol{r_i}, \boldsymbol{r_j}))\)</span> and <span class="math notranslate nohighlight">\(X \in R^{N \times 1}\)</span> are the potentials <span class="math notranslate nohighlight">\(V(\boldsymbol{r_i})\)</span> measured at the good channels. <span class="math notranslate nohighlight">\(T_{s} = (1, 1, ..., 1)^\top\)</span> is a column vector of dimension <span class="math notranslate nohighlight">\(N\)</span>. Equation <a class="reference internal" href="#equation-matrix-form">(2)</a> is the matrix formulation of Equation <a class="reference internal" href="#equation-model">(1)</a> and equation <a class="reference internal" href="#equation-constraint">(3)</a> is like applying an average reference to the data. From equation <a class="reference internal" href="#equation-matrix-form">(2)</a> and <a class="reference internal" href="#equation-constraint">(3)</a>, we get:</p>
<div class="math notranslate nohighlight" id="estimate-constant">
<span id="equation-estimate-constant"></span><span class="eqno">(4)<a class="headerlink" href="#estimate-constant" title="Link to this equation">#</a></span>\[\begin{split}\begin{bmatrix} c_0 \\ C \end{bmatrix} = {\begin{bmatrix} {T_s}^{T} &amp;&amp; 0 \\ T_s &amp;&amp; G_{ss} \end{bmatrix}}^{-1} \begin{bmatrix} 0 \\ X \end{bmatrix} = C_{i}X\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(C_{i}\)</span> is the same as matrix <span class="math notranslate nohighlight">\({\begin{bmatrix} {T_s}^{T} &amp;&amp; 0 \\ T_s &amp;&amp; G_{ss} \end{bmatrix}}^{-1}\)</span> but with its first column deleted, therefore giving a matrix of dimension <span class="math notranslate nohighlight">\((N + 1) \times N\)</span>.</p>
<p>Now, to estimate the potentials <span class="math notranslate nohighlight">\(\hat{X} \in R^{M \times 1}\)</span> at the bad channels, we have to do:</p>
<div class="math notranslate nohighlight" id="estimate-data">
<span id="equation-estimate-data"></span><span class="eqno">(5)<a class="headerlink" href="#estimate-data" title="Link to this equation">#</a></span>\[\hat{X} = G_{ds}C + T_{d}c_0\]</div>
<p>where <span class="math notranslate nohighlight">\(G_{ds} \in R^{M \times N}\)</span> computes <span class="math notranslate nohighlight">\(g_{m}(\boldsymbol{r_i}, \boldsymbol{r_j})\)</span> between the bad and good channels. <span class="math notranslate nohighlight">\(T_{d} = (1, 1, ..., 1)^\top\)</span> is a column vector of dimension <span class="math notranslate nohighlight">\(M\)</span>. Plugging in equation <a class="reference internal" href="#equation-estimate-constant">(4)</a> in <a class="reference internal" href="#equation-estimate-data">(5)</a>, we get</p>
<div class="math notranslate nohighlight">
\[\begin{split}\hat{X} = \begin{bmatrix} T_d &amp;&amp; G_{ds} \end{bmatrix} \begin{bmatrix} c_0 \\ C \end{bmatrix} = \underbrace{\begin{bmatrix} T_d &amp;&amp; G_{ds} \end{bmatrix} C_{i}}_\text{mapping matrix}X\end{split}\]</div>
<p>To interpolate bad channels, one can simply do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span><span class="o">.</span><span class="n">interpolate_bads</span><span class="p">(</span><span class="n">reset_bads</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
</pre></div>
</div>
<p>and the bad channel will be fixed.</p>
</section>
<section id="maxwell-filtering">
<span id="maxwell"></span><h2>Maxwell filtering<a class="headerlink" href="#maxwell-filtering" title="Link to this heading">#</a></h2>
<p>MNE-Python’s implementation of Maxwell filtering is described in the
<a class="reference internal" href="../auto_tutorials/preprocessing/60_maxwell_filtering_sss.html#tut-artifact-sss"><span class="std std-ref">Signal-space separation (SSS) and Maxwell filtering</span></a> tutorial.</p>
</section>
<section id="signal-space-projection-ssp">
<span id="ssp-method"></span><h2>Signal-Space Projection (SSP)<a class="headerlink" href="#signal-space-projection-ssp" title="Link to this heading">#</a></h2>
<p>The Signal-Space Projection (SSP) is one approach to rejection of external
disturbances in software. The section presents some relevant details of this
method. For practical examples of how to use SSP for artifact rejection, see
<a class="reference internal" href="../auto_tutorials/preprocessing/50_artifact_correction_ssp.html#tut-artifact-ssp"><span class="std std-ref">Repairing artifacts with SSP</span></a>.</p>
<section id="general-concepts">
<h3>General concepts<a class="headerlink" href="#general-concepts" title="Link to this heading">#</a></h3>
<p>Unlike many other noise-cancellation approaches, SSP does not require
additional reference sensors to record the disturbance fields. Instead, SSP
relies on the fact that the magnetic field distributions generated by the
sources in the brain have spatial distributions sufficiently different from
those generated by external noise sources. Furthermore, it is implicitly
assumed that the linear space spanned by the significant external noise patterns
has a low dimension.</p>
<p>Without loss of generality we can always decompose any <span class="math notranslate nohighlight">\(n\)</span>-channel
measurement <span class="math notranslate nohighlight">\(b(t)\)</span> into its signal and noise components as</p>
<div class="math notranslate nohighlight" id="additive-model">
<span id="equation-additive-model"></span><span class="eqno">(6)<a class="headerlink" href="#additive-model" title="Link to this equation">#</a></span>\[b(t) = b_s(t) + b_n(t)\]</div>
<p>Further, if we know that <span class="math notranslate nohighlight">\(b_n(t)\)</span> is well characterized by a few field
patterns <span class="math notranslate nohighlight">\(b_1 \dotso b_m\)</span>, we can express the disturbance as</p>
<div class="math notranslate nohighlight" id="pca">
<span id="equation-pca"></span><span class="eqno">(7)<a class="headerlink" href="#pca" title="Link to this equation">#</a></span>\[b_n(t) = Uc_n(t) + e(t)\ ,\]</div>
<p>where the columns of <span class="math notranslate nohighlight">\(U\)</span> constitute an orthonormal basis for <span class="math notranslate nohighlight">\(b_1
\dotso b_m\)</span>, <span class="math notranslate nohighlight">\(c_n(t)\)</span> is an <span class="math notranslate nohighlight">\(m\)</span>-component column vector, and the
error term <span class="math notranslate nohighlight">\(e(t)\)</span> is small and does not exhibit any consistent spatial
distributions over time, <em>i.e.</em>, <span class="math notranslate nohighlight">\(C_e = E \{e e^\top\} = I\)</span>. Subsequently,
we will call the column space of <span class="math notranslate nohighlight">\(U\)</span> the noise subspace. The basic idea
of SSP is that we can actually find a small basis set <span class="math notranslate nohighlight">\(b_1 \dotso b_m\)</span>
such that the conditions described above are satisfied. We can now construct
the orthogonal complement operator</p>
<div class="math notranslate nohighlight" id="projector">
<span id="equation-projector"></span><span class="eqno">(8)<a class="headerlink" href="#projector" title="Link to this equation">#</a></span>\[P_{\perp} = I - UU^\top\]</div>
<p>and apply it to <span class="math notranslate nohighlight">\(b(t)\)</span> in Equation <a class="reference internal" href="#equation-additive-model">(6)</a> yielding</p>
<div class="math notranslate nohighlight" id="result">
<span id="equation-result"></span><span class="eqno">(9)<a class="headerlink" href="#result" title="Link to this equation">#</a></span>\[b_{s}(t) \approx P_{\perp}b(t)\ ,\]</div>
<p>since <span class="math notranslate nohighlight">\(P_{\perp}b_n(t) = P_{\perp}(Uc_n(t) + e(t)) \approx 0\)</span> and
<span class="math notranslate nohighlight">\(P_{\perp}b_{s}(t) \approx b_{s}(t)\)</span>. The projection operator
<span class="math notranslate nohighlight">\(P_{\perp}\)</span> is called the <strong>signal-space projection operator</strong> and
generally provides considerable rejection of noise, suppressing external
disturbances by a factor of 10 or more. The effectiveness of SSP depends on two
factors:</p>
<ul class="simple">
<li><p>The basis set <span class="math notranslate nohighlight">\(b_1 \dotso b_m\)</span> should be able to characterize the
disturbance field patterns completely and</p></li>
<li><p>The angles between the noise subspace space spanned by <span class="math notranslate nohighlight">\(b_1 \dotso b_m\)</span>
and the signal vectors <span class="math notranslate nohighlight">\(b_s(t)\)</span> should be as close to <span class="math notranslate nohighlight">\(\pi / 2\)</span>
as possible.</p></li>
</ul>
<p>If the first requirement is not satisfied, some noise will leak through because
<span class="math notranslate nohighlight">\(P_{\perp}b_n(t) \neq 0\)</span>. If the any of the brain signal vectors
<span class="math notranslate nohighlight">\(b_s(t)\)</span> is close to the noise subspace not only the noise but also the
signal will be attenuated by the application of <span class="math notranslate nohighlight">\(P_{\perp}\)</span> and,
consequently, there might by little gain in signal-to-noise ratio.</p>
<p>Since the signal-space projection modifies the signal vectors originating in
the brain, it is necessary to apply the projection to the forward solution in
the course of inverse computations.</p>
<p>For more information on SSP, please consult the references listed in
Tesche <em>et al.</em><a class="footnote-reference brackets" href="#footcite-tescheetal1995" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>, Uusitalo and Ilmoniemi<a class="footnote-reference brackets" href="#footcite-uusitaloilmoniemi1997" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="estimation-of-the-noise-subspace">
<h3>Estimation of the noise subspace<a class="headerlink" href="#estimation-of-the-noise-subspace" title="Link to this heading">#</a></h3>
<p>As described above, application of SSP requires the estimation of the signal
vectors <span class="math notranslate nohighlight">\(b_1 \dotso b_m\)</span> constituting the noise subspace. The most common
approach, also implemented in <a class="reference internal" href="../generated/mne.compute_proj_raw.html#mne.compute_proj_raw" title="mne.compute_proj_raw"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.compute_proj_raw()</span></code></a>
is to compute a covariance matrix
of empty room data, compute its eigenvalue decomposition, and employ the
eigenvectors corresponding to the highest eigenvalues as basis for the noise
subspace. It is also customary to use a separate set of vectors for
magnetometers and gradiometers in the Vectorview system.</p>
</section>
<section id="eeg-average-electrode-reference">
<h3>EEG average electrode reference<a class="headerlink" href="#eeg-average-electrode-reference" title="Link to this heading">#</a></h3>
<p>The EEG average reference is the mean signal over all the sensors. It is
typical in EEG analysis to subtract the average reference from all the sensor
signals <span class="math notranslate nohighlight">\(b^{1}(t), ..., b^{n}(t)\)</span>. That is:</p>
<div class="math notranslate nohighlight" id="eeg-proj">
<span id="equation-eeg-proj"></span><span class="eqno">(10)<a class="headerlink" href="#eeg-proj" title="Link to this equation">#</a></span>\[{b}^{j}_{s}(t) = b^{j}(t) - \frac{1}{n}\sum_{k}{b^k(t)}\]</div>
<p>where the noise term <span class="math notranslate nohighlight">\(b_{n}^{j}(t)\)</span> is given by</p>
<div class="math notranslate nohighlight" id="noise-term">
<span id="equation-noise-term"></span><span class="eqno">(11)<a class="headerlink" href="#noise-term" title="Link to this equation">#</a></span>\[b_{n}^{j}(t) = \frac{1}{n}\sum_{k}{b^k(t)}\]</div>
<p>Thus, the projector vector <span class="math notranslate nohighlight">\(P_{\perp}\)</span> will be given by
<span class="math notranslate nohighlight">\(P_{\perp}=\frac{1}{n}[1, 1, ..., 1]\)</span></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When applying SSP, the signal of interest can also be sometimes removed.
Therefore, it’s always a good idea to check how much the effect of interest
is reduced by applying SSP. SSP might remove <em>both</em> the artifact and signal
of interest.</p>
</div>
</section>
</section>
<section id="the-boundary-element-model-bem">
<span id="bem-model"></span><h2>The Boundary Element Model (BEM)<a class="headerlink" href="#the-boundary-element-model-bem" title="Link to this heading">#</a></h2>
<section id="using-the-watershed-algorithm">
<span id="bem-watershed-algorithm"></span><h3>Using the watershed algorithm<a class="headerlink" href="#using-the-watershed-algorithm" title="Link to this heading">#</a></h3>
<p>The watershed algorithm [Segonne <em>et al.</em>,
2004] is part of the FreeSurfer software.
The name of the program is <code class="docutils literal notranslate"><span class="pre">mri_watershed</span></code>.
Its use in the MNE environment is facilitated by the script
<a class="reference internal" href="../generated/commands.html#mne-watershed-bem"><span class="std std-ref">mne watershed_bem</span></a>.</p>
<p>After <code class="docutils literal notranslate"><span class="pre">mne</span> <span class="pre">watershed_bem</span></code> has completed, the following files appear in the
subject’s <code class="file docutils literal notranslate"><span class="pre">bem/watershed</span></code> directory:</p>
<ul class="simple">
<li><p><code class="file docutils literal notranslate"><em><span class="pre">&lt;subject&gt;</span></em><span class="pre">_brain_surface</span></code> contains the brain surface triangulation.</p></li>
<li><p><code class="file docutils literal notranslate"><em><span class="pre">&lt;subject&gt;</span></em><span class="pre">_inner_skull_surface</span></code> contains the inner skull
triangulation.</p></li>
<li><p><code class="file docutils literal notranslate"><em><span class="pre">&lt;subject&gt;</span></em><span class="pre">_outer_skull_surface</span></code> contains the outer skull
triangulation.</p></li>
<li><p><code class="file docutils literal notranslate"><em><span class="pre">&lt;subject&gt;</span></em><span class="pre">_outer_skin_surface</span></code> contains the scalp triangulation.</p></li>
</ul>
<p>All of these surfaces are in the FreeSurfer format. In addition, there will be
a file called <code class="file docutils literal notranslate"><span class="pre">bem/watershed/ws.mgz</span></code> which contains the brain MRI
volume. Furthermore, <code class="docutils literal notranslate"><span class="pre">mne</span> <span class="pre">watershed_bem</span></code> script converts the scalp surface to
fif format and saves the result to <code class="file docutils literal notranslate"><span class="pre">bem/</span><em><span class="pre">&lt;subject&gt;</span></em><span class="pre">-head.fif</span></code>.</p>
</section>
<section id="using-flash-images">
<span id="bem-flash-algorithm"></span><h3>Using FLASH images<a class="headerlink" href="#using-flash-images" title="Link to this heading">#</a></h3>
<p>This method depends on the availablily of MRI data acquired with a multi-echo
FLASH sequence at two flip angles (5 and 30 degrees). These data can be
acquired separately from the MPRAGE data employed in FreeSurfer cortical
reconstructions but it is strongly recommended that they are collected at the
same time with the MPRAGEs or at least with the same scanner. For easy
co-registration, the images should have FOV, matrix, slice thickness, gap, and
slice orientation as the MPRAGE data. For information on suitable pulse
sequences, see Fischl <em>et al.</em><a class="footnote-reference brackets" href="#footcite-fischletal2004" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>.</p>
<p>Creation of the BEM meshes using this method involves the following steps:</p>
<ul class="simple">
<li><p>Creating a synthetic 5-degree flip angle FLASH volume, register
it with the MPRAGE data, and run the segmentation and meshing program.
This step is accomplished by running the script <a class="reference internal" href="../generated/commands.html#mne-flash-bem"><span class="std std-ref">mne flash_bem</span></a>.</p></li>
<li><p>Inspecting the meshes with tkmedit, see <a class="reference internal" href="#inspecting-meshes"><span class="std std-ref">Inspecting the meshes</span></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Different methods can be employed for the creation of the
individual surfaces. For example, it may turn out that the
watershed algorithm produces are better quality skin surface than
the segmentation approach based on the FLASH images. If this is
the case, <code class="docutils literal notranslate"><span class="pre">outer_skin.surf</span></code> can set to point to the corresponding
watershed output file while the other surfaces can be picked from
the FLASH segmentation data.</p>
</div>
<section id="organizing-mri-data-into-directories">
<h4>Organizing MRI data into directories<a class="headerlink" href="#organizing-mri-data-into-directories" title="Link to this heading">#</a></h4>
<p>Since all images comprising the multi-echo FLASH data are contained in a single
series, it is necessary to organize the images according to the echoes before
proceeding to the BEM surface reconstruction. This can be accomplished by using
<a class="reference external" href="https://www.nitrc.org/plugins/mwiki/index.php/dcm2nii:MainPage">dcm2niix</a>
or the MNE-C tool <code class="docutils literal notranslate"><span class="pre">mne_organize_dicom</span></code> if necessary, then use
<a class="reference internal" href="../generated/mne.bem.convert_flash_mris.html#mne.bem.convert_flash_mris" title="mne.bem.convert_flash_mris"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.bem.convert_flash_mris()</span></code></a>.</p>
</section>
<section id="creating-the-surface-tessellations">
<h4>Creating the surface tessellations<a class="headerlink" href="#creating-the-surface-tessellations" title="Link to this heading">#</a></h4>
<p>The BEM surface segmentation and tessellation is automated with the script
<a class="reference internal" href="../generated/commands.html#mne-flash-bem"><span class="std std-ref">mne flash_bem</span></a>. It assumes that a FreeSurfer reconstruction for this
subject is already in place.</p>
<p>Before running <a class="reference internal" href="../generated/commands.html#mne-flash-bem"><span class="std std-ref">mne flash_bem</span></a> do the following:</p>
<ul class="simple">
<li><p>Create symbolic links from the directories containing the 5-degree and
30-degree flip angle FLASH series to <code class="docutils literal notranslate"><span class="pre">flash05</span></code> and <code class="docutils literal notranslate"><span class="pre">flash30</span></code>,
respectively:</p>
<ul>
<li><p><code class="samp docutils literal notranslate"><span class="pre">ln</span> <span class="pre">-s</span> <em><span class="pre">&lt;FLASH</span> <span class="pre">5</span> <span class="pre">series</span> <span class="pre">dir&gt;</span></em> <span class="pre">flash05</span></code></p></li>
<li><p><code class="samp docutils literal notranslate"><span class="pre">ln</span> <span class="pre">-s</span> <em><span class="pre">&lt;FLASH</span> <span class="pre">30</span> <span class="pre">series</span> <span class="pre">dir&gt;</span></em> <span class="pre">flash30</span></code></p></li>
</ul>
</li>
<li><p>Some partition formats (e.g. FAT32) do not support symbolic links. In this
case, copy the file to the appropriate series:</p>
<ul>
<li><p><code class="samp docutils literal notranslate"><span class="pre">cp</span> <em><span class="pre">&lt;FLASH</span> <span class="pre">5</span> <span class="pre">series</span> <span class="pre">dir&gt;</span></em> <span class="pre">flash05</span></code></p></li>
<li><p><code class="samp docutils literal notranslate"><span class="pre">cp</span> <em><span class="pre">&lt;FLASH</span> <span class="pre">30</span> <span class="pre">series</span> <span class="pre">dir&gt;</span></em> <span class="pre">flash30</span></code></p></li>
</ul>
</li>
<li><p>Set the <code class="docutils literal notranslate"><span class="pre">SUBJECTS_DIR</span></code> and <code class="docutils literal notranslate"><span class="pre">SUBJECT</span></code> environment variables or pass
the <code class="docutils literal notranslate"><span class="pre">--subjects-dir</span></code> and <code class="docutils literal notranslate"><span class="pre">--subject</span></code> options to <code class="docutils literal notranslate"><span class="pre">mne</span> <span class="pre">flash_bem</span></code></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">mne</span> <span class="pre">flash_bem</span></code> is run with the <code class="docutils literal notranslate"><span class="pre">--noflash30</span></code> option, the
<code class="file docutils literal notranslate"><span class="pre">flash30</span></code> directory is not needed, <em>i.e.</em>, only the 5-degree flip
angle flash data are employed.</p>
</div>
<p>It may take a while for <code class="docutils literal notranslate"><span class="pre">mne</span> <span class="pre">flash_bem</span></code> to complete. It uses the FreeSurfer
directory structure under <code class="docutils literal notranslate"><span class="pre">$SUBJECTS_DIR/$SUBJECT</span></code>. The script encapsulates
the following processing steps:</p>
<ul class="simple">
<li><p>It creates an mgz file corresponding to each of the eight echoes in each of
the FLASH directories in <code class="docutils literal notranslate"><span class="pre">mri/flash</span></code>. The files will be called
<code class="file docutils literal notranslate"><span class="pre">mef</span> <em><span class="pre">&lt;flip-angle&gt;</span></em><span class="pre">_</span><em><span class="pre">&lt;echo-number&gt;</span></em><span class="pre">.mgz</span></code>.</p></li>
<li><p>If the <code class="docutils literal notranslate"><span class="pre">unwarp=True</span></code> option is specified, run grad_unwarp and produce
files <code class="file docutils literal notranslate"><span class="pre">mef</span> <em><span class="pre">&lt;flip-angle&gt;</span></em><span class="pre">_</span><em><span class="pre">&lt;echo-number&gt;</span></em><span class="pre">u.mgz</span></code>. These files will be
then used in the following steps.</p></li>
<li><p>It creates parameter maps in <code class="file docutils literal notranslate"><span class="pre">mri/flash/parameter_maps</span></code> using
<code class="docutils literal notranslate"><span class="pre">mri_ms_fitparms</span></code>.</p></li>
<li><p>It creates a synthetic 5-degree flip angle volume in
<code class="file docutils literal notranslate"><span class="pre">mri/flash/parameter_maps/flash5.mgz</span></code> using <code class="docutils literal notranslate"><span class="pre">mri_synthesize</span></code>.</p></li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">fsl_rigid_register</span></code>, it creates a registered 5-degree flip angle
volume <code class="docutils literal notranslate"><span class="pre">mri/flash/parameter_maps/flash5_reg.mgz</span></code> by registering
<code class="file docutils literal notranslate"><span class="pre">mri/flash/parameter_maps/flash5.mgz</span></code> to the <em>T1</em> volume under <code class="docutils literal notranslate"><span class="pre">mri</span></code>.</p></li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">mri_convert</span></code>, it converts the flash5_reg volume to COR format under
<code class="docutils literal notranslate"><span class="pre">mri/flash5</span></code>. If necessary, the T1 and brain volumes are also converted
into the COR format.</p></li>
<li><p>It runs <code class="docutils literal notranslate"><span class="pre">mri_make_bem_surfaces</span></code> to create the BEM surface tessellations.</p></li>
<li><p>It creates the directory <code class="file docutils literal notranslate"><span class="pre">bem/flash</span></code>, moves the tri-format
tringulations there and creates the corresponding FreeSurfer surface files
in the same directory.</p></li>
<li><p>The COR format volumes created by <code class="docutils literal notranslate"><span class="pre">mne</span> <span class="pre">flash_bem</span></code> are removed.</p></li>
</ul>
<p>If the <code class="docutils literal notranslate"><span class="pre">--noflash30</span></code> option is specified to <code class="docutils literal notranslate"><span class="pre">mne</span> <span class="pre">flash_bem</span></code>,
steps 3 and 4 in the above are replaced by averaging over the different
echo times in 5-degree flip angle data.</p>
</section>
<section id="inspecting-the-meshes">
<span id="inspecting-meshes"></span><h4>Inspecting the meshes<a class="headerlink" href="#inspecting-the-meshes" title="Link to this heading">#</a></h4>
<p>It is advisable to check the validity of the BEM meshes before
using them. This can be done with:</p>
<ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">--view</span></code> option of <a class="reference internal" href="../generated/commands.html#mne-flash-bem"><span class="std std-ref">mne flash_bem</span></a></p></li>
<li><p>calling <a class="reference internal" href="../generated/mne.viz.plot_bem.html#mne.viz.plot_bem" title="mne.viz.plot_bem"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.viz.plot_bem()</span></code></a> directly</p></li>
<li><p>Using FreeSurfer tools <code class="docutils literal notranslate"><span class="pre">tkmedit</span></code> or <code class="docutils literal notranslate"><span class="pre">freeview</span></code></p></li>
</ul>
</section>
</section>
</section>
<section id="the-forward-solution">
<span id="ch-forward"></span><h2>The forward solution<a class="headerlink" href="#the-forward-solution" title="Link to this heading">#</a></h2>
<section id="meg-eeg-and-mri-coordinate-systems">
<span id="coordinate-systems"></span><h3>MEG/EEG and MRI coordinate systems<a class="headerlink" href="#meg-eeg-and-mri-coordinate-systems" title="Link to this heading">#</a></h3>
<div class="sidebar admonition note">
<p class="admonition-title">Note</p>
<p>Coordinate systems in MNE-Python</p>
<p>In some MNE-Python objects (e.g., <a class="reference internal" href="../generated/mne.Forward.html#mne.Forward" title="mne.Forward"><code class="xref py py-class docutils literal notranslate"><span class="pre">Forward</span></code></a>,
<a class="reference internal" href="../generated/mne.SourceSpaces.html#mne.SourceSpaces" title="mne.SourceSpaces"><code class="xref py py-class docutils literal notranslate"><span class="pre">SourceSpaces</span></code></a>, etc), information about the coordinate frame is
encoded as a constant integer value. The meaning of those integers is
determined <a class="reference external" href="https://github.com/mne-tools/mne-python/blob/079c868240a898204bf82b2f1bf0e04cdee75da1/mne/_fiff/constants.py#L263-L275">in the source code</a>.</p>
</div>
<p>The coordinate systems used in MNE software (and FreeSurfer) and their
relationships are depicted in <a class="reference internal" href="#coordinate-system-figure"><span class="std std-ref">MEG/EEG and MRI coordinate systems</span></a>. Except for the
<em>sensor coordinates</em>, all of the coordinate systems are Cartesian and have the
“RAS” (Right-Anterior-Superior) orientation, <em>i.e.</em>, the <span class="math notranslate nohighlight">\(x\)</span> axis points
to the right, the <span class="math notranslate nohighlight">\(y\)</span> axis to the front, and the <span class="math notranslate nohighlight">\(z\)</span> axis up.</p>
<figure class="align-default" id="id19">
<span id="coordinate-system-figure"></span><img alt="MEG/EEG and MRI coordinate systems" src="../_images/CoordinateSystems.png" />
<figcaption>
<p><span class="caption-text">MEG/EEG and MRI coordinate systems</span><a class="headerlink" href="#id19" title="Link to this image">#</a></p>
<div class="legend">
<p>The coordinate transforms present in the fif files in MNE and the
FreeSurfer files as well as those set to fixed values are indicated with
<span class="math notranslate nohighlight">\(T_x\)</span>, where <span class="math notranslate nohighlight">\(x\)</span> identifies the transformation.</p>
</div>
</figcaption>
</figure>
<p>The coordinate systems related to MEG/EEG data are:</p>
<p><strong>Head coordinates</strong></p>
<blockquote>
<div><p>This is a coordinate system defined with help of the fiducial landmarks
(nasion and the two auricular points). In fif files, EEG electrode
locations are given in this coordinate system. In addition, the head
digitization data acquired in the beginning of an MEG, MEG/EEG, or EEG
acquisition are expressed in head coordinates. For details, see
<a class="reference internal" href="#coordinate-systems"><span class="std std-ref">MEG/EEG and MRI coordinate systems</span></a>.</p>
</div></blockquote>
<p><strong>Device coordinates</strong></p>
<blockquote>
<div><p>This is a coordinate system tied to the MEG device. The relationship of the
Device and Head coordinates is determined during an MEG measurement by
feeding current to three to five head-position indicator (HPI) coils and by
determining their locations with respect to the MEG sensor array from the
magnetic fields they generate.</p>
</div></blockquote>
<p><strong>Sensor coordinates</strong></p>
<blockquote>
<div><p>Each MEG sensor has a local coordinate system defining the orientation and
location of the sensor. With help of this coordinate system, the numerical
integration data needed for the computation of the magnetic field can be
expressed conveniently as discussed in <a class="reference internal" href="#coil-geometry-information"><span class="std std-ref">Coil geometry information</span></a>.
The channel information data in the fif files contain the information to
specify the coordinate transformation between the coordinates of each
sensor and the MEG device coordinates.</p>
</div></blockquote>
<p>The coordinate systems related to MRI data are:</p>
<p><strong>Surface RAS coordinates</strong></p>
<blockquote>
<div><p>The FreeSurfer surface data are expressed in this coordinate system. The
origin of this coordinate system is at the center of the conformed
FreeSurfer MRI volumes (usually 256 x 256 x 256 isotropic 1-mm3  voxels)
and the axes are oriented along the axes of this volume. The BEM surface
and the locations of the sources in the source space are usually expressed
in this coordinate system in the fif files. In this manual, the <em>Surface
RAS coordinates</em> are usually referred to as <em>MRI coordinates</em> unless there
is need to specifically discuss the different MRI-related coordinate
systems.</p>
</div></blockquote>
<p><strong>RAS coordinates</strong></p>
<blockquote>
<div><p>This coordinate system has axes identical to the Surface RAS coordinates
but the location of the origin is different and defined by the original MRI
data, i.e. , the origin is in a scanner-dependent location. There is hardly
any need to refer to this coordinate system explicitly in the analysis with
the MNE software. However, since the Talairach coordinates, discussed
below, are defined with respect to <em>RAS coordinates</em> rather than the
<em>Surface RAS coordinates</em>, the RAS coordinate system is implicitly involved
in the transformation between Surface RAS coordinates and the two
<em>Talairach</em> coordinate systems.</p>
</div></blockquote>
<p><strong>MNI Talairach coordinates</strong></p>
<blockquote>
<div><p>The definition of this coordinate system is discussed, e.g., in
<a class="reference external" href="https://imaging.mrc-cbu.cam.ac.uk/imaging/MniTalairach">https://imaging.mrc-cbu.cam.ac.uk/imaging/MniTalairach</a>. This transformation
is determined during the FreeSurfer reconstruction process. These
coordinates are in MNI305 space.</p>
</div></blockquote>
<p><strong>FreeSurfer Talairach coordinates</strong></p>
<blockquote>
<div><p>The problem with the MNI Talairach coordinates is that the linear MNI
Talairach transform does not match the brains completely to the Talairach
brain. This is probably because the Talairach atlas brain is a rather odd
shape, and as a result, it is difficult to match a standard brain to the
atlas brain using an affine transform. As a result, the MNI brains are
slightly larger (in particular higher, deeper and longer) than the
Talairach brain. The differences are larger as you get further from the
middle of the brain, towards the outside. The FreeSurfer Talairach
coordinates mitigate this problem by additing a an additional
transformation, defined separately for negative and positive MNI Talairach
<span class="math notranslate nohighlight">\(z\)</span> coordinates. These two transformations, denoted by <span class="math notranslate nohighlight">\(T_-\)</span>
and <span class="math notranslate nohighlight">\(T_+\)</span> in <a class="reference internal" href="#coordinate-system-figure"><span class="std std-ref">MEG/EEG and MRI coordinate systems</span></a>, are fixed as discussed in
<a class="reference external" href="https://imaging.mrc-cbu.cam.ac.uk/imaging/MniTalairach">https://imaging.mrc-cbu.cam.ac.uk/imaging/MniTalairach</a> (<em>Approach 2</em>).</p>
</div></blockquote>
<p>The different coordinate systems are related by coordinate transformations
depicted in <a class="reference internal" href="#coordinate-system-figure"><span class="std std-ref">MEG/EEG and MRI coordinate systems</span></a>. The arrows and coordinate
transformation symbols (<span class="math notranslate nohighlight">\(T_x\)</span>) indicate the transformations actually
present in the FreeSurfer files. Generally,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
x_2 \\
y_2 \\
z_2 \\
1
    \end{bmatrix} = T_{12} \begin{bmatrix}
x_1 \\
y_1 \\
z_1 \\
1
    \end{bmatrix} = \begin{bmatrix}
R_{11} &amp; R_{12} &amp; R_{13} &amp; x_0 \\
R_{21} &amp; R_{22} &amp; R_{23} &amp; y_0 \\
R_{31} &amp; R_{32} &amp; R_{33} &amp; z_0 \\
0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix} \begin{bmatrix}
x_1 \\
y_1 \\
z_1 \\
1
    \end{bmatrix}\ ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(x_k\)</span>, <span class="math notranslate nohighlight">\(y_k\)</span>,and <span class="math notranslate nohighlight">\(z_k\)</span> are the location coordinates in
two coordinate systems, <span class="math notranslate nohighlight">\(T_{12}\)</span> is the coordinate transformation from
coordinate system “1” to “2”, <span class="math notranslate nohighlight">\(x_0\)</span>, <span class="math notranslate nohighlight">\(y_0\)</span>, and <span class="math notranslate nohighlight">\(z_0\)</span> is the
location of the origin of coordinate system “1” in coordinate system “2”, and
<span class="math notranslate nohighlight">\(R_{jk}\)</span> are the elements of the rotation matrix relating the two
coordinate systems. The coordinate transformations are present in different
files produced by FreeSurfer and MNE.
The fixed transformations <span class="math notranslate nohighlight">\(T_-\)</span> and <span class="math notranslate nohighlight">\(T_+\)</span> are:</p>
<div class="math notranslate nohighlight">
\[\begin{split}T_{-} = \begin{bmatrix}
0.99 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0.9688 &amp; 0.042 &amp; 0 \\
0 &amp; -0.0485 &amp; 0.839 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}\end{split}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}T_{+} = \begin{bmatrix}
0.99 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0.9688 &amp; 0.046 &amp; 0 \\
0 &amp; -0.0485 &amp; 0.9189 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}\end{split}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section does not discuss the transformation between the MRI voxel
indices and the different MRI coordinates. However, it is important to note
that in FreeSurfer, MNE, as well as in Neuromag software an integer voxel
coordinate corresponds to the location of the center of a voxel. Detailed
information on the FreeSurfer MRI systems can be found at
<a class="reference external" href="https://surfer.nmr.mgh.harvard.edu/fswiki/CoordinateSystems">https://surfer.nmr.mgh.harvard.edu/fswiki/CoordinateSystems</a>.
The symbols <span class="math notranslate nohighlight">\(T_x\)</span> are defined in <a class="reference internal" href="#coordinate-system-figure"><span class="std std-ref">MEG/EEG and MRI coordinate systems</span></a>.</p>
</div>
<div class="pst-scrollable-table-container"><table class="table" id="id20">
<caption><span class="caption-text">Coordinate transformations in FreeSurfer and MNE software packages.</span><a class="headerlink" href="#id20" title="Link to this table">#</a></caption>
<tbody>
<tr class="row-odd"><td><p>Transformation</p></td>
<td><p>FreeSurfer</p></td>
<td><p>MNE</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(T_1\)</span></p></td>
<td><p>Not present</p></td>
<td><div class="line-block">
<div class="line">Measurement data files</div>
<div class="line">Forward solution files (<code class="docutils literal notranslate"><span class="pre">*fwd.fif</span></code>)</div>
<div class="line">Inverse operator files (<code class="docutils literal notranslate"><span class="pre">*inv.fif</span></code>)</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(T_{s_1}\dots T_{s_n}\)</span></p></td>
<td><p>Not present</p></td>
<td><p>Channel information in files
containing <span class="math notranslate nohighlight">\(T_1\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(T_2\)</span></p></td>
<td><p>Not present</p></td>
<td><div class="line-block">
<div class="line">MRI description filesSeparate</div>
<div class="line">Separate <code class="docutils literal notranslate"><span class="pre">-trans.fif</span></code> files</div>
<div class="line">from <a class="reference internal" href="../generated/commands.html#mne-coreg"><span class="std std-ref">mne coreg</span></a></div>
<div class="line">Forward solution files</div>
<div class="line">Inverse operator files</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(T_3\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mri/*mgz</span></code> files</p></td>
<td><p><a class="reference external" href="https://nipy.org/nibabel/reference/nibabel.freesurfer.html#nibabel.freesurfer.mghformat.MGHImage" title="(in NiBabel v5.4.0.dev1+g3b1c7b37)"><code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.freesurfer.mghformat.MGHImage</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(T_4\)</span></p></td>
<td><p>mri/transforms/talairach.xfm</p></td>
<td><p>Internal reading</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(T_-\)</span></p></td>
<td><p>Hardcoded in software</p></td>
<td><p>Hardcoded in software.</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(T_+\)</span></p></td>
<td><p>Hardcoded in software</p></td>
<td><p>Hardcoded in software.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="the-head-and-device-coordinate-systems">
<span id="head-device-coords"></span><h3>The head and device coordinate systems<a class="headerlink" href="#the-head-and-device-coordinate-systems" title="Link to this heading">#</a></h3>
<figure class="align-default" id="id21">
<img alt="Head coordinate system" src="../_images/HeadCS.png" />
<figcaption>
<p><span class="caption-text">The head coordinate system</span><a class="headerlink" href="#id21" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The MEG/EEG head coordinate system employed in the MNE software is a
right-handed Cartesian coordinate system. The direction of <span class="math notranslate nohighlight">\(x\)</span> axis is
from left to right, that of <span class="math notranslate nohighlight">\(y\)</span> axis to the front, and the <span class="math notranslate nohighlight">\(z\)</span> axis
thus points up.</p>
<p>The <span class="math notranslate nohighlight">\(x\)</span> axis of the head coordinate system passes through the two
periauricular or preauricular points digitized before acquiring the data with
positive direction to the right. The <span class="math notranslate nohighlight">\(y\)</span> axis passes through the nasion
and is normal to the <span class="math notranslate nohighlight">\(x\)</span> axis. The <span class="math notranslate nohighlight">\(z\)</span> axis points up according to
the right-hand rule and is normal to the <span class="math notranslate nohighlight">\(xy\)</span> plane.</p>
<p>The origin of the MEG device coordinate system is device dependent. Its origin
is located approximately at the center of a sphere which fits the occipital
section of the MEG helmet best with <span class="math notranslate nohighlight">\(x\)</span> axis axis going from left to
right and <span class="math notranslate nohighlight">\(y\)</span> axis pointing front. The <span class="math notranslate nohighlight">\(z\)</span> axis is, again, normal
to the <span class="math notranslate nohighlight">\(xy\)</span> plane with positive direction up.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The above definition is identical to that of the Neuromag MEG/EEG (head)
coordinate system. However, in 4-D Neuroimaging and CTF MEG systems the head
coordinate frame definition is different. The origin of the coordinate
system is at the midpoint of the left and right auricular points. The
<span class="math notranslate nohighlight">\(x\)</span> axis passes through the nasion and the origin with positive
direction to the front. The <span class="math notranslate nohighlight">\(y\)</span> axis is perpendicular to the <span class="math notranslate nohighlight">\(x\)</span>
axis on the and lies in the plane defined by the three fiducial landmarks,
positive direction from right to left. The <span class="math notranslate nohighlight">\(z\)</span> axis is normal to the
plane of the landmarks, pointing up. Note that in this convention the
auricular points are not necessarily located on <span class="math notranslate nohighlight">\(y\)</span> coordinate axis.
The file conversion utilities take care of these idiosyncrasies and convert
all coordinate information to the MNE software head coordinate frame.</p>
</div>
</section>
<section id="creating-a-surface-based-source-space">
<h3>Creating a surface-based source space<a class="headerlink" href="#creating-a-surface-based-source-space" title="Link to this heading">#</a></h3>
<p>The fif format source space files containing the dipole locations and
orientations are created with <a class="reference internal" href="../generated/mne.setup_source_space.html#mne.setup_source_space" title="mne.setup_source_space"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.setup_source_space()</span></code></a>.</p>
</section>
<section id="creating-a-volumetric-or-discrete-source-space">
<h3>Creating a volumetric or discrete source space<a class="headerlink" href="#creating-a-volumetric-or-discrete-source-space" title="Link to this heading">#</a></h3>
<p>In addition to source spaces confined to a surface, the MNE software provides
some support for three-dimensional source spaces bounded by a surface as well
as source spaces comprised of discrete, arbitrarily located source points. The
<a class="reference internal" href="../generated/mne.setup_volume_source_space.html#mne.setup_volume_source_space" title="mne.setup_volume_source_space"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.setup_volume_source_space()</span></code></a> utility assists in generating such source
spaces.</p>
</section>
<section id="creating-the-bem-meshes">
<h3>Creating the BEM meshes<a class="headerlink" href="#creating-the-bem-meshes" title="Link to this heading">#</a></h3>
<p>See <a class="reference internal" href="#bem-model"><span class="std std-ref">The Boundary Element Model (BEM)</span></a>.</p>
<section id="topology-checks">
<h4>Topology checks<a class="headerlink" href="#topology-checks" title="Link to this heading">#</a></h4>
<p>The following topology checks are performed during the creation of BEM models:</p>
<ul class="simple">
<li><p>The completeness of each surface is confirmed by calculating the total solid
angle subtended by all triangles from a point inside the triangulation. The
result should be very close to <span class="math notranslate nohighlight">\(4 \pi\)</span>. If the result is <span class="math notranslate nohighlight">\(-4 \pi\)</span>
instead, it is conceivable that the ordering of the triangle vertices is
incorrect and the <code class="docutils literal notranslate"><span class="pre">--swap</span></code> option should be specified.</p></li>
<li><p>The correct ordering of the surfaces is verified by checking that the
surfaces are inside each other as expected. This is accomplished by checking
that the sum solid angles subtended by triangles of a surface <span class="math notranslate nohighlight">\(S_k\)</span> at
all vertices of another surface <span class="math notranslate nohighlight">\(S_p\)</span> which is supposed to be inside it
equals <span class="math notranslate nohighlight">\(4 \pi\)</span>. Naturally, this check is applied only if the model has
more than one surface. Since the surface relations are transitive, it is
enough to check that the outer skull surface is inside the skin surface and
that the inner skull surface is inside the outer skull one.</p></li>
<li><p>The extent of each of the triangulated volumes is checked. If the extent is
smaller than 50mm, an error is reported. This may indicate that the vertex
coordinates have been specified in meters instead of millimeters.</p></li>
</ul>
</section>
</section>
<section id="computing-the-bem-geometry-data">
<h3>Computing the BEM geometry data<a class="headerlink" href="#computing-the-bem-geometry-data" title="Link to this heading">#</a></h3>
<p>The utility <a class="reference internal" href="../generated/mne.make_bem_solution.html#mne.make_bem_solution" title="mne.make_bem_solution"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.make_bem_solution()</span></code></a> computes the geometry information for
BEM.</p>
</section>
<section id="coil-geometry-information">
<span id="id7"></span><h3>Coil geometry information<a class="headerlink" href="#coil-geometry-information" title="Link to this heading">#</a></h3>
<p>This Section explains the presentation of MEG detection coil geometry
information the approximations used for different detection coils in MNE
software. Two pieces of information are needed to characterize the detectors:</p>
<ul class="simple">
<li><p>The location and orientation a local coordinate system for each detector.</p></li>
<li><p>A unique identifier, which has an one-to-one correspondence to the
geometrical description of the coil.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>MNE ships with several coil geometry configurations. They can be
found in <code class="docutils literal notranslate"><span class="pre">mne/data</span></code>. See <a class="reference internal" href="../auto_examples/visualization/meg_sensors.html#ex-plot-meg-sensors"><span class="std std-ref">Plotting sensor layouts of MEG systems</span></a> for a
comparison between different coil geometries, and
<a class="reference internal" href="#implemented-coil-geometries"><span class="std std-ref">Implemented coil geometries</span></a> for detailed information regarding
the files describing Neuromag coil geometries.</p>
</div>
<section id="the-sensor-coordinate-system">
<h4>The sensor coordinate system<a class="headerlink" href="#the-sensor-coordinate-system" title="Link to this heading">#</a></h4>
<p>The sensor coordinate system is completely characterized by the location of its
origin and the direction cosines of three orthogonal unit vectors pointing to
the directions of the x, y, and z axis. In fact, the unit vectors contain
redundant information because the orientation can be uniquely defined with
three angles. The measurement fif files list these data in MEG device
coordinates. Transformation to the MEG head coordinate frame can be easily
accomplished by applying the device-to-head coordinate transformation matrix
available in the data files provided that the head-position indicator was used.
Optionally, the MNE software forward calculation applies another coordinate
transformation to the head-coordinate data to bring the coil locations and
orientations to the MRI coordinate system.</p>
<p>If <span class="math notranslate nohighlight">\(r_0\)</span> is a row vector for the origin of the local sensor coordinate
system and <span class="math notranslate nohighlight">\(e_x\)</span>, <span class="math notranslate nohighlight">\(e_y\)</span>, and <span class="math notranslate nohighlight">\(e_z\)</span> are the row vectors for
the three orthogonal unit vectors, all given in device coordinates, a location
of a point <span class="math notranslate nohighlight">\(r_C\)</span> in sensor coordinates is transformed to device
coordinates (<span class="math notranslate nohighlight">\(r_D\)</span>) by</p>
<div class="math notranslate nohighlight">
\[[r_D 1] = [r_C 1] T_{CD}\ ,\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}T = \begin{bmatrix}
e_x &amp; 0 \\
e_y &amp; 0 \\
e_z &amp; 0 \\
r_{0D} &amp; 1
    \end{bmatrix}\ .\end{split}\]</div>
</section>
<section id="calculation-of-the-magnetic-field">
<h4>Calculation of the magnetic field<a class="headerlink" href="#calculation-of-the-magnetic-field" title="Link to this heading">#</a></h4>
<p>The forward calculation in the MNE software computes the signals detected by
each MEG sensor for three orthogonal dipoles at each source space location.
This requires specification of the conductor model, the location and
orientation of the dipoles, and the location and orientation of each MEG sensor
as well as its coil geometry.</p>
<p>The output of each SQUID sensor is a weighted sum of the magnetic fluxes
threading the loops comprising the detection coil. Since the flux threading a
coil loop is an integral of the magnetic field component normal to the coil
plane, the output of the k <sup>th</sup> MEG channel, <span class="math notranslate nohighlight">\(b_k\)</span> can be
approximated by:</p>
<div class="math notranslate nohighlight">
\[b_k = \sum_{p = 1}^{N_k} {w_{kp} B(r_{kp}) \cdot n_{kp}}\]</div>
<p>where <span class="math notranslate nohighlight">\(r_{kp}\)</span> are a set of <span class="math notranslate nohighlight">\(N_k\)</span> integration points covering the
pickup coil loops of the sensor, <span class="math notranslate nohighlight">\(B(r_{kp})\)</span> is the magnetic field due to
the current sources calculated at <span class="math notranslate nohighlight">\(r_{kp}\)</span>, <span class="math notranslate nohighlight">\(n_{kp}\)</span> are the coil
normal directions at these points, and <span class="math notranslate nohighlight">\(w_{kp}\)</span> are the weights
associated to the integration points. This formula essentially presents
numerical integration of the magnetic field over the pickup loops of sensor
<span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>There are three accuracy levels for the numerical integration expressed above.
The <em>simple</em> accuracy means the simplest description of the coil. This accuracy
is not used in the MNE forward calculations. The <em>normal</em> or <em>recommended</em>
accuracy typically uses two integration points for planar gradiometers, one in
each half of the pickup coil and four evenly distributed integration points for
magnetometers. This is the default accuracy used by MNE. If the <code class="docutils literal notranslate"><span class="pre">--accurate</span></code>
option is specified, the forward calculation typically employs a total of eight
integration points for planar gradiometers and sixteen for magnetometers.
Detailed information about the integration points is given in the next section.</p>
</section>
<section id="implemented-coil-geometries">
<span id="id8"></span><h4>Implemented coil geometries<a class="headerlink" href="#implemented-coil-geometries" title="Link to this heading">#</a></h4>
<p>This section describes the coil geometries currently implemented
in MNE. The coil types fall in two general categories:</p>
<ul class="simple">
<li><p>Axial gradiometers and planar gradiometers
and</p></li>
<li><p>Planar magnetometers.</p></li>
</ul>
<p>For axial sensors, the <em>z</em> axis of the local coordinate system is parallel to
the field component detected, <em>i.e.</em>, normal to the coil plane.For circular
coils, the orientation of the <em>x</em> and <em>y</em> axes on the plane normal to the z
axis is irrelevant. In the square coils employed in the Vectorview (TM) system
the <em>x</em> axis is chosen to be parallel to one of the sides of the magnetometer
coil. For planar sensors, the <em>z</em> axis is likewise normal to the coil plane and
the x axis passes through the centerpoints of the two coil loops so that the
detector gives a positive signal when the normal field component increases
along the <em>x</em> axis.</p>
<p><a class="reference internal" href="#normal-coil-descriptions"><span class="std std-ref">Normal coil descriptions.</span></a> lists the parameters of the <em>normal</em> coil
geometry descriptions <a class="reference internal" href="#accurate-coil-descriptions"><span class="std std-ref">Accurate coil descriptions</span></a> lists the <em>accurate</em>
descriptions. For simple accuracy, please consult the coil definition file, see
<a class="reference internal" href="#coil-definition-file"><span class="std std-ref">The coil definition file</span></a>. The columns of the tables contain the following
data:</p>
<ul class="simple">
<li><p>The number identifying the coil id.
This number is used in the coil descriptions found in the FIF files.</p></li>
<li><p>Description of the coil.</p></li>
<li><p>Number of integration points used</p></li>
<li><p>The locations of the integration points in sensor coordinates.</p></li>
<li><p>Weights assigned to the field values at the integration points.
Some formulas are listed instead of the numerical values to demonstrate
the principle of the calculation. For example, in the normal coil
descriptions of the planar gradiometers the weights are inverses
of the baseline of the gradiometer to show that the output is in
T/m.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The coil geometry information is stored in the file
<code class="file docutils literal notranslate"><span class="pre">mne/data/coil_def.dat</span></code>, which is
automatically created by the MNE-C utility <code class="docutils literal notranslate"><span class="pre">mne_list_coil_def</span></code>.</p>
</div>
<div class="pst-scrollable-table-container"><span id="normal-coil-descriptions"></span><table class="table" id="id22">
<caption><span class="caption-text">Normal coil descriptions.</span><a class="headerlink" href="#id22" title="Link to this table">#</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Id</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>n</p></th>
<th class="head"><p>r/mm</p></th>
<th class="head"><p>w</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>Neuromag-122
planar gradiometer</p></td>
<td><p>2</p></td>
<td><p>(+/-8.1, 0, 0) mm</p></td>
<td><p>+/-1 ⁄ 16.2mm</p></td>
</tr>
<tr class="row-odd"><td><p>2000</p></td>
<td><p>A point magnetometer</p></td>
<td><p>1</p></td>
<td><p>(0, 0, 0)mm</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>3012</p></td>
<td><p>Vectorview type 1
planar gradiometer</p></td>
<td><p>2</p></td>
<td><p>(+/-8.4, 0, 0.3) mm</p></td>
<td><p>+/-1 ⁄ 16.8mm</p></td>
</tr>
<tr class="row-odd"><td><p>3013</p></td>
<td><p>Vectorview type 2
planar gradiometer</p></td>
<td><p>2</p></td>
<td><p>(+/-8.4, 0, 0.3) mm</p></td>
<td><p>+/-1 ⁄ 16.8mm</p></td>
</tr>
<tr class="row-even"><td><p>3022</p></td>
<td><p>Vectorview type 1
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-6.45, +/-6.45, 0.3)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-odd"><td><p>3023</p></td>
<td><p>Vectorview type 2
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-6.45, +/-6.45, 0.3)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-even"><td><p>3024</p></td>
<td><p>Vectorview type 3
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-5.25, +/-5.25, 0.3)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-odd"><td><p>2000</p></td>
<td><p>An ideal point
magnetometer</p></td>
<td><p>1</p></td>
<td><p>(0.0, 0.0, 0.0)mm</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>4001</p></td>
<td><p>Magnes WH
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-5.75, +/-5.75, 0.0)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-odd"><td><p>4002</p></td>
<td><p>Magnes WH 3600
axial gradiometer</p></td>
<td><p>8</p></td>
<td><p>(+/-4.5, +/-4.5, 0.0)mm
(+/-4.5, +/-4.5, 50.0)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
<tr class="row-even"><td><p>4003</p></td>
<td><p>Magnes reference
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-7.5, +/-7.5, 0.0)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-odd"><td><p>4004</p></td>
<td><p>Magnes reference
gradiometer measuring
diagonal gradients</p></td>
<td><p>8</p></td>
<td><p>(+/-20, +/-20, 0.0)mm
(+/-20, +/-20, 135)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
<tr class="row-even"><td><p>4005</p></td>
<td><p>Magnes reference
gradiometer measuring
off-diagonal gradients</p></td>
<td><p>8</p></td>
<td><p>(87.5, +/-20, 0.0)mm
(47.5, +/-20, 0.0)mm
(-87.5, +/-20, 0.0)mm
(-47.5, +/-20, 0.0)mm</p></td>
<td><p>1/4
-1/4
1/4
-1/4</p></td>
</tr>
<tr class="row-odd"><td><p>5001</p></td>
<td><p>CTF 275 axial
gradiometer</p></td>
<td><p>8</p></td>
<td><p>(+/-4.5, +/-4.5, 0.0)mm
(+/-4.5, +/-4.5, 50.0)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
<tr class="row-even"><td><p>5002</p></td>
<td><p>CTF reference
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-4, +/-4, 0.0)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-odd"><td><p>5003</p></td>
<td><p>CTF reference
gradiometer measuring
diagonal gradients</p></td>
<td><p>8</p></td>
<td><p>(+/-8.6, +/-8.6, 0.0)mm
(+/-8.6, +/-8.6, 78.6)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
</tbody>
</table>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a plus-minus sign occurs in several coordinates, all possible
combinations have to be included.</p>
</div>
<div class="pst-scrollable-table-container"><span id="accurate-coil-descriptions"></span><table class="table" id="id23">
<caption><span class="caption-text">Accurate coil descriptions</span><a class="headerlink" href="#id23" title="Link to this table">#</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Id</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>n</p></th>
<th class="head"><p>r/mm</p></th>
<th class="head"><p>w</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>Neuromag-122 planar
gradiometer</p></td>
<td><p>8</p></td>
<td><p>+/-(8.1, 0, 0) mm</p></td>
<td><p>+/-1 ⁄ 16.2mm</p></td>
</tr>
<tr class="row-odd"><td><p>2000</p></td>
<td><p>A point magnetometer</p></td>
<td><p>1</p></td>
<td><p>(0, 0, 0) mm</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>3012</p></td>
<td><p>Vectorview type 1
planar gradiometer</p></td>
<td><p>2</p></td>
<td><p>(+/-8.4, 0, 0.3) mm</p></td>
<td><p>+/-1 ⁄ 16.8mm</p></td>
</tr>
<tr class="row-odd"><td><p>3013</p></td>
<td><p>Vectorview type 2
planar gradiometer</p></td>
<td><p>2</p></td>
<td><p>(+/-8.4, 0, 0.3) mm</p></td>
<td><p>+/-1 ⁄ 16.8mm</p></td>
</tr>
<tr class="row-even"><td><p>3022</p></td>
<td><p>Vectorview type 1
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-6.45, +/-6.45, 0.3)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-odd"><td><p>3023</p></td>
<td><p>Vectorview type 2
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-6.45, +/-6.45, 0.3)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-even"><td><p>3024</p></td>
<td><p>Vectorview type 3
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-5.25, +/-5.25, 0.3)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-odd"><td><p>4001</p></td>
<td><p>Magnes WH magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-5.75, +/-5.75, 0.0)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-even"><td><p>4002</p></td>
<td><p>Magnes WH 3600
axial gradiometer</p></td>
<td><p>4</p></td>
<td><p>(+/-4.5, +/-4.5, 0.0)mm
(+/-4.5, +/-4.5, 0.0)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
<tr class="row-odd"><td><p>4004</p></td>
<td><p>Magnes reference
gradiometer measuring
diagonal gradients</p></td>
<td><p>8</p></td>
<td><p>(+/-20, +/-20, 0.0)mm
(+/-20, +/-20, 135)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
<tr class="row-even"><td><p>4005</p></td>
<td><p>Magnes reference
gradiometer measuring
off-diagonal gradients</p></td>
<td><p>8</p></td>
<td><p>(87.5, +/-20, 0.0)mm
(47.5, +/-20, 0.0)mm
(-87.5, +/-20, 0.0)mm
(-47.5, +/-20, 0.0)mm</p></td>
<td><p>1/4
-1/4
1/4
-1/4</p></td>
</tr>
<tr class="row-odd"><td><p>5001</p></td>
<td><p>CTF 275 axial
gradiometer</p></td>
<td><p>8</p></td>
<td><p>(+/-4.5, +/-4.5, 0.0)mm
(+/-4.5, +/-4.5, 50.0)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
<tr class="row-even"><td><p>5002</p></td>
<td><p>CTF reference
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-4, +/-4, 0.0)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-odd"><td><p>5003</p></td>
<td><p>CTF 275 reference
gradiometer measuring
diagonal gradients</p></td>
<td><p>8</p></td>
<td><p>(+/-8.6, +/-8.6, 0.0)mm
(+/-8.6, +/-8.6, 78.6)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
<tr class="row-even"><td><p>5004</p></td>
<td><p>CTF 275 reference
gradiometer measuring
off-diagonal gradients</p></td>
<td><p>8</p></td>
<td><p>(47.8, +/-8.5, 0.0)mm
(30.8, +/-8.5, 0.0)mm
(-47.8, +/-8.5, 0.0)mm
(-30.8, +/-8.5, 0.0)mm</p></td>
<td><p>1/4
-1/4
1/4
-1/4</p></td>
</tr>
<tr class="row-odd"><td><p>6001</p></td>
<td><p>MIT KIT system axial
gradiometer</p></td>
<td><p>8</p></td>
<td><p>(+/-3.875, +/-3.875, 0.0)mm
(+/-3.875, +/-3.875, 0.0)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="the-coil-definition-file">
<span id="coil-definition-file"></span><h4>The coil definition file<a class="headerlink" href="#the-coil-definition-file" title="Link to this heading">#</a></h4>
<p>The coil geometry information is stored in the text file
<code class="file docutils literal notranslate"><em><span class="pre">$MNE_ROOT</span></em><span class="pre">/share/mne/coil_def.dat</span></code>. In this file, any lines starting
with the pound sign (#) are comments. A coil definition starts with a
description line containing the following fields:</p>
<ul class="simple">
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;class&gt;</span></em></code>: A number indicating class of this coil.</p></li>
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;id&gt;</span></em></code>: Coil ID value. This value is listed in the first column of
Tables <a class="reference internal" href="#normal-coil-descriptions"><span class="std std-ref">Normal coil descriptions.</span></a> and <a class="reference internal" href="#accurate-coil-descriptions"><span class="std std-ref">Accurate coil descriptions</span></a>.</p></li>
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;accuracy&gt;</span></em></code>: The coil representation accuracy. Possible values and
their meanings are listed in <a class="reference internal" href="#coil-accuracies"><span class="std std-ref">Coil representation accuracies.</span></a>.</p></li>
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;np&gt;</span></em></code>: Number of integration points in this representation.</p></li>
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;size/m&gt;</span></em></code>: The size of the coil. For circular coils this is the
diameter of the coil and for square ones the side length of the square. This
information is mainly included to facilitate drawing of the coil geometry. It
should not be employed to infer a coil approximation for the forward
calculations.</p></li>
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;baseline/m&gt;</span></em></code>: The baseline of a this kind of a coil. This will be
zero for magnetometer coils. This information is mainly included to
facilitate drawing of the coil geometry. It should not be employed to infer
a coil approximation for the forward calculations.</p></li>
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;description&gt;</span></em></code>: Short description of this kind of a coil. If the
description contains several words, it is enclosed in quotes.</p></li>
</ul>
<div class="pst-scrollable-table-container"><span id="coil-accuracies"></span><table class="table" id="id24">
<caption><span class="caption-text">Coil representation accuracies.</span><a class="headerlink" href="#id24" title="Link to this table">#</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>The simplest representation available</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>The standard or <em>normal</em> representation (see <a class="reference internal" href="#normal-coil-descriptions"><span class="std std-ref">Normal coil descriptions.</span></a>)</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>The most <em>accurate</em> representation available (see <a class="reference internal" href="#accurate-coil-descriptions"><span class="std std-ref">Accurate coil descriptions</span></a>)</p></td>
</tr>
</tbody>
</table>
</div>
<p>Each coil description line is followed by one or more integration point lines,
consisting of seven numbers:</p>
<ul class="simple">
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;weight&gt;</span></em></code>: Gives the weight for this integration point (last column
in Tables <a class="reference internal" href="#normal-coil-descriptions"><span class="std std-ref">Normal coil descriptions.</span></a> and
<a class="reference internal" href="#accurate-coil-descriptions"><span class="std std-ref">Accurate coil descriptions</span></a>).</p></li>
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;x/m&gt;</span></em> <em><span class="pre">&lt;y/m&gt;</span></em> <em><span class="pre">&lt;z/m&gt;</span></em></code>: Indicates the location of the integration
point (fourth column in Tables <a class="reference internal" href="#normal-coil-descriptions"><span class="std std-ref">Normal coil descriptions.</span></a> and
<a class="reference internal" href="#accurate-coil-descriptions"><span class="std std-ref">Accurate coil descriptions</span></a>).</p></li>
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;nx&gt;</span></em> <em><span class="pre">&lt;ny&gt;</span></em> <em><span class="pre">&lt;nz&gt;</span></em></code>: Components of a unit vector indicating the
field component to be selected. Note that listing a separate unit vector for
each integration points allows the implementation of curved coils and coils
with the gradiometer loops tilted with respect to each other.</p></li>
</ul>
</section>
</section>
<section id="computing-the-forward-solution">
<h3>Computing the forward solution<a class="headerlink" href="#computing-the-forward-solution" title="Link to this heading">#</a></h3>
<section id="purpose">
<h4>Purpose<a class="headerlink" href="#purpose" title="Link to this heading">#</a></h4>
<p>Examples on how to compute the forward solution in MNE-Python using
<a class="reference internal" href="../generated/mne.make_forward_solution.html#mne.make_forward_solution" title="mne.make_forward_solution"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.make_forward_solution()</span></code></a> can be found
<a class="reference internal" href="../auto_tutorials/forward/30_forward.html#plot-forward-compute-forward-solution"><span class="std std-ref">Compute forward solution</span></a> and
<a class="reference internal" href="cookbook.html#computing-the-forward-solution"><span class="std std-ref">Computing the forward solution</span></a>.</p>
</section>
<section id="implementation-of-software-gradient-compensation">
<h4>Implementation of software gradient compensation<a class="headerlink" href="#implementation-of-software-gradient-compensation" title="Link to this heading">#</a></h4>
<p>Accounting for noise cancellation in MNE-Python is accomplished in
<a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw.apply_gradient_compensation" title="mne.io.Raw.apply_gradient_compensation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mne.io.Raw.apply_gradient_compensation()</span></code></a>. See
<a class="reference internal" href="../auto_tutorials/inverse/85_brainstorm_phantom_ctf.html#plot-brainstorm-phantom-ctf"><span class="std std-ref">Brainstorm CTF phantom dataset tutorial</span></a> for an example.</p>
<p>CTF and 4D Neuroimaging data may have been subjected to noise cancellation
employing the data from the reference sensor array. Even though these sensor
are rather far away from the brain sources, <a class="reference internal" href="../generated/mne.make_forward_solution.html#mne.make_forward_solution" title="mne.make_forward_solution"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.make_forward_solution()</span></code></a>
takes them into account in the computations. If the data file has software
gradient compensation activated, it computes the field of at the reference
sensors in addition to the main MEG sensor array and computes a compensated
forward solution.</p>
</section>
<section id="the-eeg-sphere-model-definition-file">
<h4>The EEG sphere model definition file<a class="headerlink" href="#the-eeg-sphere-model-definition-file" title="Link to this heading">#</a></h4>
<p>In MNE-Python, different sphere models can be specified through
<a class="reference internal" href="../generated/mne.make_sphere_model.html#mne.make_sphere_model" title="mne.make_sphere_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.make_sphere_model()</span></code></a>. The default model has the following structure:</p>
<div class="pst-scrollable-table-container"><table class="table" id="id25">
<caption><span class="caption-text">Structure of the default EEG model</span><a class="headerlink" href="#id25" title="Link to this table">#</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Layer</p></th>
<th class="head"><p>Relative outer radius</p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(\sigma\)</span> (S/m)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Head</p></td>
<td><p>1.0</p></td>
<td><p>0.33</p></td>
</tr>
<tr class="row-odd"><td><p>Skull</p></td>
<td><p>0.97</p></td>
<td><p>0.04</p></td>
</tr>
<tr class="row-even"><td><p>CSF</p></td>
<td><p>0.92</p></td>
<td><p>1.0</p></td>
</tr>
<tr class="row-odd"><td><p>Brain</p></td>
<td><p>0.90</p></td>
<td><p>0.33</p></td>
</tr>
</tbody>
</table>
</div>
<p>Although it is not BEM model per se the <code class="docutils literal notranslate"><span class="pre">sphere</span></code> structure describes the head
geometry so it can be passed as <code class="docutils literal notranslate"><span class="pre">bem</span></code> parameter in MNE-Python functions such
as <a class="reference internal" href="../generated/mne.fit_dipole.html#mne.fit_dipole" title="mne.fit_dipole"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.fit_dipole()</span></code></a>, <a class="reference internal" href="../generated/mne.viz.plot_alignment.html#mne.viz.plot_alignment" title="mne.viz.plot_alignment"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.viz.plot_alignment()</span></code></a> or
<a class="reference internal" href="../generated/mne.make_forward_solution.html#mne.make_forward_solution" title="mne.make_forward_solution"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.make_forward_solution()</span></code></a>.</p>
</section>
<section id="eeg-forward-solution-in-the-sphere-model">
<span id="eeg-sphere-model"></span><h4>EEG forward solution in the sphere model<a class="headerlink" href="#eeg-forward-solution-in-the-sphere-model" title="Link to this heading">#</a></h4>
<div class="sidebar admonition note">
<p class="admonition-title">Note</p>
<p>Sphere-model examples in MNE-Python</p>
<p>For examples of using the sphere model when computing the forward model
(using <a class="reference internal" href="../generated/mne.make_forward_solution.html#mne.make_forward_solution" title="mne.make_forward_solution"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.make_forward_solution()</span></code></a>), see <a class="reference internal" href="../auto_tutorials/inverse/85_brainstorm_phantom_ctf.html#plt-brainstorm-phantom-ctf-eeg-sphere-geometry"><span class="std std-ref">Brainstorm CTF phantom
dataset tutorial</span></a>,
<a class="reference internal" href="../auto_tutorials/inverse/80_brainstorm_phantom_elekta.html#plt-brainstorm-phantom-elekta-eeg-sphere-geometry"><span class="std std-ref">Brainstorm Elekta phantom dataset tutorial</span></a>, and
<a class="reference internal" href="../auto_tutorials/forward/20_source_alignment.html#tut-source-alignment-without-mri"><span class="std std-ref">Alignment without MRI</span></a>.</p>
</div>
<p>When the sphere model is employed, the computation of the EEG solution can be
substantially accelerated by using approximation methods described by Mosher
<a class="footnote-reference brackets" href="#footcite-mosheretal1999" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>, Zhang <a class="footnote-reference brackets" href="#footcite-zhang1995" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>, and Berg
<a class="footnote-reference brackets" href="#footcite-bergscherg1994" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>.
<a class="reference internal" href="../generated/mne.make_forward_solution.html#mne.make_forward_solution" title="mne.make_forward_solution"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.make_forward_solution()</span></code></a> approximates the solution with three dipoles
in a homogeneous sphere whose locations and amplitudes are determined by
minimizing the cost function:</p>
<div class="math notranslate nohighlight">
\[S(r_1,\dotsc,r_m\ ,\ \mu_1,\dotsc,\mu_m) = \int_{scalp} {(V_{true} - V_{approx})}\,dS\]</div>
<p>where <span class="math notranslate nohighlight">\(r_1,\dotsc,r_m\)</span> and <span class="math notranslate nohighlight">\(\mu_1,\dotsc,\mu_m\)</span> are the locations
and amplitudes of the approximating dipoles and <span class="math notranslate nohighlight">\(V_{true}\)</span> and
<span class="math notranslate nohighlight">\(V_{approx}\)</span> are the potential distributions given by the true and
approximative formulas, respectively. It can be shown that this integral can be
expressed in closed form using an expansion of the potentials in spherical
harmonics. The formula is evaluated for the most superficial dipoles, <em>i.e.</em>,
those lying just inside the inner skull surface.</p>
</section>
</section>
<section id="averaging-forward-solutions">
<h3>Averaging forward solutions<a class="headerlink" href="#averaging-forward-solutions" title="Link to this heading">#</a></h3>
<p>One possibility to make a grand average over several runs of a experiment is to
average the data across runs and average the forward solutions accordingly. For
this purpose, <a class="reference internal" href="../generated/mne.average_forward_solutions.html#mne.average_forward_solutions" title="mne.average_forward_solutions"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.average_forward_solutions()</span></code></a> computes a weighted average
of several forward solutions. The function averages both MEG and EEG forward
solutions. Usually the EEG forward solution is identical across runs because
the electrode locations do not change.</p>
</section>
</section>
<section id="the-minimum-norm-current-estimates">
<span id="minimum-norm-estimates"></span><h2>The minimum-norm current estimates<a class="headerlink" href="#the-minimum-norm-current-estimates" title="Link to this heading">#</a></h2>
<p>This section describes the mathematical details of the calculation of
minimum-norm estimates. In Bayesian sense, the ensuing current distribution is
the maximum a posteriori (MAP) estimate under the following assumptions:</p>
<ul class="simple">
<li><p>The viable locations of the currents are constrained to the cortex.
Optionally, the current orientations can be fixed to be normal to the
cortical mantle.</p></li>
<li><p>The amplitudes of the currents have a Gaussian prior distribution with a
known source covariance matrix.</p></li>
<li><p>The measured data contain additive noise with a Gaussian distribution with a
known covariance matrix. The noise is not correlated over time.</p></li>
</ul>
<p>Computing the inverse operator is accomplished using
<a class="reference internal" href="../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a> and
<a class="reference internal" href="../generated/mne.minimum_norm.apply_inverse.html#mne.minimum_norm.apply_inverse" title="mne.minimum_norm.apply_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.apply_inverse()</span></code></a>. The use of these functions is presented
in the tutorial <a class="reference internal" href="../auto_tutorials/inverse/30_mne_dspm_loreta.html#tut-inverse-methods"><span class="std std-ref">Source localization with MNE, dSPM, sLORETA, and eLORETA</span></a>.</p>
<section id="the-linear-inverse-operator">
<h3>The linear inverse operator<a class="headerlink" href="#the-linear-inverse-operator" title="Link to this heading">#</a></h3>
<p>The measured data in the source estimation procedure consists of MEG and EEG
data, recorded on a total of N channels. The task is to estimate a total of
<span class="math notranslate nohighlight">\(Q\)</span>
strengths of sources located on the cortical mantle. If the number of source
locations is <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q = P\)</span> for fixed-orientation sources and
<span class="math notranslate nohighlight">\(Q = 3P\)</span> if the source
orientations are unconstrained. The regularized linear inverse operator
following from regularized maximal likelihood of the above probabilistic model
is given by the <span class="math notranslate nohighlight">\(Q \times N\)</span> matrix</p>
<div class="math notranslate nohighlight">
\[M = R' G^\top (G R' G^\top + C)^{-1}\ ,\]</div>
<p>where <span class="math notranslate nohighlight">\(G\)</span> is the gain matrix relating the source strengths to the measured
MEG/EEG data, <span class="math notranslate nohighlight">\(C\)</span> is the data noise-covariance matrix and <span class="math notranslate nohighlight">\(R'\)</span> is
the source covariance matrix. The dimensions of these matrices are <span class="math notranslate nohighlight">\(N
\times Q\)</span>, <span class="math notranslate nohighlight">\(N \times N\)</span>, and <span class="math notranslate nohighlight">\(Q \times Q\)</span>, respectively. The
<span class="math notranslate nohighlight">\(Q \times 1\)</span> source-strength vector is obtained by multiplying the
<span class="math notranslate nohighlight">\(Q \times 1\)</span> data vector by <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<p>The expected value of the current amplitudes at time <em>t</em> is then given by
<span class="math notranslate nohighlight">\(\hat{j}(t) = Mx(t)\)</span>, where <span class="math notranslate nohighlight">\(x(t)\)</span> is a vector containing the
measured MEG and EEG data values at time <em>t</em>.</p>
<p>For computational convenience, the linear inverse operator is
not computed explicitly. See <a class="reference internal" href="#mne-solution"><span class="std std-ref">Computation of the solution</span></a> for mathematical
details, and <a class="reference internal" href="cookbook.html#cihcfjei"><span class="std std-ref">Calculating the inverse operator</span></a> for a detailed example.</p>
</section>
<section id="regularization">
<span id="mne-regularization"></span><h3>Regularization<a class="headerlink" href="#regularization" title="Link to this heading">#</a></h3>
<p>The a priori variance of the currents is, in practice, unknown. We can express
this by writing <span class="math notranslate nohighlight">\(R' = R/ \lambda^2 = R \lambda^{-2}\)</span>, which yields the
inverse operator</p>
<div class="math notranslate nohighlight" id="inv-m">
<span id="equation-inv-m"></span><span class="eqno">(12)<a class="headerlink" href="#inv-m" title="Link to this equation">#</a></span>\[\begin{split} M &amp;= R' G^\top (G R' G^\top + C)^{-1} \\
   &amp;= R \lambda^{-2} G^\top (G R \lambda^{-2} G^\top + C)^{-1} \\
   &amp;= R \lambda^{-2} G^\top \lambda^2 (G R G^\top + \lambda^2 C)^{-1} \\
   &amp;= R G^\top (G R G^\top + \lambda^2 C)^{-1}\ ,\end{split}\]</div>
<p>where the unknown current amplitude is now interpreted in terms of the
regularization parameter <span class="math notranslate nohighlight">\(\lambda^2\)</span>. Larger <span class="math notranslate nohighlight">\(\lambda^2\)</span> values
correspond to spatially smoother and weaker current amplitudes, whereas smaller
<span class="math notranslate nohighlight">\(\lambda^2\)</span> values lead to the opposite.</p>
<p>We can arrive at the regularized linear inverse operator also by minimizing a
cost function <span class="math notranslate nohighlight">\(S\)</span> with respect to the estimated current <span class="math notranslate nohighlight">\(\hat{j}\)</span>
(given the measurement vector <span class="math notranslate nohighlight">\(x\)</span> at any given time <span class="math notranslate nohighlight">\(t\)</span>) as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\min_\hat{j} \Bigl\{ S \Bigr\} &amp;= \min_\hat{j} \Bigl\{ \tilde{e}^\top \tilde{e} + \lambda^2 \hat{j}^\top R^{-1} \hat{j} \Bigr\} \\
                               &amp;= \min_\hat{j} \Bigl\{ (x - G\hat{j})^\top C^{-1} (x - G\hat{j}) + \lambda^2 \hat{j}^\top R^{-1} \hat{j} \Bigr\} \,\end{split}\]</div>
<p>where the first term consists of the difference between the whitened measured
data (see <a class="reference internal" href="#whitening-and-scaling"><span class="std std-ref">Whitening and scaling</span></a>) and those predicted by the model while the
second term is a weighted-norm of the current estimate. It is seen that, with
increasing <span class="math notranslate nohighlight">\(\lambda^2\)</span>, the source term receive more weight and larger
discrepancy between the measured and predicted data is tolerable.</p>
</section>
<section id="whitening-and-scaling">
<span id="id12"></span><h3>Whitening and scaling<a class="headerlink" href="#whitening-and-scaling" title="Link to this heading">#</a></h3>
<p>The MNE software employs data whitening so that a ‘whitened’ inverse operator
assumes the form</p>
<div class="math notranslate nohighlight" id="inv-m-tilde">
<span id="equation-inv-m-tilde"></span><span class="eqno">(13)<a class="headerlink" href="#inv-m-tilde" title="Link to this equation">#</a></span>\[\tilde{M} = M C^{^1/_2} = R \tilde{G}^\top (\tilde{G} R \tilde{G}^\top + \lambda^2 I)^{-1}\ ,\]</div>
<p>where</p>
<div class="math notranslate nohighlight" id="inv-g-tilde">
<span id="equation-inv-g-tilde"></span><span class="eqno">(14)<a class="headerlink" href="#inv-g-tilde" title="Link to this equation">#</a></span>\[\tilde{G} = C^{-^1/_2}G\]</div>
<p>is the spatially whitened gain matrix. We arrive at the whitened inverse
operator equation <a class="reference internal" href="#equation-inv-m-tilde">(13)</a> by making the substitution for
<span class="math notranslate nohighlight">\(G\)</span> from <a class="reference internal" href="#equation-inv-g-tilde">(14)</a> in <a class="reference internal" href="#equation-inv-m">(12)</a> as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\tilde{M} = M C^{^1/_2} &amp;= R G^\top (G R G^\top + \lambda^2 C)^{-1} C^{^1/_2} \\
                         &amp;= R \tilde{G}^\top C^{^1/_2} (C^{^1/_2} \tilde{G} R \tilde{G}^\top C^{^1/_2} + \lambda^2 C)^{-1} C^{^1/_2} \\
                         &amp;= R \tilde{G}^\top C^{^1/_2} (C^{^1/_2} (\tilde{G} R \tilde{G}^\top + \lambda^2 I) C^{^1/_2})^{-1} C^{^1/_2} \\
                         &amp;= R \tilde{G}^\top C^{^1/_2} C^{-^1/_2} (\tilde{G} R \tilde{G}^\top + \lambda^2 I)^{-1} C^{-^1/_2} C^{^1/_2} \\
                         &amp;= R \tilde{G}^\top (\tilde{G} R \tilde{G}^\top + \lambda^2 I)^{-1}\ .\end{split}\]</div>
<p>The expected current values are</p>
<div class="math notranslate nohighlight" id="inv-j-hat-t">
<span id="equation-inv-j-hat-t"></span><span class="eqno">(15)<a class="headerlink" href="#inv-j-hat-t" title="Link to this equation">#</a></span>\[\begin{split} \hat{j}(t) &amp;= Mx(t) \\
            &amp;= M C^{^1/_2} C^{-^1/_2} x(t) \\
            &amp;= \tilde{M} \tilde{x}(t)\end{split}\]</div>
<p>knowing <a class="reference internal" href="#equation-inv-m-tilde">(13)</a> and taking</p>
<div class="math notranslate nohighlight" id="inv-tilde-x-t">
<span id="equation-inv-tilde-x-t"></span><span class="eqno">(16)<a class="headerlink" href="#inv-tilde-x-t" title="Link to this equation">#</a></span>\[ \tilde{x}(t) = C^{-^1/_2}x(t)\]</div>
<p>as the whitened measurement vector at time <em>t</em>. The spatial
whitening operator <span class="math notranslate nohighlight">\(C^{-^1/_2}\)</span> is obtained with the help of the
eigenvalue decomposition
<span class="math notranslate nohighlight">\(C = U_C \Lambda_C^2 U_C^\top\)</span> as <span class="math notranslate nohighlight">\(C^{-^1/_2} = \Lambda_C^{-1} U_C^\top\)</span>.
In the MNE software the noise-covariance matrix is stored as the one applying
to raw data. To reflect the decrease of noise due to averaging, this matrix,
<span class="math notranslate nohighlight">\(C_0\)</span>, is scaled by the number of averages, <span class="math notranslate nohighlight">\(L\)</span>, <em>i.e.</em>, <span class="math notranslate nohighlight">\(C =
C_0 / L\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When EEG data are included, the gain matrix <span class="math notranslate nohighlight">\(G\)</span> needs to be average referenced when computing the linear inverse operator <span class="math notranslate nohighlight">\(M\)</span>. This is incorporated during creating the spatial whitening operator <span class="math notranslate nohighlight">\(C^{-^1/_2}\)</span>, which includes any projectors on the data. EEG data average reference (using a projector) is mandatory for source modeling and is checked when calculating the inverse operator.</p>
</div>
<p>As shown above, regularization of the inverse solution is equivalent to a
change in the variance of the current amplitudes in the Bayesian <em>a priori</em>
distribution.</p>
<p>A convenient choice for the source-covariance matrix <span class="math notranslate nohighlight">\(R\)</span> is such that
<span class="math notranslate nohighlight">\(\text{trace}(\tilde{G} R \tilde{G}^\top) / \text{trace}(I) = 1\)</span>. With this
choice we can approximate <span class="math notranslate nohighlight">\(\lambda^2 \sim 1/\rm{SNR}^2\)</span>, where SNR is the
(amplitude) signal-to-noise ratio of the whitened data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The definition of the signal to noise-ratio/ <span class="math notranslate nohighlight">\(\lambda^2\)</span> relationship
given above works nicely for the whitened forward solution. In the
un-whitened case scaling with the trace ratio <span class="math notranslate nohighlight">\(\text{trace}(GRG^\top) /
\text{trace}(C)\)</span> does not make sense, since the diagonal elements summed
have, in general, different units of measure. For example, the MEG data are
expressed in T or T/m whereas the unit of EEG is Volts.</p>
</div>
<p>See <a class="reference internal" href="../auto_tutorials/forward/90_compute_covariance.html#tut-compute-covariance"><span class="std std-ref">Computing a covariance matrix</span></a> for example of noise covariance computation
and whitening.</p>
</section>
<section id="regularization-of-the-noise-covariance-matrix">
<span id="cov-regularization-math"></span><h3>Regularization of the noise-covariance matrix<a class="headerlink" href="#regularization-of-the-noise-covariance-matrix" title="Link to this heading">#</a></h3>
<p>Since finite amount of data is usually available to compute an estimate of the
noise-covariance matrix <span class="math notranslate nohighlight">\(C\)</span>, the smallest eigenvalues of its estimate are
usually inaccurate and smaller than the true eigenvalues. Depending on the
seriousness of this problem, the following quantities can be affected:</p>
<ul class="simple">
<li><p>The model data predicted by the current estimate,</p></li>
<li><p>Estimates of signal-to-noise ratios, which lead to estimates of the required
regularization, see <a class="reference internal" href="#mne-regularization"><span class="std std-ref">Regularization</span></a>,</p></li>
<li><p>The estimated current values, and</p></li>
<li><p>The noise-normalized estimates, see <a class="reference internal" href="#noise-normalization"><span class="std std-ref">Noise normalization</span></a>.</p></li>
</ul>
<p>Fortunately, the latter two are least likely to be affected due to
regularization of the estimates. However, in some cases especially the EEG part
of the noise-covariance matrix estimate can be deficient, <em>i.e.</em>, it may
possess very small eigenvalues and thus regularization of the noise-covariance
matrix is advisable.</p>
<p>Historically, the MNE software accomplishes the regularization by replacing a
noise-covariance matrix estimate <span class="math notranslate nohighlight">\(C\)</span> with</p>
<div class="math notranslate nohighlight">
\[C' = C + \sum_k {\varepsilon_k \bar{\sigma_k}^2 I^{(k)}}\ ,\]</div>
<p>where the index <span class="math notranslate nohighlight">\(k\)</span> goes across the different channel groups (MEG planar
gradiometers, MEG axial gradiometers and magnetometers, and EEG),
<span class="math notranslate nohighlight">\(\varepsilon_k\)</span> are the corresponding regularization factors,
<span class="math notranslate nohighlight">\(\bar{\sigma_k}\)</span> are the average variances across the channel groups, and
<span class="math notranslate nohighlight">\(I^{(k)}\)</span> are diagonal matrices containing ones at the positions
corresponding to the channels contained in each channel group.</p>
<p>See <a class="reference internal" href="../auto_tutorials/forward/90_compute_covariance.html#plot-compute-covariance-howto"><span class="std std-ref">How should I regularize the covariance matrix?</span></a> for details on computing and
regularizing the channel covariance matrix.</p>
</section>
<section id="computation-of-the-solution">
<span id="mne-solution"></span><h3>Computation of the solution<a class="headerlink" href="#computation-of-the-solution" title="Link to this heading">#</a></h3>
<p>The most straightforward approach to calculate the MNE is to employ the
expression of the original or whitened inverse operator directly. However, for
computational convenience we prefer to take another route, which employs the
singular-value decomposition (SVD) of the matrix</p>
<div class="math notranslate nohighlight" id="inv-a">
<span id="equation-inv-a"></span><span class="eqno">(17)<a class="headerlink" href="#inv-a" title="Link to this equation">#</a></span>\[\begin{split} A &amp;= \tilde{G} R^{^1/_2} \\
   &amp;= U \Lambda V^\top\end{split}\]</div>
<p>where the superscript <span class="math notranslate nohighlight">\(^1/_2\)</span> indicates a square root of <span class="math notranslate nohighlight">\(R\)</span>. For a
diagonal matrix, one simply takes the square root of <span class="math notranslate nohighlight">\(R\)</span> while in the
more general case one can use the Cholesky factorization <span class="math notranslate nohighlight">\(R = R_C R_C^\top\)</span>
and thus <span class="math notranslate nohighlight">\(R^{^1/_2} = R_C\)</span>.</p>
<p>Combining the SVD from <a class="reference internal" href="#equation-inv-a">(17)</a> with the inverse equation <a class="reference internal" href="#equation-inv-m">(12)</a> it is
easy to show that</p>
<div class="math notranslate nohighlight" id="inv-m-tilde-svd">
<span id="equation-inv-m-tilde-svd"></span><span class="eqno">(18)<a class="headerlink" href="#inv-m-tilde-svd" title="Link to this equation">#</a></span>\[\begin{split} \tilde{M} &amp;= R \tilde{G}^\top (\tilde{G} R \tilde{G}^\top + \lambda^2 I)^{-1} \\
           &amp;= R^{^1/_2} A^\top (A A^\top + \lambda^2 I)^{-1} \\
           &amp;= R^{^1/_2} V \Lambda U^\top (U \Lambda V^\top V \Lambda U^\top + \lambda^2 I)^{-1} \\
           &amp;= R^{^1/_2} V \Lambda U^\top (U (\Lambda^2 + \lambda^2 I) U^\top)^{-1} \\
           &amp;= R^{^1/_2} V \Lambda U^\top U (\Lambda^2 + \lambda^2 I)^{-1} U^\top \\
           &amp;= R^{^1/_2} V \Lambda (\Lambda^2 + \lambda^2 I)^{-1} U^\top \\
           &amp;= R^{^1/_2} V \Gamma U^\top\end{split}\]</div>
<p>where the elements of the diagonal matrix <span class="math notranslate nohighlight">\(\Gamma\)</span> are simply</p>
<div class="math notranslate nohighlight" id="inv-gamma-k">
<span id="equation-inv-gamma-k"></span><span class="eqno">(19)<a class="headerlink" href="#inv-gamma-k" title="Link to this equation">#</a></span>\[ \gamma_k = \frac{\lambda_k}{\lambda_k^2 + \lambda^2}\ .\]</div>
<p>From our expected current equation <a class="reference internal" href="#equation-inv-j-hat-t">(15)</a> and our whitened
measurement equation <a class="reference internal" href="#equation-inv-tilde-x-t">(16)</a>, if we take</p>
<div class="math notranslate nohighlight" id="inv-w-t">
<span id="equation-inv-w-t"></span><span class="eqno">(20)<a class="headerlink" href="#inv-w-t" title="Link to this equation">#</a></span>\[\begin{split} w(t) &amp;= U^\top \tilde{x}(t) \\
      &amp;= U^\top C^{-^1/_2} x(t)\ ,\end{split}\]</div>
<p>we can see that the expression for the expected current is just</p>
<div class="math notranslate nohighlight" id="inv-j-hat-t-svd">
<span id="equation-inv-j-hat-t-svd"></span><span class="eqno">(21)<a class="headerlink" href="#inv-j-hat-t-svd" title="Link to this equation">#</a></span>\[\begin{split} \hat{j}(t) &amp;= R^{^1/_2} V \Gamma w(t) \\
            &amp;= \sum_k {\bar{v_k} \gamma_k w_k(t)}\ ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\bar{v_k} = R^{^1/_2} v_k\)</span>, with <span class="math notranslate nohighlight">\(v_k\)</span> being the
<span class="math notranslate nohighlight">\(k\)</span> th column of <span class="math notranslate nohighlight">\(V\)</span>. It is thus seen that the current estimate is
a weighted sum of the “weighted” eigenleads <span class="math notranslate nohighlight">\(v_k\)</span>.</p>
<p>It is easy to see that <span class="math notranslate nohighlight">\(w(t) \propto \sqrt{L}\)</span>. To maintain the relation
<span class="math notranslate nohighlight">\((\tilde{G} R \tilde{G}^\top) / \text{trace}(I) = 1\)</span> when <span class="math notranslate nohighlight">\(L\)</span> changes
we must have <span class="math notranslate nohighlight">\(R \propto 1/L\)</span>. With this approach, <span class="math notranslate nohighlight">\(\lambda_k\)</span> is
independent of  <span class="math notranslate nohighlight">\(L\)</span> and, for fixed <span class="math notranslate nohighlight">\(\lambda\)</span>, we see directly that
<span class="math notranslate nohighlight">\(j(t)\)</span> is independent of <span class="math notranslate nohighlight">\(L\)</span>.</p>
<p>The minimum-norm estimate is computed using this procedure in
<a class="reference internal" href="../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a>, and its usage is illustrated
in <a class="reference internal" href="cookbook.html#cihcfjei"><span class="std std-ref">Calculating the inverse operator</span></a>.</p>
</section>
<section id="noise-normalization">
<span id="id13"></span><h3>Noise normalization<a class="headerlink" href="#noise-normalization" title="Link to this heading">#</a></h3>
<p>Noise normalization serves three purposes:</p>
<ul class="simple">
<li><p>It converts the expected current value into a dimensionless statistical test
variable. Thus the resulting time and location dependent values are often
referred to as dynamic statistical parameter maps (dSPM).</p></li>
<li><p>It reduces the location bias of the estimates. In particular, the tendency of
the MNE to prefer superficial currents is eliminated.</p></li>
<li><p>The width of the point-spread function becomes less dependent on the source
location on the cortical mantle. The point-spread is defined as the MNE
resulting from the signals coming from a point current source (a current
dipole) located at a certain point on the cortex.</p></li>
</ul>
<p>In practice, noise normalization is implemented as a division by the square
root of the estimated variance of each voxel. In computing these noise
normalization factors, it’s convenient to reuse our “weighted eigenleads”
definition from equation <a class="reference internal" href="#equation-inv-j-hat-t">(15)</a> in matrix form as</p>
<div class="math notranslate nohighlight" id="inv-eigenleads-weighted">
<span id="equation-inv-eigenleads-weighted"></span><span class="eqno">(22)<a class="headerlink" href="#inv-eigenleads-weighted" title="Link to this equation">#</a></span>\[ \bar{V} = R^{^1/_2} V\ .\]</div>
<section id="dspm">
<h4>dSPM<a class="headerlink" href="#dspm" title="Link to this heading">#</a></h4>
<p>Noise-normalized linear estimates introduced by Dale et al.
<a class="footnote-reference brackets" href="#footcite-daleetal1999" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a> require division of the expected current amplitude by
its variance. In practice, this requires the computation of the diagonal
elements of the following matrix, using SVD equation <a class="reference internal" href="#equation-inv-m-tilde">(13)</a> and
<a class="reference internal" href="#equation-inv-eigenleads-weighted">(22)</a>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}M C M^\top &amp;= M C^{^1/_2} C^{^1/_2} M^\top \\
        &amp;= \tilde{M} \tilde{M}^\top \\
        &amp;= R^{^1/_2} V \Gamma U^\top U \Gamma V^\top R^{^1/_2} \\
        &amp;= \bar{V} \Gamma^2 \bar{V}^\top\ .\end{split}\]</div>
<p>Because we only care about the diagonal entries here, we can find the
variances for each source as</p>
<div class="math notranslate nohighlight">
\[\sigma_k^2 = \gamma_k^2\]</div>
<p>Under the conditions expressed at the end of <a class="reference internal" href="#mne-solution"><span class="std std-ref">Computation of the solution</span></a>, it
follows that the <em>t</em>-statistic values associated with fixed-orientation
sources) are thus proportional to <span class="math notranslate nohighlight">\(\sqrt{L}\)</span> while the <em>F</em>-statistic
employed with free-orientation sources is proportional to <span class="math notranslate nohighlight">\(L\)</span>,
correspondingly.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The MNE software usually computes the <em>square roots</em> of the F-statistic to
be displayed on the inflated cortical surfaces. These are also proportional
to <span class="math notranslate nohighlight">\(\sqrt{L}\)</span>.</p>
</div>
</section>
<section id="sloreta">
<h4>sLORETA<a class="headerlink" href="#sloreta" title="Link to this heading">#</a></h4>
<p>sLORETA <a class="footnote-reference brackets" href="#footcite-pascual-marqui2002" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> estimates the current variances as the
diagonal entries of the
resolution matrix, which is the product of the inverse and forward operators.
In other words, the diagonal entries of (using <a class="reference internal" href="#equation-inv-m-tilde-svd">(18)</a>,
<a class="reference internal" href="#equation-inv-g-tilde">(14)</a>, and <a class="reference internal" href="#equation-inv-a">(17)</a>)</p>
<div class="math notranslate nohighlight">
\[\begin{split}M G &amp;= M C^{^1/_2} C^{-^1/_2} G \\
    &amp;= \tilde{M} \tilde{G} \\
    &amp;= R^{^1/_2} V \Gamma U^\top \tilde{G} R^{^1/_2} R^{-^1/_2} \\
    &amp;= R^{^1/_2} V \Gamma U^\top U \Lambda V^\top R^{-^1/_2} \\
    &amp;= R^{^1/_2} V \Gamma U^\top U \Lambda V^\top R^{^1/_2} R^{-1} \\
    &amp;= \bar{V} \Gamma U^\top U \Lambda \bar{V}^\top R^{-1} \\
    &amp;= \bar{V} \Gamma \Lambda \bar{V}^\top R^{-1}\ .\end{split}\]</div>
<p>Because <span class="math notranslate nohighlight">\(R\)</span> is diagonal and we only care about the diagonal entries,
we can find our variance estimates as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\sigma_k^2 &amp;= \gamma_k \lambda_k R_{k,k}^{-1} \\
           &amp;= \left(\frac{\lambda_k}{(\lambda_k^2 + \lambda^2)}\right) \left(\frac{\lambda_k}{1}\right) \left(\frac{1}{\lambda^2}\right) \\
           &amp;= \frac{\lambda_k^2}{(\lambda_k^2 + \lambda^2) \lambda^2} \\
           &amp;= \left(\frac{\lambda_k^2}{(\lambda_k^2 + \lambda^2)^2}\right) \left(\frac{\lambda^2 + \lambda_k^2}{\lambda^2}\right) \\
           &amp;= \left(\frac{\lambda_k}{\lambda_k^2 + \lambda^2}\right)^2 \left(1 + \frac{\lambda_k^2}{\lambda^2}\right) \\
           &amp;= \gamma_k^2 \left(1 + \frac{\lambda_k^2}{\lambda^2}\right)\ .\end{split}\]</div>
</section>
</section>
<section id="eloreta">
<h3>eLORETA<a class="headerlink" href="#eloreta" title="Link to this heading">#</a></h3>
<p>While dSPM and sLORETA solve for noise normalization weights
<span class="math notranslate nohighlight">\(\sigma^2_k\)</span> that are applied to standard minimum-norm estimates
<span class="math notranslate nohighlight">\(\hat{j}(t)\)</span>, eLORETA <a class="footnote-reference brackets" href="#footcite-pascual-marqui2011" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a> instead solves for
a source covariance
matrix <span class="math notranslate nohighlight">\(R\)</span> that achieves zero localization bias. For fixed-orientation
solutions the resulting matrix <span class="math notranslate nohighlight">\(R\)</span> will be a diagonal matrix, and for
free-orientation solutions it will be a block-diagonal matrix with
<span class="math notranslate nohighlight">\(3 \times 3\)</span> blocks.</p>
<p>In <a class="footnote-reference brackets" href="#footcite-pascual-marqui2011" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a> eq. 2.13 states that the following system
of equations can be used to find the weights, <span class="math notranslate nohighlight">\(\forall i \in {1, ..., P}\)</span>
(note that here we represent the equations from that paper using our notation):</p>
<div class="math notranslate nohighlight">
\[r_i = \left[ G_i^\top \left( GRG^\top + \lambda^2C \right)^{-1} G_i \right] ^{-^1/_2}\]</div>
<p>And an iterative algorithm can be used to find the values for the weights
<span class="math notranslate nohighlight">\(r_i\)</span> that satisfy these equations as:</p>
<ol class="arabic simple">
<li><p>Initialize identity weights.</p></li>
<li><p>Compute <span class="math notranslate nohighlight">\(N= \left( GRG^\top + \lambda^2C \right)^{-1}\)</span>.</p></li>
<li><p>Holding <span class="math notranslate nohighlight">\(N\)</span> fixed, compute new weights <span class="math notranslate nohighlight">\(r_i = \left[ G_i^\top N G_i \right]^{-^1/_2}\)</span>.</p></li>
<li><p>Using new weights, go to step (2) until convergence.</p></li>
</ol>
<p>In particular, for step (2) we can use our substitution from <a class="reference internal" href="#equation-inv-g-tilde">(14)</a>
as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}N &amp;= (G R G^\top + \lambda^2 C)^{-1} \\
  &amp;= (C^{^1/_2} \tilde{G} R \tilde{G}^\top C^{^1/_2} + \lambda^2 C)^{-1} \\
  &amp;= (C^{^1/_2} (\tilde{G} R \tilde{G}^\top + \lambda^2 I) C^{^1/_2})^{-1} \\
  &amp;= C^{-^1/_2} (\tilde{G} R \tilde{G}^\top + \lambda^2 I)^{-1} C^{-^1/_2} \\
  &amp;= C^{-^1/_2} (\tilde{G} R \tilde{G}^\top + \lambda^2 I)^{-1} C^{-^1/_2}\ .\end{split}\]</div>
<p>Then defining <span class="math notranslate nohighlight">\(\tilde{N}\)</span> as the whitened version of <span class="math notranslate nohighlight">\(N\)</span>, i.e.,
the regularized pseudoinverse of <span class="math notranslate nohighlight">\(\tilde{G}R\tilde{G}^\top\)</span>, we can
compute <span class="math notranslate nohighlight">\(N\)</span> as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}N &amp;= C^{-^1/_2} (U_{\tilde{G}R\tilde{G}^\top} \Lambda_{\tilde{G}R\tilde{G}^\top} V_{\tilde{G}R\tilde{G}^\top}^\top + \lambda^2 I)^{-1} C^{-^1/_2} \\
  &amp;= C^{-^1/_2} (U_{\tilde{G}R\tilde{G}^\top} (\Lambda_{\tilde{G}R\tilde{G}^\top} + \lambda^2 I) V_{\tilde{G}R\tilde{G}^\top}^\top)^{-1} C^{-^1/_2} \\
  &amp;= C^{-^1/_2} V_{\tilde{G}R\tilde{G}^\top} (\Lambda_{\tilde{G}R\tilde{G}^\top} + \lambda^2 I)^{-1} U_{\tilde{G}R\tilde{G}^\top}^\top C^{-^1/_2} \\
  &amp;= C^{-^1/_2} \tilde{N} C^{-^1/_2}\ .\end{split}\]</div>
<p>In step (3) we left and right multiply with subsets of <span class="math notranslate nohighlight">\(G\)</span>, but making
the substitution <a class="reference internal" href="#equation-inv-g-tilde">(14)</a> we see that we equivalently compute:</p>
<div class="math notranslate nohighlight">
\[\begin{split}r_i &amp;= \left[ G_i^\top N G_i \right]^{-^1/_2} \\
    &amp;= \left[ (C^{^1/_2} \tilde{G}_i)^\top N C^{^1/_2} \tilde{G}_i \right]^{-^1/_2} \\
    &amp;= \left[ \tilde{G}_i^\top C^{^1/_2} N C^{^1/_2} \tilde{G}_i \right]^{-^1/_2} \\
    &amp;= \left[ \tilde{G}_i^\top C^{^1/_2} C^{-^1/_2} \tilde{N} C^{-^1/_2} C^{^1/_2} \tilde{G}_i \right]^{-^1/_2} \\
    &amp;= \left[ \tilde{G}_i^\top \tilde{N} \tilde{G}_i \right]^{-^1/_2}\ .\end{split}\]</div>
<p>For convenience, we thus never need to compute <span class="math notranslate nohighlight">\(N\)</span> itself but can instead
compute the whitened version <span class="math notranslate nohighlight">\(\tilde{N}\)</span>.</p>
</section>
<section id="predicted-data">
<h3>Predicted data<a class="headerlink" href="#predicted-data" title="Link to this heading">#</a></h3>
<p>Under noiseless conditions the SNR is infinite and thus leads to
<span class="math notranslate nohighlight">\(\lambda^2 = 0\)</span> and the minimum-norm estimate explains the measured data
perfectly. Under realistic conditions, however, <span class="math notranslate nohighlight">\(\lambda^2 &gt; 0\)</span> and there
is a misfit between measured data and those predicted by the MNE. Comparison of
the predicted data, here denoted by <span class="math notranslate nohighlight">\(x(t)\)</span>, and measured one can give
valuable insight on the correctness of the regularization applied.</p>
<p>In the SVD approach we easily find</p>
<div class="math notranslate nohighlight">
\[\hat{x}(t) = G \hat{j}(t) = C^{^1/_2} U \Pi w(t)\ ,\]</div>
<p>where the diagonal matrix <span class="math notranslate nohighlight">\(\Pi\)</span> has elements <span class="math notranslate nohighlight">\(\pi_k = \lambda_k
\gamma_k\)</span> The predicted data is thus expressed as the weighted sum of the
‘recolored eigenfields’ in <span class="math notranslate nohighlight">\(C^{^1/_2} U\)</span>.</p>
</section>
<section id="cortical-patch-statistics">
<h3>Cortical patch statistics<a class="headerlink" href="#cortical-patch-statistics" title="Link to this heading">#</a></h3>
<p>If the <code class="docutils literal notranslate"><span class="pre">add_dists=True</span></code> option was used in source space creation,
the source space file will contain
Cortical Patch Statistics (CPS) for each vertex of the cortical surface. The
CPS provide information about the source space point closest to it as well as
the distance from the vertex to this source space point. The vertices for which
a given source space point is the nearest one define the cortical patch
associated with with the source space point. Once these data are available, it
is straightforward to compute the following cortical patch statistics for each
source location <span class="math notranslate nohighlight">\(d\)</span>:</p>
<ul class="simple">
<li><p>The average over the normals of at the vertices in a patch,
<span class="math notranslate nohighlight">\(\bar{n_d}\)</span>,</p></li>
<li><p>The areas of the patches, <span class="math notranslate nohighlight">\(A_d\)</span>, and</p></li>
<li><p>The average deviation of the vertex normals in a patch from their average,
<span class="math notranslate nohighlight">\(\sigma_d\)</span>, given in degrees.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">use_cps</span></code> parameter in <a class="reference internal" href="../generated/mne.convert_forward_solution.html#mne.convert_forward_solution" title="mne.convert_forward_solution"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.convert_forward_solution()</span></code></a>, and
<a class="reference internal" href="../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a> controls whether to use
cortical patch statistics (CPS) to define normal orientations or not (see
<a class="reference internal" href="cookbook.html#chdbbcej"><span class="std std-ref">Cortical surface reconstruction with FreeSurfer</span></a>).</p>
</section>
<section id="orientation-constraints">
<span id="inverse-orientation-constraints"></span><h3>Orientation constraints<a class="headerlink" href="#orientation-constraints" title="Link to this heading">#</a></h3>
<p>The principal sources of MEG and EEG signals are generally believed to be
postsynaptic currents in the cortical pyramidal neurons. Since the net primary
current associated with these microscopic events is oriented normal to the
cortical mantle, it is reasonable to use the cortical normal orientation as a
constraint in source estimation. In addition to allowing completely free source
orientations, the MNE software implements three orientation constraints based
of the surface normal data:</p>
<ul class="simple">
<li><p>Source orientation can be rigidly fixed to the surface normal direction by
specifying <code class="docutils literal notranslate"><span class="pre">fixed=True</span></code> in <a class="reference internal" href="../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a>.
If cortical patch statistics are available the average
normal over each patch, <span class="math notranslate nohighlight">\(\bar{n_d}\)</span>, are used to define the source
orientation. Otherwise, the vertex normal at the source space location is
employed.</p></li>
<li><p>A <em>location independent or fixed loose orientation constraint</em> (fLOC) can be
employed by specifying <code class="docutils literal notranslate"><span class="pre">fixed=False</span></code> and <code class="docutils literal notranslate"><span class="pre">loose=1.0</span></code> when
calling <a class="reference internal" href="../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a> (see
<a class="reference internal" href="../auto_tutorials/inverse/35_dipole_orientations.html#plot-dipole-orientations-floc-orientations"><span class="std std-ref">Loose dipole orientations</span></a>).
In this approach, a source coordinate
system based on the local surface orientation at the source location is
employed. By default, the three columns of the gain matrix G, associated with
a given source location, are the fields of unit dipoles pointing to the
directions of the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, and <span class="math notranslate nohighlight">\(z\)</span> axis of the coordinate
system employed in the forward calculation (usually the <a class="reference internal" href="#head-device-coords"><span class="std std-ref">MEG head
coordinate frame</span></a>). For LOC the orientation is changed so
that the first two source components lie in the plane normal to the surface
normal at the source location and the third component is aligned with it.
Thereafter, the variance of the source components tangential to the cortical
surface are reduced by a factor defined by the <code class="docutils literal notranslate"><span class="pre">--loose</span></code> option.</p></li>
<li><p>A <em>variable loose orientation constraint</em> (vLOC) can be employed by
specifying <code class="docutils literal notranslate"><span class="pre">fixed=False</span></code> and <code class="docutils literal notranslate"><span class="pre">loose</span></code> parameters when calling
<a class="reference internal" href="../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a> (see
<a class="reference internal" href="../auto_tutorials/inverse/35_dipole_orientations.html#plot-dipole-orientations-vloc-orientations"><span class="std std-ref">Limiting orientations, but not fixing them</span></a>). This
is similar to <em>fLOC</em> except that the value given with the <code class="docutils literal notranslate"><span class="pre">loose</span></code>
parameter will be multiplied by <span class="math notranslate nohighlight">\(\sigma_d\)</span>, defined above.</p></li>
</ul>
</section>
<section id="depth-weighting">
<h3>Depth weighting<a class="headerlink" href="#depth-weighting" title="Link to this heading">#</a></h3>
<p>The minimum-norm estimates have a bias towards superficial currents. This
tendency can be alleviated by adjusting the source covariance matrix <span class="math notranslate nohighlight">\(R\)</span>
to favor deeper source locations. In the depth weighting scheme employed in MNE
analyze, the elements of <span class="math notranslate nohighlight">\(R\)</span> corresponding to the <span class="math notranslate nohighlight">\(p\)</span> th source
location are be scaled by a factor</p>
<div class="math notranslate nohighlight">
\[f_p = (g_{1p}^\top g_{1p} + g_{2p}^\top g_{2p} + g_{3p}^\top g_{3p})^{-\gamma}\ ,\]</div>
<p>where <span class="math notranslate nohighlight">\(g_{1p}\)</span>, <span class="math notranslate nohighlight">\(g_{2p}\)</span>, and <span class="math notranslate nohighlight">\(g_{3p}\)</span> are the three columns
of <span class="math notranslate nohighlight">\(G\)</span> corresponding to source location <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(\gamma\)</span> is
the order of the depth weighting, which is specified via the <code class="docutils literal notranslate"><span class="pre">depth</span></code> option
in <a class="reference internal" href="../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a>.</p>
</section>
<section id="effective-number-of-averages">
<h3>Effective number of averages<a class="headerlink" href="#effective-number-of-averages" title="Link to this heading">#</a></h3>
<p>It is often the case that the epoch to be analyzed is a linear combination over
conditions rather than one of the original averages computed. As stated above,
the noise-covariance matrix computed is originally one corresponding to raw
data. Therefore, it has to be scaled correctly to correspond to the actual or
effective number of epochs in the condition to be analyzed. In general, we have</p>
<div class="math notranslate nohighlight">
\[C = C_0 / L_{eff}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{eff}\)</span> is the effective number of averages. To calculate
<span class="math notranslate nohighlight">\(L_{eff}\)</span> for an arbitrary linear combination of conditions</p>
<div class="math notranslate nohighlight">
\[y(t) = \sum_{i = 1}^n {w_i x_i(t)}\]</div>
<p>we make use of the the fact that the noise-covariance matrix</p>
<div class="math notranslate nohighlight">
\[C_y = \sum_{i = 1}^n {w_i^2 C_{x_i}} = C_0 \sum_{i = 1}^n {w_i^2 / L_i}\]</div>
<p>which leads to</p>
<div class="math notranslate nohighlight">
\[1 / L_{eff} = \sum_{i = 1}^n {w_i^2 / L_i}\]</div>
<p>An important special case  of the above is a weighted average, where</p>
<div class="math notranslate nohighlight">
\[w_i = L_i / \sum_{i = 1}^n {L_i}\]</div>
<p>and, therefore</p>
<div class="math notranslate nohighlight">
\[L_{eff} = \sum_{i = 1}^n {L_i}\]</div>
<p>Instead of a weighted average, one often computes a weighted sum, a simplest
case being a difference or sum of two categories. For a difference <span class="math notranslate nohighlight">\(w_1 =
1\)</span> and <span class="math notranslate nohighlight">\(w_2 = -1\)</span> and thus</p>
<div class="math notranslate nohighlight">
\[1 / L_{eff} = 1 / L_1 + 1 / L_2\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[L_{eff} = \frac{L_1 L_2}{L_1 + L_2}\]</div>
<p>Interestingly, the same holds for a sum, where <span class="math notranslate nohighlight">\(w_1 = w_2 = 1\)</span>.
Generalizing, for any combination of sums and differences, where <span class="math notranslate nohighlight">\(w_i =
1\)</span> or <span class="math notranslate nohighlight">\(w_i = -1\)</span>, <span class="math notranslate nohighlight">\(i = 1 \dotso n\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[1 / L_{eff} = \sum_{i = 1}^n {1/{L_i}}\]</div>
</section>
</section>
<section id="morphing-and-averaging-source-estimates">
<span id="ch-morph"></span><h2>Morphing and averaging source estimates<a class="headerlink" href="#morphing-and-averaging-source-estimates" title="Link to this heading">#</a></h2>
<section id="why-morphing">
<h3>Why morphing?<a class="headerlink" href="#why-morphing" title="Link to this heading">#</a></h3>
<div class="sidebar admonition note">
<p class="admonition-title">Note</p>
<p>Morphing examples in MNE-Python</p>
<p>Examples of morphing in MNE-Python include <a class="reference internal" href="../auto_tutorials/inverse/40_mne_fixed_free.html#tut-mne-fixed-free"><span class="std std-ref">this tutorial</span></a> on surface source estimation or these examples on
<a class="reference internal" href="../auto_examples/inverse/morph_surface_stc.html#ex-morph-surface"><span class="std std-ref">surface</span></a> and <a class="reference internal" href="../auto_examples/inverse/morph_volume_stc.html#ex-morph-volume"><span class="std std-ref">volumetric</span></a>
source estimation.</p>
</div>
<p>Modern neuroimaging techniques, such as source reconstruction or fMRI analyses,
make use of advanced mathematical models and hardware to map brain activity
patterns into a subject-specific anatomical brain space. This enables the study
of spatio-temporal brain activity. The representation of spatio-temporal brain
data is often mapped onto the anatomical brain structure to relate functional
and anatomical maps. Thereby activity patterns are overlaid with anatomical
locations that supposedly produced the activity. Anatomical MR images are often
used as such or are transformed into an inflated surface representations to
serve as  “canvas” for the visualization.</p>
<p>In order to compute group-level statistics, data representations across
subjects must be morphed to a common frame, such that anatomically and
functional similar structures are represented at the same spatial location for
<em>all subjects equally</em>. Since brains vary, <a class="reference internal" href="glossary.html#term-morphing"><span class="xref std std-term">morphing</span></a> comes into play to
tell us how the data produced by subject A would be represented on the brain of
subject B (and vice-versa).</p>
</section>
<section id="the-morphing-maps">
<h3>The morphing maps<a class="headerlink" href="#the-morphing-maps" title="Link to this heading">#</a></h3>
<p>The MNE software accomplishes morphing with help of morphing maps.
The morphing is performed with help of the registered
spherical surfaces (<code class="docutils literal notranslate"><span class="pre">lh.sphere.reg</span></code> and <code class="docutils literal notranslate"><span class="pre">rh.sphere.reg</span></code> ) which must be
produced in FreeSurfer. A morphing map is a linear mapping from cortical
surface values in subject A (<span class="math notranslate nohighlight">\(x^{(A)}\)</span>) to those in another subject B
(<span class="math notranslate nohighlight">\(x^{(B)}\)</span>)</p>
<div class="math notranslate nohighlight">
\[x^{(B)} = M^{(AB)} x^{(A)}\ ,\]</div>
<p>where <span class="math notranslate nohighlight">\(M^{(AB)}\)</span> is a sparse matrix with at most three nonzero elements
on each row. These elements are determined as follows. First, using the aligned
spherical surfaces, for each vertex <span class="math notranslate nohighlight">\(x_j^{(B)}\)</span>, find the triangle
<span class="math notranslate nohighlight">\(T_j^{(A)}\)</span> on the spherical surface of subject A which contains the
location <span class="math notranslate nohighlight">\(x_j^{(B)}\)</span>. Next, find the numbers of the vertices of this
triangle and set the corresponding elements on the <em>j</em> th row of
<span class="math notranslate nohighlight">\(M^{(AB)}\)</span> so that <span class="math notranslate nohighlight">\(x_j^{(B)}\)</span> will be a linear interpolation
between the triangle vertex values reflecting the location <span class="math notranslate nohighlight">\(x_j^{(B)}\)</span>
within the triangle <span class="math notranslate nohighlight">\(T_j^{(A)}\)</span>.</p>
<p>It follows from the above definition that in general</p>
<div class="math notranslate nohighlight">
\[M^{(AB)} \neq (M^{(BA)})^{-1}\ ,\]</div>
<p><em>i.e.</em>,</p>
<div class="math notranslate nohighlight">
\[x_{(A)} \neq M^{(BA)} M^{(AB)} x^{(A)}\ ,\]</div>
<p>even if</p>
<div class="math notranslate nohighlight">
\[x^{(A)} \approx M^{(BA)} M^{(AB)} x^{(A)}\ ,\]</div>
<p><em>i.e.</em>, the mapping is <em>almost</em> a bijection.</p>
</section>
<section id="about-smoothing">
<h3>About smoothing<a class="headerlink" href="#about-smoothing" title="Link to this heading">#</a></h3>
<p>The current estimates are normally defined only in a decimated grid which is a
sparse subset of the vertices in the triangular tessellation of the cortical
surface. Therefore, any sparse set of values is distributed to neighboring
vertices to make the visualized results easily understandable. This procedure
has been traditionally called smoothing but a more appropriate name might be
smudging or blurring in accordance with similar operations in image processing
programs.</p>
<p>In MNE software terms, smoothing of the vertex data is an iterative procedure,
which produces a blurred image <span class="math notranslate nohighlight">\(x^{(N)}\)</span> from the original sparse image
<span class="math notranslate nohighlight">\(x^{(0)}\)</span> by applying in each iteration step a sparse blurring matrix:</p>
<div class="math notranslate nohighlight">
\[x^{(p)} = S^{(p)} x^{(p - 1)}\ .\]</div>
<p>On each row <span class="math notranslate nohighlight">\(j\)</span> of the matrix <span class="math notranslate nohighlight">\(S^{(p)}\)</span> there are <span class="math notranslate nohighlight">\(N_j^{(p -
1)}\)</span> nonzero entries whose values equal <span class="math notranslate nohighlight">\(1/N_j^{(p - 1)}\)</span>. Here
<span class="math notranslate nohighlight">\(N_j^{(p - 1)}\)</span> is the number of immediate neighbors of vertex <span class="math notranslate nohighlight">\(j\)</span>
which had non-zero values at iteration step <span class="math notranslate nohighlight">\(p - 1\)</span>. Matrix
<span class="math notranslate nohighlight">\(S^{(p)}\)</span> thus assigns the average of the non-zero neighbors as the new
value for vertex <span class="math notranslate nohighlight">\(j\)</span>. One important feature of this procedure is that it
tends to preserve the amplitudes while blurring the surface image.</p>
<p>Once the indices non-zero vertices in <span class="math notranslate nohighlight">\(x^{(0)}\)</span> and the topology of the
triangulation are fixed the matrices <span class="math notranslate nohighlight">\(S^{(p)}\)</span> are fixed and independent
of the data. Therefore, it would be in principle possible to construct a
composite blurring matrix</p>
<div class="math notranslate nohighlight">
\[S^{(N)} = \prod_{p = 1}^N {S^{(p)}}\ .\]</div>
<p>However, it turns out to be computationally more effective to do blurring with
an iteration. The above formula for <span class="math notranslate nohighlight">\(S^{(N)}\)</span> also shows that the
smudging (smoothing) operation is linear.</p>
</section>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading">#</a></h2>
<div class="docutils container" id="id18">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-perrinetal1989" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">1</a><span class="fn-bracket">]</span></span>
<p>François M. Perrin, Jacques Pernier, Olivier M. Bertrand, and Jean Franćois Echallier. Spherical splines for scalp potential and current density mapping. <em>Electroencephalography and Clinical Neurophysiology</em>, 72(2):184–187, 1989. <a class="reference external" href="https://doi.org/10.1016/0013-4694(89)90180-6">doi:10.1016/0013-4694(89)90180-6</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-tescheetal1995" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">2</a><span class="fn-bracket">]</span></span>
<p>Claudia D. Tesche, Mikko A. Uusitalo, Risto J. Ilmoniemi, Minna Huotilainen, Matti J. Kajola, and Oili L. M. Salonen. Signal-space projections of MEG data characterize both distributed and well-localized neuronal sources. <em>Electroencephalography and Clinical Neurophysiology</em>, 95(3):189–200, 1995. <a class="reference external" href="https://doi.org/10.1016/0013-4694(95)00064-6">doi:10.1016/0013-4694(95)00064-6</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-uusitaloilmoniemi1997" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">3</a><span class="fn-bracket">]</span></span>
<p>Mikko A. Uusitalo and Risto J. Ilmoniemi. Signal-space projection method for separating MEG or EEG into components. <em>Medical &amp; Biological Engineering &amp; Computing</em>, 35(2):135–140, 1997. <a class="reference external" href="https://doi.org/10.1007/BF02534144">doi:10.1007/BF02534144</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-fischletal2004" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">4</a><span class="fn-bracket">]</span></span>
<p>Bruce Fischl, David H. Salat, André J.W. van der Kouwe, Nikos Makris, Florent Ségonne, Brian T. Quinn, and Anders M. Dale. Sequence-independent segmentation of magnetic resonance images. <em>NeuroImage</em>, 23:S69–S84, 2004. <a class="reference external" href="https://doi.org/10.1016/j.neuroimage.2004.07.016">doi:10.1016/j.neuroimage.2004.07.016</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-mosheretal1999" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">5</a><span class="fn-bracket">]</span></span>
<p>John C. Mosher, Richard M. Leahy, and Paul S. Lewis. EEG and MEG: forward solutions for inverse methods. <em>IEEE Transactions on Biomedical Engineering</em>, 46(3):245–259, 1999. <a class="reference external" href="https://doi.org/10.1109/10.748978">doi:10.1109/10.748978</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-zhang1995" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">6</a><span class="fn-bracket">]</span></span>
<p>Zhi Zhang. A fast method to compute surface potentials generated by dipoles within multilayer anisotropic spheres. <em>Physics in Medicine and Biology</em>, 40(3):335–349, 1995. <a class="reference external" href="https://doi.org/10.1088/0031-9155/40/3/001">doi:10.1088/0031-9155/40/3/001</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-bergscherg1994" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">7</a><span class="fn-bracket">]</span></span>
<p>Patrick Berg and Michael Scherg. A fast method for forward computation of multiple-shell spherical head models. <em>Electroencephalography and Clinical Neurophysiology</em>, 90(1):58–64, 1994. <a class="reference external" href="https://doi.org/10.1016/0013-4694(94)90113-9">doi:10.1016/0013-4694(94)90113-9</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-daleetal1999" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">8</a><span class="fn-bracket">]</span></span>
<p>Anders M. Dale, Bruce Fischl, and Martin I. Sereno. Cortical surface-based analysis: I. segmentation and surface reconstruction. <em>NeuroImage</em>, 9(2):179–194, 1999. <a class="reference external" href="https://doi.org/10.1006/nimg.1998.0395">doi:10.1006/nimg.1998.0395</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-pascual-marqui2002" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">9</a><span class="fn-bracket">]</span></span>
<p>Roberto D. Pascual-Marqui. Standardized low-resolution brain electromagnetic tomography (sLORETA): technical details. <em>Methods and Findings in Experimental and Clinical Pharmacology</em>, 24(D):5–12, 2002. URL: <a class="reference external" href="https://pubmed.ncbi.nlm.nih.gov/12575463/">https://pubmed.ncbi.nlm.nih.gov/12575463/</a>.</p>
</aside>
<aside class="footnote brackets" id="footcite-pascual-marqui2011" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id16">1</a>,<a role="doc-backlink" href="#id17">2</a>)</span>
<p>Roberto D. Pascual-Marqui, Dietrich Lehmann, Martha Koukkou, Kieko Kochi, Peter Anderer, Bernd Saletu, Hideaki Tanaka, Koichi Hirata, E. Roy John, Leslie Prichep, Rolando Biscay-Lirio, and Toshihiko Kinoshita. Assessing interactions in the brain with exact low-resolution electromagnetic tomography. <em>Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences</em>, 369(1952):3768–3784, 2011. <a class="reference external" href="https://doi.org/10.1098/rsta.2011.0081">doi:10.1098/rsta.2011.0081</a>.</p>
</aside>
</aside>
</div>
</section>
</section>


  
</div>

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="glossary.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Glossary</p>
      </div>
    </a>
    <a class="right-next"
       href="design_philosophy.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Design philosophy</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#internal-representation-units">Internal representation (units)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#floating-point-precision">Floating-point precision</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#supported-channel-types">Supported channel types</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#supported-data-formats">Supported data formats</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#supported-formats-for-digitized-3d-locations">Supported formats for digitized 3D locations</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#memory-efficient-i-o">Memory-efficient I/O</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#preloading-continuous-raw-data">Preloading continuous (raw) data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#preloading-epoched-data">Preloading epoched data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#loading-data-explicitly">Loading data explicitly</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#accessing-data-as-numpy-arrays">Accessing data as NumPy arrays</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bad-channel-repair-via-interpolation">Bad channel repair via interpolation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#maxwell-filtering">Maxwell filtering</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#signal-space-projection-ssp">Signal-Space Projection (SSP)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#general-concepts">General concepts</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#estimation-of-the-noise-subspace">Estimation of the noise subspace</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#eeg-average-electrode-reference">EEG average electrode reference</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-boundary-element-model-bem">The Boundary Element Model (BEM)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#using-the-watershed-algorithm">Using the watershed algorithm</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#using-flash-images">Using FLASH images</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#organizing-mri-data-into-directories">Organizing MRI data into directories</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-the-surface-tessellations">Creating the surface tessellations</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#inspecting-the-meshes">Inspecting the meshes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-forward-solution">The forward solution</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#meg-eeg-and-mri-coordinate-systems">MEG/EEG and MRI coordinate systems</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-head-and-device-coordinate-systems">The head and device coordinate systems</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-surface-based-source-space">Creating a surface-based source space</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-volumetric-or-discrete-source-space">Creating a volumetric or discrete source space</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-the-bem-meshes">Creating the BEM meshes</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#topology-checks">Topology checks</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#computing-the-bem-geometry-data">Computing the BEM geometry data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#coil-geometry-information">Coil geometry information</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#the-sensor-coordinate-system">The sensor coordinate system</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#calculation-of-the-magnetic-field">Calculation of the magnetic field</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#implemented-coil-geometries">Implemented coil geometries</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#the-coil-definition-file">The coil definition file</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#computing-the-forward-solution">Computing the forward solution</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#purpose">Purpose</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#implementation-of-software-gradient-compensation">Implementation of software gradient compensation</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#the-eeg-sphere-model-definition-file">The EEG sphere model definition file</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#eeg-forward-solution-in-the-sphere-model">EEG forward solution in the sphere model</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#averaging-forward-solutions">Averaging forward solutions</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-minimum-norm-current-estimates">The minimum-norm current estimates</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-linear-inverse-operator">The linear inverse operator</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#regularization">Regularization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#whitening-and-scaling">Whitening and scaling</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#regularization-of-the-noise-covariance-matrix">Regularization of the noise-covariance matrix</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#computation-of-the-solution">Computation of the solution</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#noise-normalization">Noise normalization</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dspm">dSPM</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#sloreta">sLORETA</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#eloreta">eLORETA</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#predicted-data">Predicted data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cortical-patch-statistics">Cortical patch statistics</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#orientation-constraints">Orientation constraints</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#depth-weighting">Depth weighting</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#effective-number-of-averages">Effective number of averages</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#morphing-and-averaging-source-estimates">Morphing and averaging source estimates</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#why-morphing">Why morphing?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-morphing-maps">The morphing maps</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#about-smoothing">About smoothing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references">References</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
    
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

    <script src="https://mne.tools/versionwarning.js"></script>
  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item"><p class="text-center small">&copy; Copyright 2012–2024, MNE Developers. Last updated <time datetime="2024-10-24T17:17:05.546129+00:00" class="localized">2024-10-24 17:17 UTC</time>
<script type="text/javascript">$(function () { $("time.localized").each(function () { var el = $(this); el.text(new Date(el.attr("datetime")).toLocaleString([], {dateStyle: "medium", timeStyle: "long"})); }); } )</script></p></div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.0.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>