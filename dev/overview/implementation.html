<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Algorithms and other implementation details &#8212; MNE 0.23.dev0 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap_divs.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-rendered-html.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/bootstrap_divs.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />

    <link rel="canonical" href="https://mne.tools/stable/index.html" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>


    <link rel="stylesheet" href="../_static/style.css " type="text/css" />
    <link rel="stylesheet" href="../_static/font-awesome.css" type="text/css" />
    <link rel="stylesheet" href="../_static/font-source-code-pro.css" type="text/css" />
    <link rel="stylesheet" href="../_static/font-source-sans-pro.css" type="text/css" />
    <link rel="stylesheet" href="../_static/flag-icon.css" type="text/css" />


    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>



<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.12.4.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.4.1/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>



  </head><body>

<div class="d-block devbar alert alert-danger">
This is documentation for the <em>unstable development version</em> of MNE-Python,
<a href="https://mne.tools/dev/install/advanced.html#using-the-development-version-of-mne-python-latest-master">available here</a>.
Or, switch to documentation for the <a href="https://mne.tools/stable">current stable version</a>.

</div>





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/mne_logo_small.svg"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.23.dev0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../install/index.html">Install</a></li>
                <li><a href="index.html">Overview</a></li>
                <li><a href="../auto_tutorials/index.html">Tutorials</a></li>
                <li><a href="../auto_examples/index.html">Examples</a></li>
                <li><a href="../glossary.html">Glossary</a></li>
                <li><a href="../python_reference.html">API</a></li>
            
            
            <li class="dropdown globaltoc-container">
              <a role="button" id="dLabelGlobalToc" data-toggle="dropdown" data-target="#" href="#">More<b class="caret"></b></a>
              <ul class="dropdown-menu globaltoc" role="menu" aria-labelledby="dLabelGlobalToc">
                <li><a href="https://github.com/mne-tools/mne-python"><i class="fa fa-github"></i> GitHub</a></li>
                <li><a href="get_help.html"><i class="fa fa-question-circle"></i> Get help</a></li>
                <li><a href="../install/contributing.html"><i class="fa fa-code-fork"></i> Contribute</a></li>
                <li><a href="cite.html"><i class="fa fa-book"></i> Cite MNE</a></li>
              </ul>
            </li>

            <li class="dropdown">
              <button type="button" class="btn btn-danger btn-sm navbar-btn dropdown-toggle" id="dLabelMore" data-toggle="dropdown" style="margin-left: 10px">
              v0.23.dev0
              <span class="caret"></span>
            </button>
              <ul class="dropdown-menu" aria-labelledby="dLabelMore">
                <li><a href="https://mne-tools.github.io/dev/index.html">Development</a></li>
                <li><a href="https://mne-tools.github.io/stable/index.html">v0.22 (stable)</a></li>
                <li><a href="https://mne-tools.github.io/0.21/index.html">v0.21</a></li>
                <li><a href="https://mne-tools.github.io/0.20/index.html">v0.20</a></li>
                <li><a href="https://mne-tools.github.io/0.19/index.html">v0.19</a></li>
                <li><a href="https://mne-tools.github.io/0.18/index.html">v0.18</a></li>
                <li><a href="https://mne-tools.github.io/0.17/index.html">v0.17</a></li>
                <li><a href="https://mne-tools.github.io/0.16/index.html">v0.16</a></li>
                <li><a href="https://mne-tools.github.io/0.15/index.html">v0.15</a></li>
                <li><a href="https://mne-tools.github.io/0.14/index.html">v0.14</a></li>
                <li><a href="https://mne-tools.github.io/0.13/index.html">v0.13</a></li>
                <li><a href="https://mne-tools.github.io/0.12/index.html">v0.12</a></li>
                <li><a href="https://mne-tools.github.io/0.11/index.html">v0.11</a></li>
              </ul>
            </li>

            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="algorithms-and-other-implementation-details">
<span id="implementation"></span><h1>Algorithms and other implementation details<a class="headerlink" href="#algorithms-and-other-implementation-details" title="Permalink to this headline">¶</a></h1>
<p>This page describes some of the technical details of MNE-Python implementation.</p>
<div class="contents local topic" id="page-contents">
<p class="topic-title">Page contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#internal-representation-units" id="id20">Internal representation (units)</a></p></li>
<li><p><a class="reference internal" href="#floating-point-precision" id="id21">Floating-point precision</a></p></li>
<li><p><a class="reference internal" href="#supported-channel-types" id="id22">Supported channel types</a></p></li>
<li><p><a class="reference internal" href="#supported-data-formats" id="id23">Supported data formats</a></p></li>
<li><p><a class="reference internal" href="#supported-formats-for-digitized-3d-locations" id="id24">Supported formats for digitized 3D locations</a></p></li>
<li><p><a class="reference internal" href="#memory-efficient-i-o" id="id25">Memory-efficient I/O</a></p></li>
<li><p><a class="reference internal" href="#bad-channel-repair-via-interpolation" id="id26">Bad channel repair via interpolation</a></p></li>
<li><p><a class="reference internal" href="#maxwell-filtering" id="id27">Maxwell filtering</a></p></li>
<li><p><a class="reference internal" href="#signal-space-projection-ssp" id="id28">Signal-Space Projection (SSP)</a></p></li>
<li><p><a class="reference internal" href="#the-boundary-element-model-bem" id="id29">The Boundary Element Model (BEM)</a></p></li>
<li><p><a class="reference internal" href="#the-forward-solution" id="id30">The forward solution</a></p></li>
<li><p><a class="reference internal" href="#the-minimum-norm-current-estimates" id="id31">The minimum-norm current estimates</a></p></li>
<li><p><a class="reference internal" href="#morphing-and-averaging-source-estimates" id="id32">Morphing and averaging source estimates</a></p></li>
<li><p><a class="reference internal" href="#references" id="id33">References</a></p></li>
</ul>
</div>
<div class="section" id="internal-representation-units">
<span id="units"></span><h2><a class="toc-backref" href="#id20">Internal representation (units)</a><a class="headerlink" href="#internal-representation-units" title="Permalink to this headline">¶</a></h2>
<p>Irrespective of the units used in your manufacturer’s format, when importing
data, MNE-Python will always convert measurements to the same standard units.
Thus the in-memory representation of data are always in:</p>
<ul class="simple">
<li><p>Volts (eeg, eog, seeg, emg, ecg, bio, ecog)</p></li>
<li><p>Teslas (magnetometers)</p></li>
<li><p>Teslas/meter (gradiometers)</p></li>
<li><p>Amperes*meter (dipole fits, minimum-norm estimates, etc.)</p></li>
<li><p>Moles/liter (“molar”; fNIRS data: oxyhemoglobin (hbo), deoxyhemoglobin (hbr))</p></li>
<li><p>Arbitrary units (various derived unitless quantities)</p></li>
</ul>
<p>Note, however, that most MNE-Python plotting functions will scale the data when
plotted to yield nice-looking axis annotations in a sensible range; for
example, <a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw.plot_psd" title="mne.io.Raw.plot_psd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mne.io.Raw.plot_psd()</span></code></a> will convert teslas to femtoteslas (fT)
and volts to microvolts (µV) when plotting MEG and EEG data.</p>
<p>The units used in internal data representation are particularly important to
remember when extracting data from MNE-Python objects and manipulating it
outside MNE-Python (e.g., when using methods like <a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw.get_data" title="mne.io.Raw.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_data()</span></code></a>
or <a class="reference internal" href="../generated/mne.Epochs.html#mne.Epochs.to_data_frame" title="mne.Epochs.to_data_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_data_frame()</span></code></a> to convert data to <a class="reference external" href="https://numpy.org/devdocs/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.21.dev0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">NumPy</span> <span class="pre">arrays</span></code></a> or <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame" title="(in pandas v1.2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pandas</span> <span class="pre">DataFrames</span></code></a> for analysis
or plotting with other Python modules).</p>
</div>
<div class="section" id="floating-point-precision">
<span id="precision"></span><h2><a class="toc-backref" href="#id21">Floating-point precision</a><a class="headerlink" href="#floating-point-precision" title="Permalink to this headline">¶</a></h2>
<p>MNE-Python performs all computation in memory using the double-precision 64-bit
floating point format. This means that the data is typecast into float64 format
as soon as it is read into memory. The reason for this is that operations such
as filtering and preprocessing are more accurate when using the 64-bit format.
However, for backward compatibility, MNE-Python writes <code class="file docutils literal notranslate"><span class="pre">.fif</span></code> files in a
32-bit format by default. This reduces file size when saving data to disk, but
beware that <em>saving intermediate results to disk and re-loading them from disk
later may lead to loss in precision</em>. If you would like to ensure 64-bit
precision, there are two possibilities:</p>
<ul class="simple">
<li><p>Chain the operations in memory and avoid saving intermediate results.</p></li>
<li><p>Save intermediate results but change the <a class="reference external" href="https://numpy.org/devdocs/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v1.21.dev0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dtype</span></code></a> used for
saving, by using the <code class="docutils literal notranslate"><span class="pre">fmt</span></code> parameter of <a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw.save" title="mne.io.Raw.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mne.io.Raw.save()</span></code></a> (or
<a class="reference internal" href="../generated/mne.Epochs.html#mne.Epochs.save" title="mne.Epochs.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mne.Epochs.save()</span></code></a>, etc). However, note that this may render the
<code class="file docutils literal notranslate"><span class="pre">.fif</span></code> files unreadable in software packages other than MNE-Python.</p></li>
</ul>
</div>
<div class="section" id="supported-channel-types">
<span id="channel-types"></span><h2><a class="toc-backref" href="#id22">Supported channel types</a><a class="headerlink" href="#supported-channel-types" title="Permalink to this headline">¶</a></h2>
<p>Channel types are represented in MNE-Python with shortened or abbreviated
names. This page lists all supported channel types, their abbreviated names,
and the measurement unit used to represent data of that type. Where channel
types occur in two or more sub-types, the sub-type abbreviations are given in
parentheses. More information about measurement units is given in the
<a class="reference internal" href="#units"><span class="std std-ref">Internal representation (units)</span></a> section.</p>
<table class="table-bordered midvalign docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 58%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Channel type</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Measurement unit</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>eeg</p></td>
<td><p>scalp electroencephalography (EEG)</p></td>
<td><p>Volts</p></td>
</tr>
<tr class="row-odd"><td><p>meg (mag)</p></td>
<td><p>Magnetoencephalography (magnetometers)</p></td>
<td><p>Teslas</p></td>
</tr>
<tr class="row-even"><td><p>meg (grad)</p></td>
<td><p>Magnetoencephalography (gradiometers)</p></td>
<td><p>Teslas/meter</p></td>
</tr>
<tr class="row-odd"><td><p>ecg</p></td>
<td><p>Electrocardiography (ECG)</p></td>
<td><p>Volts</p></td>
</tr>
<tr class="row-even"><td><p>seeg</p></td>
<td><p>Stereotactic EEG channels</p></td>
<td><p>Volts</p></td>
</tr>
<tr class="row-odd"><td><p>ecog</p></td>
<td><p>Electrocorticography (ECoG)</p></td>
<td><p>Volts</p></td>
</tr>
<tr class="row-even"><td><p>fnirs (hbo)</p></td>
<td><p>Functional near-infrared spectroscopy
(oxyhemoglobin)</p></td>
<td><p>Moles/liter</p></td>
</tr>
<tr class="row-odd"><td><p>fnirs (hbr)</p></td>
<td><p>Functional near-infrared spectroscopy
(deoxyhemoglobin)</p></td>
<td><p>Moles/liter</p></td>
</tr>
<tr class="row-even"><td><p>emg</p></td>
<td><p>Electromyography (EMG)</p></td>
<td><p>Volts</p></td>
</tr>
<tr class="row-odd"><td><p>bio</p></td>
<td><p>Miscellaneous biological channels (e.g.,
skin conductance)</p></td>
<td><p>Arbitrary units</p></td>
</tr>
<tr class="row-even"><td><p>stim</p></td>
<td><p>stimulus (a.k.a. trigger) channels</p></td>
<td><p>Arbitrary units</p></td>
</tr>
<tr class="row-odd"><td><p>resp</p></td>
<td><p>response-trigger channel</p></td>
<td><p>Arbitrary units</p></td>
</tr>
<tr class="row-even"><td><p>chpi</p></td>
<td><p>continuous head position indicator
(HPI) coil channels</p></td>
<td><p>Teslas</p></td>
</tr>
<tr class="row-odd"><td><p>exci</p></td>
<td><p>Flux excitation channel</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ias</p></td>
<td><p>Internal Active Shielding data
(Triux systems only?)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>syst</p></td>
<td><p>System status channel information
(Triux systems only)</p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="supported-data-formats">
<span id="data-formats"></span><h2><a class="toc-backref" href="#id23">Supported data formats</a><a class="headerlink" href="#supported-data-formats" title="Permalink to this headline">¶</a></h2>
<p>When MNE-Python loads sensor data, the data are stored in a Python object of
type <a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw" title="mne.io.Raw"><code class="xref py py-class docutils literal notranslate"><span class="pre">mne.io.Raw</span></code></a>. Specialized loading functions are provided for the
raw data file formats from a variety of equipment manufacturers. All raw data
input/output functions in MNE-Python are found in <a class="reference internal" href="../python_reference.html#module-mne.io" title="mne.io"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mne.io</span></code></a> and start
with <code class="samp docutils literal notranslate"><span class="pre">read_raw_</span><em><span class="pre">*</span></em></code>; see the documentation for each reader function for
more info on reading specific file types.</p>
<p>As seen in the table below, there are also a few formats defined by other
neuroimaging analysis software packages that are supported (EEGLAB,
FieldTrip). Like the equipment-specific loading functions, these will also
return an object of class <a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw" title="mne.io.Raw"><code class="xref py py-class docutils literal notranslate"><span class="pre">Raw</span></code></a>; additional functions are
available for reading data that has already been epoched or averaged (see
table).</p>
<table class="table-bordered midvalign docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 44%" />
<col style="width: 9%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Data type</p></th>
<th class="head"><p>File format</p></th>
<th class="head"><p>Extension</p></th>
<th class="head"><p>MNE-Python function</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>MEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_10_reading_meg_data.html#import-artemis"><span class="std std-ref">Artemis123</span></a></p></td>
<td><p>.bin</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_artemis123.html#mne.io.read_raw_artemis123" title="mne.io.read_raw_artemis123"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_artemis123()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>MEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_10_reading_meg_data.html#import-bti"><span class="std std-ref">4-D Neuroimaging / BTi</span></a></p></td>
<td><p>&lt;dir&gt;</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_bti.html#mne.io.read_raw_bti" title="mne.io.read_raw_bti"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_bti()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>MEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_10_reading_meg_data.html#import-ctf"><span class="std std-ref">CTF</span></a></p></td>
<td><p>&lt;dir&gt;</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_ctf.html#mne.io.read_raw_ctf" title="mne.io.read_raw_ctf"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_ctf()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>MEG and EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_10_reading_meg_data.html#import-neuromag"><span class="std std-ref">Elekta Neuromag</span></a></p></td>
<td><p>.fif</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_fif.html#mne.io.read_raw_fif" title="mne.io.read_raw_fif"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_fif()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>MEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_10_reading_meg_data.html#import-kit"><span class="std std-ref">KIT</span></a></p></td>
<td><p>.sqd</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_kit.html#mne.io.read_raw_kit" title="mne.io.read_raw_kit"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_kit()</span></code></a>,
<a class="reference internal" href="../generated/mne.read_epochs_kit.html#mne.read_epochs_kit" title="mne.read_epochs_kit"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.read_epochs_kit()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>MEG and EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_10_reading_meg_data.html#import-fieldtrip"><span class="std std-ref">FieldTrip</span></a></p></td>
<td><p>.mat</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_fieldtrip.html#mne.io.read_raw_fieldtrip" title="mne.io.read_raw_fieldtrip"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_fieldtrip()</span></code></a>,
<a class="reference internal" href="../generated/mne.read_epochs_fieldtrip.html#mne.read_epochs_fieldtrip" title="mne.read_epochs_fieldtrip"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.read_epochs_fieldtrip()</span></code></a>,
<a class="reference internal" href="../generated/mne.read_evoked_fieldtrip.html#mne.read_evoked_fieldtrip" title="mne.read_evoked_fieldtrip"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.read_evoked_fieldtrip()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_20_reading_eeg_data.html#import-bv"><span class="std std-ref">Brainvision</span></a></p></td>
<td><p>.vhdr</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_brainvision.html#mne.io.read_raw_brainvision" title="mne.io.read_raw_brainvision"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_brainvision()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_20_reading_eeg_data.html#import-biosemi"><span class="std std-ref">Biosemi data format</span></a></p></td>
<td><p>.bdf</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_bdf.html#mne.io.read_raw_bdf" title="mne.io.read_raw_bdf"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_bdf()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_20_reading_eeg_data.html#import-cnt"><span class="std std-ref">Neuroscan CNT</span></a></p></td>
<td><p>.cnt</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_cnt.html#mne.io.read_raw_cnt" title="mne.io.read_raw_cnt"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_cnt()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_20_reading_eeg_data.html#import-edf"><span class="std std-ref">European data format</span></a></p></td>
<td><p>.edf</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_edf.html#mne.io.read_raw_edf" title="mne.io.read_raw_edf"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_edf()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_20_reading_eeg_data.html#import-set"><span class="std std-ref">EEGLAB</span></a></p></td>
<td><p>.set</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_eeglab.html#mne.io.read_raw_eeglab" title="mne.io.read_raw_eeglab"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_eeglab()</span></code></a>,
<a class="reference internal" href="../generated/mne.read_epochs_eeglab.html#mne.read_epochs_eeglab" title="mne.read_epochs_eeglab"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.read_epochs_eeglab()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_20_reading_eeg_data.html#import-egi"><span class="std std-ref">EGI simple binary</span></a></p></td>
<td><p>.egi</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_egi.html#mne.io.read_raw_egi" title="mne.io.read_raw_egi"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_egi()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_20_reading_eeg_data.html#import-mff"><span class="std std-ref">EGI MFF format</span></a></p></td>
<td><p>.mff</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_egi.html#mne.io.read_raw_egi" title="mne.io.read_raw_egi"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_egi()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_20_reading_eeg_data.html#import-nxe"><span class="std std-ref">eXimia</span></a></p></td>
<td><p>.nxe</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_eximia.html#mne.io.read_raw_eximia" title="mne.io.read_raw_eximia"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_eximia()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_20_reading_eeg_data.html#import-gdf"><span class="std std-ref">General data format</span></a></p></td>
<td><p>.gdf</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_gdf.html#mne.io.read_raw_gdf" title="mne.io.read_raw_gdf"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_gdf()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_20_reading_eeg_data.html#import-nicolet"><span class="std std-ref">Nicolet</span></a></p></td>
<td><p>.data</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_nicolet.html#mne.io.read_raw_nicolet" title="mne.io.read_raw_nicolet"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_nicolet()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>EEG</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_20_reading_eeg_data.html#import-persyst"><span class="std std-ref">Persyst</span></a></p></td>
<td><p>.lay</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_persyst.html#mne.io.read_raw_persyst" title="mne.io.read_raw_persyst"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_persyst()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>NIRS</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_30_reading_fnirs_data.html#import-nirx"><span class="std std-ref">NIRx</span></a></p></td>
<td><p>directory</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_nirx.html#mne.io.read_raw_nirx" title="mne.io.read_raw_nirx"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_nirx()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>NIRS</p></td>
<td><p><a class="reference internal" href="../auto_tutorials/io/plot_30_reading_fnirs_data.html#import-boxy"><span class="std std-ref">BOXY</span></a></p></td>
<td><p>directory</p></td>
<td><p><a class="reference internal" href="../generated/mne.io.read_raw_boxy.html#mne.io.read_raw_boxy" title="mne.io.read_raw_boxy"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.read_raw_boxy()</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>More details are provided in the tutorials in the <a class="reference internal" href="../auto_tutorials/index.html#tut-data-formats"><span class="std std-ref">Reading data for different recording systems</span></a>
section.</p>
</div>
<div class="section" id="supported-formats-for-digitized-3d-locations">
<span id="dig-formats"></span><h2><a class="toc-backref" href="#id24">Supported formats for digitized 3D locations</a><a class="headerlink" href="#supported-formats-for-digitized-3d-locations" title="Permalink to this headline">¶</a></h2>
<p>MNE-Python can load 3D point locations obtained by digitization systems.
Such files allow to obtain a <a class="reference internal" href="../generated/mne.channels.DigMontage.html#mne.channels.DigMontage" title="mne.channels.DigMontage"><code class="xref py py-class docutils literal notranslate"><span class="pre">montage</span></code></a>
that can then be added to <a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw" title="mne.io.Raw"><code class="xref py py-class docutils literal notranslate"><span class="pre">Raw</span></code></a> objects with the
<a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw.set_montage" title="mne.io.Raw.set_montage"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_montage()</span></code></a>. See the documentation for each reader
function for more info on reading specific file types.</p>
<table class="table-bordered midvalign docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 20%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Vendor</p></th>
<th class="head"><p>Extension(s)</p></th>
<th class="head"><p>MNE-Python function</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Neuromag</p></td>
<td><p>.fif</p></td>
<td><p><a class="reference internal" href="../generated/mne.channels.read_dig_fif.html#mne.channels.read_dig_fif" title="mne.channels.read_dig_fif"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.read_dig_fif()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>Polhemus ISOTRAK</p></td>
<td><p>.hsp, .elp, .eeg</p></td>
<td><p><a class="reference internal" href="../generated/mne.channels.read_dig_polhemus_isotrak.html#mne.channels.read_dig_polhemus_isotrak" title="mne.channels.read_dig_polhemus_isotrak"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.read_dig_polhemus_isotrak()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>EGI</p></td>
<td><p>.xml</p></td>
<td><p><a class="reference internal" href="../generated/mne.channels.read_dig_egi.html#mne.channels.read_dig_egi" title="mne.channels.read_dig_egi"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.read_dig_egi()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>MNE-C</p></td>
<td><p>.hpts</p></td>
<td><p><a class="reference internal" href="../generated/mne.channels.read_dig_hpts.html#mne.channels.read_dig_hpts" title="mne.channels.read_dig_hpts"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.read_dig_hpts()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>Brain Products</p></td>
<td><p>.bvct</p></td>
<td><p><a class="reference internal" href="../generated/mne.channels.read_dig_captrak.html#mne.channels.read_dig_captrak" title="mne.channels.read_dig_captrak"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.read_dig_captrak()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>Compumedics</p></td>
<td><p>.dat</p></td>
<td><p><a class="reference internal" href="../generated/mne.channels.read_dig_dat.html#mne.channels.read_dig_dat" title="mne.channels.read_dig_dat"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.read_dig_dat()</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>To load Polhemus FastSCAN files you can use
<a class="reference internal" href="../generated/mne.channels.read_polhemus_fastscan.html#mne.channels.read_polhemus_fastscan" title="mne.channels.read_polhemus_fastscan"><code class="xref py py-func docutils literal notranslate"><span class="pre">montage</span></code></a>.</p>
<p>It is also possible to make a <a class="reference internal" href="../generated/mne.channels.DigMontage.html#mne.channels.DigMontage" title="mne.channels.DigMontage"><code class="xref py py-class docutils literal notranslate"><span class="pre">montage</span></code></a>
from arrays with <a class="reference internal" href="../generated/mne.channels.make_dig_montage.html#mne.channels.make_dig_montage" title="mne.channels.make_dig_montage"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.channels.make_dig_montage()</span></code></a>.</p>
</div>
<div class="section" id="memory-efficient-i-o">
<span id="memory"></span><h2><a class="toc-backref" href="#id25">Memory-efficient I/O</a><a class="headerlink" href="#memory-efficient-i-o" title="Permalink to this headline">¶</a></h2>
<div class="section" id="preloading-continuous-raw-data">
<h3>Preloading continuous (raw) data<a class="headerlink" href="#preloading-continuous-raw-data" title="Permalink to this headline">¶</a></h3>
<p>MNE-Python can read data on-demand using the <code class="docutils literal notranslate"><span class="pre">preload</span></code> option provided in
raw reading functions. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mne</span> <span class="kn">import</span> <span class="n">io</span>
<span class="kn">from</span> <span class="nn">mne.datasets</span> <span class="kn">import</span> <span class="n">sample</span>
<span class="n">data_path</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">data_path</span><span class="p">()</span>
<span class="n">raw_fname</span> <span class="o">=</span> <span class="n">data_path</span> <span class="o">+</span> <span class="s1">&#39;/MEG/sample/sample_audvis_filt-0-40_raw.fif&#39;</span>
<span class="n">raw</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">read_raw_fif</span><span class="p">(</span><span class="n">raw_fname</span><span class="p">,</span> <span class="n">preload</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Filtering, resampling and dropping or selecting channels does not
work with <code class="docutils literal notranslate"><span class="pre">preload=False</span></code>.</p>
</div>
</div>
<div class="section" id="preloading-epoched-data">
<h3>Preloading epoched data<a class="headerlink" href="#preloading-epoched-data" title="Permalink to this headline">¶</a></h3>
<p>Similarly, epochs can also be be read from disk on-demand. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mne</span>
<span class="n">events</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">find_events</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>
<span class="n">event_id</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span>
<span class="n">picks</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">pick_types</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">meg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">eeg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">epochs</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">Epochs</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="n">picks</span><span class="p">,</span>
                    <span class="n">baseline</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">reject</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">eeg</span><span class="o">=</span><span class="mf">80e-6</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="mf">150e-6</span><span class="p">),</span>
                    <span class="n">preload</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">preload=False</span></code>, the epochs data is loaded from the disk on-demand. Note
that <code class="docutils literal notranslate"><span class="pre">preload=False</span></code> for epochs will work even if the <code class="docutils literal notranslate"><span class="pre">raw</span></code> object has been
loaded with <code class="docutils literal notranslate"><span class="pre">preload=True</span></code>. Preloading is also supported for
<a class="reference internal" href="../generated/mne.read_epochs.html#mne.read_epochs" title="mne.read_epochs"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.read_epochs()</span></code></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This comes with a caveat. When <code class="docutils literal notranslate"><span class="pre">preload=False</span></code>, data rejection
based on peak-to-peak thresholds is executed when the data is
loaded from disk, <em>not</em> when the <code class="docutils literal notranslate"><span class="pre">Epochs</span></code> object is created.</p>
</div>
<p>To explicitly reject artifacts with <code class="docutils literal notranslate"><span class="pre">preload=False</span></code>, use the function <a class="reference internal" href="../generated/mne.Epochs.html#mne.Epochs.drop_bad" title="mne.Epochs.drop_bad"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.Epochs.drop_bad()</span></code></a>.</p>
</div>
<div class="section" id="loading-data-explicitly">
<h3>Loading data explicitly<a class="headerlink" href="#loading-data-explicitly" title="Permalink to this headline">¶</a></h3>
<p>To load the data if <code class="docutils literal notranslate"><span class="pre">preload=False</span></code> was initially selected, use the functions <a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw.load_data" title="mne.io.Raw.load_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.io.Raw.load_data()</span></code></a> and <a class="reference internal" href="../generated/mne.Epochs.html#mne.Epochs.load_data" title="mne.Epochs.load_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.Epochs.load_data()</span></code></a>.</p>
</div>
<div class="section" id="accessing-data-as-numpy-arrays">
<h3>Accessing data as NumPy arrays<a class="headerlink" href="#accessing-data-as-numpy-arrays" title="Permalink to this headline">¶</a></h3>
<p>If you just want your raw data as a <a class="reference external" href="https://numpy.org/devdocs/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.21.dev0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Numpy</span> <span class="pre">array</span></code></a> to
work with it in a different framework you can use slicing syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">first_channel_data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
<span class="n">channels_3_and_4</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="p">:]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="bad-channel-repair-via-interpolation">
<span id="channel-interpolation"></span><h2><a class="toc-backref" href="#id26">Bad channel repair via interpolation</a><a class="headerlink" href="#bad-channel-repair-via-interpolation" title="Permalink to this headline">¶</a></h2>
<p>In short, data repair using spherical spline interpolation <a class="footnote-reference brackets" href="#perrinetal1989" id="id1">5</a> consists of the following steps:</p>
<ul class="simple">
<li><p>Project the good and bad electrodes onto a unit sphere</p></li>
<li><p>Compute a mapping matrix that maps <span class="math notranslate nohighlight">\(N\)</span> good channels to <span class="math notranslate nohighlight">\(M\)</span> bad channels</p></li>
<li><p>Use this mapping matrix to compute interpolated data in the bad channels</p></li>
</ul>
<p>Spherical splines assume that the potential <span class="math notranslate nohighlight">\(V(\boldsymbol{r_i})\)</span> at any point <span class="math notranslate nohighlight">\(\boldsymbol{r_i}\)</span> on the surface of the sphere can be represented by:</p>
<div class="math notranslate nohighlight" id="equation-model">
<span class="eqno">(1)<a class="headerlink" href="#equation-model" title="Permalink to this equation">¶</a></span>\[V(\boldsymbol{r_i}) = c_0 + \sum_{j=1}^{N}c_{i}g_{m}(cos(\boldsymbol{r_i}, \boldsymbol{r_{j}}))\]</div>
<p>where the <span class="math notranslate nohighlight">\(C = (c_{1}, ..., c_{N})^{T}\)</span> are constants which must be estimated. The function <span class="math notranslate nohighlight">\(g_{m}(\cdot)\)</span> of order <span class="math notranslate nohighlight">\(m\)</span> is given by:</p>
<div class="math notranslate nohighlight" id="equation-legendre">
<span class="eqno">(2)<a class="headerlink" href="#equation-legendre" title="Permalink to this equation">¶</a></span>\[g_{m}(x) = \frac{1}{4 \pi}\sum_{n=1}^{\infty} \frac{2n + 1}{(n(n + 1))^m}P_{n}(x)\]</div>
<p>where <span class="math notranslate nohighlight">\(P_{n}(x)\)</span> are <a class="reference external" href="https://en.wikipedia.org/wiki/Legendre_polynomials">Legendre polynomials</a> of order <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>To estimate the constants <span class="math notranslate nohighlight">\(C\)</span>, we must solve the following two equations simultaneously:</p>
<div class="math notranslate nohighlight" id="equation-matrix-form">
<span class="eqno">(3)<a class="headerlink" href="#equation-matrix-form" title="Permalink to this equation">¶</a></span>\[G_{ss}C + T_{s}c_0 = X\]</div>
<div class="math notranslate nohighlight" id="equation-constraint">
<span class="eqno">(4)<a class="headerlink" href="#equation-constraint" title="Permalink to this equation">¶</a></span>\[{T_s}^{T}C = 0\]</div>
<p>where <span class="math notranslate nohighlight">\(G_{ss} \in R^{N \times N}\)</span> is a matrix whose entries are <span class="math notranslate nohighlight">\(G_{ss}[i, j] = g_{m}(cos(\boldsymbol{r_i}, \boldsymbol{r_j}))\)</span> and <span class="math notranslate nohighlight">\(X \in R^{N \times 1}\)</span> are the potentials <span class="math notranslate nohighlight">\(V(\boldsymbol{r_i})\)</span> measured at the good channels. <span class="math notranslate nohighlight">\(T_{s} = (1, 1, ..., 1)^\top\)</span> is a column vector of dimension <span class="math notranslate nohighlight">\(N\)</span>. Equation <a class="reference internal" href="#equation-matrix-form">(3)</a> is the matrix formulation of Equation <a class="reference internal" href="#equation-model">(1)</a> and equation <a class="reference internal" href="#equation-constraint">(4)</a> is like applying an average reference to the data. From equation <a class="reference internal" href="#equation-matrix-form">(3)</a> and <a class="reference internal" href="#equation-constraint">(4)</a>, we get:</p>
<div class="math notranslate nohighlight" id="equation-estimate-constant">
<span class="eqno">(5)<a class="headerlink" href="#equation-estimate-constant" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{bmatrix} c_0 \\ C \end{bmatrix} = {\begin{bmatrix} {T_s}^{T} &amp;&amp; 0 \\ T_s &amp;&amp; G_{ss} \end{bmatrix}}^{-1} \begin{bmatrix} 0 \\ X \end{bmatrix} = C_{i}X\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(C_{i}\)</span> is the same as matrix <span class="math notranslate nohighlight">\({\begin{bmatrix} {T_s}^{T} &amp;&amp; 0 \\ T_s &amp;&amp; G_{ss} \end{bmatrix}}^{-1}\)</span> but with its first column deleted, therefore giving a matrix of dimension <span class="math notranslate nohighlight">\((N + 1) \times N\)</span>.</p>
<p>Now, to estimate the potentials <span class="math notranslate nohighlight">\(\hat{X} \in R^{M \times 1}\)</span> at the bad channels, we have to do:</p>
<div class="math notranslate nohighlight" id="equation-estimate-data">
<span class="eqno">(6)<a class="headerlink" href="#equation-estimate-data" title="Permalink to this equation">¶</a></span>\[\hat{X} = G_{ds}C + T_{d}c_0\]</div>
<p>where <span class="math notranslate nohighlight">\(G_{ds} \in R^{M \times N}\)</span> computes <span class="math notranslate nohighlight">\(g_{m}(\boldsymbol{r_i}, \boldsymbol{r_j})\)</span> between the bad and good channels. <span class="math notranslate nohighlight">\(T_{d} = (1, 1, ..., 1)^\top\)</span> is a column vector of dimension <span class="math notranslate nohighlight">\(M\)</span>. Plugging in equation <a class="reference internal" href="#equation-estimate-constant">(5)</a> in <a class="reference internal" href="#equation-estimate-data">(6)</a>, we get</p>
<div class="math notranslate nohighlight">
\[\begin{split}\hat{X} = \begin{bmatrix} T_d &amp;&amp; G_{ds} \end{bmatrix} \begin{bmatrix} c_0 \\ C \end{bmatrix} = \underbrace{\begin{bmatrix} T_d &amp;&amp; G_{ds} \end{bmatrix} C_{i}}_\text{mapping matrix}X\end{split}\]</div>
<p>To interpolate bad channels, one can simply do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span><span class="o">.</span><span class="n">interpolate_bads</span><span class="p">(</span><span class="n">reset_bads</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
</pre></div>
</div>
<p>and the bad channel will be fixed.</p>
</div>
<div class="section" id="maxwell-filtering">
<span id="maxwell"></span><h2><a class="toc-backref" href="#id27">Maxwell filtering</a><a class="headerlink" href="#maxwell-filtering" title="Permalink to this headline">¶</a></h2>
<p>MNE-Python’s implementation of Maxwell filtering is described in the
<a class="reference internal" href="../auto_tutorials/preprocessing/plot_60_maxwell_filtering_sss.html#tut-artifact-sss"><span class="std std-ref">Signal-space separation (SSS) and Maxwell filtering</span></a> tutorial.</p>
</div>
<div class="section" id="signal-space-projection-ssp">
<span id="ssp-method"></span><h2><a class="toc-backref" href="#id28">Signal-Space Projection (SSP)</a><a class="headerlink" href="#signal-space-projection-ssp" title="Permalink to this headline">¶</a></h2>
<p>The Signal-Space Projection (SSP) is one approach to rejection of external
disturbances in software. The section presents some relevant details of this
method. For practical examples of how to use SSP for artifact rejection, see
<a class="reference internal" href="../auto_tutorials/preprocessing/plot_50_artifact_correction_ssp.html#tut-artifact-ssp"><span class="std std-ref">Repairing artifacts with SSP</span></a>.</p>
<div class="section" id="general-concepts">
<h3>General concepts<a class="headerlink" href="#general-concepts" title="Permalink to this headline">¶</a></h3>
<p>Unlike many other noise-cancellation approaches, SSP does not require
additional reference sensors to record the disturbance fields. Instead, SSP
relies on the fact that the magnetic field distributions generated by the
sources in the brain have spatial distributions sufficiently different from
those generated by external noise sources. Furthermore, it is implicitly
assumed that the linear space spanned by the significant external noise patters
has a low dimension.</p>
<p>Without loss of generality we can always decompose any <span class="math notranslate nohighlight">\(n\)</span>-channel
measurement <span class="math notranslate nohighlight">\(b(t)\)</span> into its signal and noise components as</p>
<div class="math notranslate nohighlight" id="equation-additive-model">
<span class="eqno">(7)<a class="headerlink" href="#equation-additive-model" title="Permalink to this equation">¶</a></span>\[b(t) = b_s(t) + b_n(t)\]</div>
<p>Further, if we know that <span class="math notranslate nohighlight">\(b_n(t)\)</span> is well characterized by a few field
patterns <span class="math notranslate nohighlight">\(b_1 \dotso b_m\)</span>, we can express the disturbance as</p>
<div class="math notranslate nohighlight" id="equation-pca">
<span class="eqno">(8)<a class="headerlink" href="#equation-pca" title="Permalink to this equation">¶</a></span>\[b_n(t) = Uc_n(t) + e(t)\ ,\]</div>
<p>where the columns of <span class="math notranslate nohighlight">\(U\)</span> constitute an orthonormal basis for <span class="math notranslate nohighlight">\(b_1
\dotso b_m\)</span>, <span class="math notranslate nohighlight">\(c_n(t)\)</span> is an <span class="math notranslate nohighlight">\(m\)</span>-component column vector, and the
error term <span class="math notranslate nohighlight">\(e(t)\)</span> is small and does not exhibit any consistent spatial
distributions over time, <em>i.e.</em>, <span class="math notranslate nohighlight">\(C_e = E \{e e^\top\} = I\)</span>. Subsequently,
we will call the column space of <span class="math notranslate nohighlight">\(U\)</span> the noise subspace. The basic idea
of SSP is that we can actually find a small basis set <span class="math notranslate nohighlight">\(b_1 \dotso b_m\)</span>
such that the conditions described above are satisfied. We can now construct
the orthogonal complement operator</p>
<div class="math notranslate nohighlight" id="equation-projector">
<span class="eqno">(9)<a class="headerlink" href="#equation-projector" title="Permalink to this equation">¶</a></span>\[P_{\perp} = I - UU^\top\]</div>
<p>and apply it to <span class="math notranslate nohighlight">\(b(t)\)</span> in Equation <a class="reference internal" href="#equation-additive-model">(7)</a> yielding</p>
<div class="math notranslate nohighlight" id="equation-result">
<span class="eqno">(10)<a class="headerlink" href="#equation-result" title="Permalink to this equation">¶</a></span>\[b_{s}(t) \approx P_{\perp}b(t)\ ,\]</div>
<p>since <span class="math notranslate nohighlight">\(P_{\perp}b_n(t) = P_{\perp}(Uc_n(t) + e(t)) \approx 0\)</span> and
<span class="math notranslate nohighlight">\(P_{\perp}b_{s}(t) \approx b_{s}(t)\)</span>. The projection operator
<span class="math notranslate nohighlight">\(P_{\perp}\)</span> is called the <strong>signal-space projection operator</strong> and
generally provides considerable rejection of noise, suppressing external
disturbances by a factor of 10 or more. The effectiveness of SSP depends on two
factors:</p>
<ul class="simple">
<li><p>The basis set <span class="math notranslate nohighlight">\(b_1 \dotso b_m\)</span> should be able to characterize the
disturbance field patterns completely and</p></li>
<li><p>The angles between the noise subspace space spanned by <span class="math notranslate nohighlight">\(b_1 \dotso b_m\)</span>
and the signal vectors <span class="math notranslate nohighlight">\(b_s(t)\)</span> should be as close to <span class="math notranslate nohighlight">\(\pi / 2\)</span>
as possible.</p></li>
</ul>
<p>If the first requirement is not satisfied, some noise will leak through because
<span class="math notranslate nohighlight">\(P_{\perp}b_n(t) \neq 0\)</span>. If the any of the brain signal vectors
<span class="math notranslate nohighlight">\(b_s(t)\)</span> is close to the noise subspace not only the noise but also the
signal will be attenuated by the application of <span class="math notranslate nohighlight">\(P_{\perp}\)</span> and,
consequently, there might by little gain in signal-to-noise ratio.</p>
<p>Since the signal-space projection modifies the signal vectors originating in
the brain, it is necessary to apply the projection to the forward solution in
the course of inverse computations.</p>
<p>For more information on SSP, please consult the references listed in
<a class="reference internal" href="../references.html#cegieebb"><span class="std std-ref">Signal-space projections</span></a>.</p>
</div>
<div class="section" id="estimation-of-the-noise-subspace">
<h3>Estimation of the noise subspace<a class="headerlink" href="#estimation-of-the-noise-subspace" title="Permalink to this headline">¶</a></h3>
<p>As described above, application of SSP requires the estimation of the signal
vectors <span class="math notranslate nohighlight">\(b_1 \dotso b_m\)</span> constituting the noise subspace. The most common
approach, also implemented in <a class="reference internal" href="../generated/mne.compute_proj_raw.html#mne.compute_proj_raw" title="mne.compute_proj_raw"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.compute_proj_raw()</span></code></a>
is to compute a covariance matrix
of empty room data, compute its eigenvalue decomposition, and employ the
eigenvectors corresponding to the highest eigenvalues as basis for the noise
subspace. It is also customary to use a separate set of vectors for
magnetometers and gradiometers in the Vectorview system.</p>
</div>
<div class="section" id="eeg-average-electrode-reference">
<h3>EEG average electrode reference<a class="headerlink" href="#eeg-average-electrode-reference" title="Permalink to this headline">¶</a></h3>
<p>The EEG average reference is the mean signal over all the sensors. It is
typical in EEG analysis to subtract the average reference from all the sensor
signals <span class="math notranslate nohighlight">\(b^{1}(t), ..., b^{n}(t)\)</span>. That is:</p>
<div class="math notranslate nohighlight" id="equation-eeg-proj">
<span class="eqno">(11)<a class="headerlink" href="#equation-eeg-proj" title="Permalink to this equation">¶</a></span>\[{b}^{j}_{s}(t) = b^{j}(t) - \frac{1}{n}\sum_{k}{b^k(t)}\]</div>
<p>where the noise term <span class="math notranslate nohighlight">\(b_{n}^{j}(t)\)</span> is given by</p>
<div class="math notranslate nohighlight" id="equation-noise-term">
<span class="eqno">(12)<a class="headerlink" href="#equation-noise-term" title="Permalink to this equation">¶</a></span>\[b_{n}^{j}(t) = \frac{1}{n}\sum_{k}{b^k(t)}\]</div>
<p>Thus, the projector vector <span class="math notranslate nohighlight">\(P_{\perp}\)</span> will be given by
<span class="math notranslate nohighlight">\(P_{\perp}=\frac{1}{n}[1, 1, ..., 1]\)</span></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When applying SSP, the signal of interest can also be sometimes removed.
Therefore, it’s always a good idea to check how much the effect of interest
is reduced by applying SSP. SSP might remove <em>both</em> the artifact and signal
of interest.</p>
</div>
</div>
</div>
<div class="section" id="the-boundary-element-model-bem">
<span id="bem-model"></span><h2><a class="toc-backref" href="#id29">The Boundary Element Model (BEM)</a><a class="headerlink" href="#the-boundary-element-model-bem" title="Permalink to this headline">¶</a></h2>
<div class="section" id="using-the-watershed-algorithm">
<span id="bem-watershed-algorithm"></span><h3>Using the watershed algorithm<a class="headerlink" href="#using-the-watershed-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The watershed algorithm [Segonne <em>et al.</em>,
2004] is part of the FreeSurfer software.
The name of the program is mri_watershed .
Its use in the MNE environment is facilitated by the script
<a class="reference internal" href="../generated/commands.html#mne-watershed-bem"><span class="std std-ref">mne watershed_bem</span></a>.</p>
<p>After <code class="docutils literal notranslate"><span class="pre">mne</span> <span class="pre">watershed_bem</span></code> has completed, the following files appear in the
subject’s <code class="file docutils literal notranslate"><span class="pre">bem/watershed</span></code> directory:</p>
<ul class="simple">
<li><p><code class="file docutils literal notranslate"><em><span class="pre">&lt;subject&gt;</span></em><span class="pre">_brain_surface</span></code> contains the brain surface triangulation.</p></li>
<li><p><code class="file docutils literal notranslate"><em><span class="pre">&lt;subject&gt;</span></em><span class="pre">_inner_skull_surface</span></code> contains the inner skull
triangulation.</p></li>
<li><p><code class="file docutils literal notranslate"><em><span class="pre">&lt;subject&gt;</span></em><span class="pre">_outer_skull_surface</span></code> contains the outer skull
triangulation.</p></li>
<li><p><code class="file docutils literal notranslate"><em><span class="pre">&lt;subject&gt;</span></em><span class="pre">_outer_skin_surface</span></code> contains the scalp triangulation.</p></li>
</ul>
<p>All of these surfaces are in the FreeSurfer format. In addition, there will be
a file called <code class="file docutils literal notranslate"><span class="pre">bem/watershed/ws.mgz</span></code> which contains the brain MRI
volume. Furthermore, <code class="docutils literal notranslate"><span class="pre">mne</span> <span class="pre">watershed_bem</span></code> script converts the scalp surface to
fif format and saves the result to <code class="file docutils literal notranslate"><span class="pre">bem/</span><em><span class="pre">&lt;subject&gt;</span></em><span class="pre">-head.fif</span></code>.</p>
</div>
<div class="section" id="using-flash-images">
<h3>Using FLASH images<a class="headerlink" href="#using-flash-images" title="Permalink to this headline">¶</a></h3>
<p>This method depends on the availablily of MRI data acquired with a multi-echo
FLASH sequence at two flip angles (5 and 30 degrees). These data can be
acquired separately from the MPRAGE data employed in FreeSurfer cortical
reconstructions but it is strongly recommended that they are collected at the
same time with the MPRAGEs or at least with the same scanner. For easy
co-registration, the images should have FOV, matrix, slice thickness, gap, and
slice orientation as the MPRAGE data. For information on suitable pulse
sequences, see reference [B. Fischl <em>et al.</em> and J. Jovicich <em>et al.</em>, 2006] in
<a class="reference internal" href="../references.html#cegegdei"><span class="std std-ref">Forward modeling</span></a>.</p>
<p>Creation of the BEM meshes using this method involves the following steps:</p>
<ul class="simple">
<li><p>Creating a synthetic 5-degree flip angle FLASH volume, register
it with the MPRAGE data, and run the segmentation and meshing program.
This step is accomplished by running the script <a class="reference internal" href="../generated/commands.html#mne-flash-bem"><span class="std std-ref">mne flash_bem</span></a>.</p></li>
<li><p>Inspecting the meshes with tkmedit, see <a class="reference internal" href="#inspecting-meshes"><span class="std std-ref">Inspecting the meshes</span></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Different methods can be employed for the creation of the
individual surfaces. For example, it may turn out that the
watershed algorithm produces are better quality skin surface than
the segmentation approach based on the FLASH images. If this is
the case, <code class="docutils literal notranslate"><span class="pre">outer_skin.surf</span></code> can set to point to the corresponding
watershed output file while the other surfaces can be picked from
the FLASH segmentation data.</p>
</div>
<div class="section" id="organizing-mri-data-into-directories">
<h4>Organizing MRI data into directories<a class="headerlink" href="#organizing-mri-data-into-directories" title="Permalink to this headline">¶</a></h4>
<p>Since all images comprising the multi-echo FLASH data are contained in a single
series, it is necessary to organize the images according to the echoes before
proceeding to the BEM surface reconstruction. This can be accomplished by using
<a class="reference external" href="https://www.nitrc.org/plugins/mwiki/index.php/dcm2nii:MainPage">dcm2niix</a>
or the MNE-C tool <code class="docutils literal notranslate"><span class="pre">mne_organize_dicom</span></code> if necessary, then use
<a class="reference internal" href="../generated/mne.bem.convert_flash_mris.html#mne.bem.convert_flash_mris" title="mne.bem.convert_flash_mris"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.bem.convert_flash_mris()</span></code></a>.</p>
</div>
<div class="section" id="creating-the-surface-tessellations">
<h4>Creating the surface tessellations<a class="headerlink" href="#creating-the-surface-tessellations" title="Permalink to this headline">¶</a></h4>
<p>The BEM surface segmentation and tessellation is automated with the script
<a class="reference internal" href="../generated/commands.html#mne-flash-bem"><span class="std std-ref">mne flash_bem</span></a>. It assumes that a FreeSurfer reconstruction for this
subject is already in place.</p>
<p>Before running <a class="reference internal" href="../generated/commands.html#mne-flash-bem"><span class="std std-ref">mne flash_bem</span></a> do the following:</p>
<ul class="simple">
<li><p>Create symbolic links from the directories containing the 5-degree and
30-degree flip angle FLASH series to <code class="docutils literal notranslate"><span class="pre">flash05</span></code> and <code class="docutils literal notranslate"><span class="pre">flash30</span></code>,
respectively:</p>
<ul>
<li><p><code class="samp docutils literal notranslate"><span class="pre">ln</span> <span class="pre">-s</span> <em><span class="pre">&lt;FLASH</span> <span class="pre">5</span> <span class="pre">series</span> <span class="pre">dir&gt;</span></em> <span class="pre">flash05</span></code></p></li>
<li><p><code class="samp docutils literal notranslate"><span class="pre">ln</span> <span class="pre">-s</span> <em><span class="pre">&lt;FLASH</span> <span class="pre">30</span> <span class="pre">series</span> <span class="pre">dir&gt;</span></em> <span class="pre">flash30</span></code></p></li>
</ul>
</li>
<li><p>Some partition formats (e.g. FAT32) do not support symbolic links. In this
case, copy the file to the appropriate series:</p>
<ul>
<li><p><code class="samp docutils literal notranslate"><span class="pre">cp</span> <em><span class="pre">&lt;FLASH</span> <span class="pre">5</span> <span class="pre">series</span> <span class="pre">dir&gt;</span></em> <span class="pre">flash05</span></code></p></li>
<li><p><code class="samp docutils literal notranslate"><span class="pre">cp</span> <em><span class="pre">&lt;FLASH</span> <span class="pre">30</span> <span class="pre">series</span> <span class="pre">dir&gt;</span></em> <span class="pre">flash30</span></code></p></li>
</ul>
</li>
<li><p>Set the <code class="docutils literal notranslate"><span class="pre">SUBJECTS_DIR</span></code> and <code class="docutils literal notranslate"><span class="pre">SUBJECT</span></code> environment variables or pass
the <code class="docutils literal notranslate"><span class="pre">--subjects-dir</span></code> and <code class="docutils literal notranslate"><span class="pre">--subject</span></code> options to <code class="docutils literal notranslate"><span class="pre">mne</span> <span class="pre">flash_bem</span></code></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">mne</span> <span class="pre">flash_bem</span></code> is run with the <code class="docutils literal notranslate"><span class="pre">--noflash30</span></code> option, the
<code class="file docutils literal notranslate"><span class="pre">flash30</span></code> directory is not needed, <em>i.e.</em>, only the 5-degree flip
angle flash data are employed.</p>
</div>
<p>It may take a while for <code class="docutils literal notranslate"><span class="pre">mne</span> <span class="pre">flash_bem</span></code> to complete. It uses the FreeSurfer
directory structure under <code class="docutils literal notranslate"><span class="pre">$SUBJECTS_DIR/$SUBJECT</span></code>. The script encapsulates
the following processing steps:</p>
<ul class="simple">
<li><p>It creates an mgz file corresponding to each of the eight echoes in each of
the FLASH directories in <code class="docutils literal notranslate"><span class="pre">mri/flash</span></code>. The files will be called
<code class="file docutils literal notranslate"><span class="pre">mef</span> <em><span class="pre">&lt;flip-angle&gt;</span></em><span class="pre">_</span><em><span class="pre">&lt;echo-number&gt;</span></em><span class="pre">.mgz</span></code>.</p></li>
<li><p>If the <code class="docutils literal notranslate"><span class="pre">unwarp=True</span></code> option is specified, run grad_unwarp and produce
files <code class="file docutils literal notranslate"><span class="pre">mef</span> <em><span class="pre">&lt;flip-angle&gt;</span></em><span class="pre">_</span><em><span class="pre">&lt;echo-number&gt;</span></em><span class="pre">u.mgz</span></code>. These files will be
then used in the following steps.</p></li>
<li><p>It creates parameter maps in <code class="file docutils literal notranslate"><span class="pre">mri/flash/parameter_maps</span></code> using
<code class="docutils literal notranslate"><span class="pre">mri_ms_fitparms</span></code>.</p></li>
<li><p>It creates a synthetic 5-degree flip angle volume in
<code class="file docutils literal notranslate"><span class="pre">mri/flash/parameter_maps/flash5.mgz</span></code> using <code class="docutils literal notranslate"><span class="pre">mri_synthesize</span></code>.</p></li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">fsl_rigid_register</span></code>, it creates a registered 5-degree flip angle
volume <code class="docutils literal notranslate"><span class="pre">mri/flash/parameter_maps/flash5_reg.mgz</span></code> by registering
<code class="file docutils literal notranslate"><span class="pre">mri/flash/parameter_maps/flash5.mgz</span></code> to the <em>T1</em> volume under <code class="docutils literal notranslate"><span class="pre">mri</span></code>.</p></li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">mri_convert</span></code>, it converts the flash5_reg volume to COR format under
<code class="docutils literal notranslate"><span class="pre">mri/flash5</span></code>. If necessary, the T1 and brain volumes are also converted
into the COR format.</p></li>
<li><p>It runs <code class="docutils literal notranslate"><span class="pre">mri_make_bem_surfaces</span></code> to create the BEM surface tessellations.</p></li>
<li><p>It creates the directory <code class="file docutils literal notranslate"><span class="pre">bem/flash</span></code>, moves the tri-format
tringulations there and creates the corresponding FreeSurfer surface files
in the same directory.</p></li>
<li><p>The COR format volumes created by <code class="docutils literal notranslate"><span class="pre">mne</span> <span class="pre">flash_bem</span></code> are removed.</p></li>
</ul>
<p>If the <code class="docutils literal notranslate"><span class="pre">--noflash30</span></code> option is specified to <code class="docutils literal notranslate"><span class="pre">mne</span> <span class="pre">flash_bem</span></code>,
steps 3 and 4 in the above are replaced by averaging over the different
echo times in 5-degree flip angle data.</p>
</div>
<div class="section" id="inspecting-the-meshes">
<span id="inspecting-meshes"></span><h4>Inspecting the meshes<a class="headerlink" href="#inspecting-the-meshes" title="Permalink to this headline">¶</a></h4>
<p>It is advisable to check the validity of the BEM meshes before
using them. This can be done with:</p>
<ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">--view</span></code> option of <a class="reference internal" href="../generated/commands.html#mne-flash-bem"><span class="std std-ref">mne flash_bem</span></a></p></li>
<li><p>calling <a class="reference internal" href="../generated/mne.viz.plot_bem.html#mne.viz.plot_bem" title="mne.viz.plot_bem"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.viz.plot_bem()</span></code></a> directly</p></li>
<li><p>Using FreeSurfer tools <code class="docutils literal notranslate"><span class="pre">tkmedit</span></code> or <code class="docutils literal notranslate"><span class="pre">freeview</span></code></p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="the-forward-solution">
<span id="ch-forward"></span><h2><a class="toc-backref" href="#id30">The forward solution</a><a class="headerlink" href="#the-forward-solution" title="Permalink to this headline">¶</a></h2>
<div class="section" id="meg-eeg-and-mri-coordinate-systems">
<span id="coordinate-systems"></span><h3>MEG/EEG and MRI coordinate systems<a class="headerlink" href="#meg-eeg-and-mri-coordinate-systems" title="Permalink to this headline">¶</a></h3>
<div class="sidebar">
<p class="sidebar-title">Coordinate systems in MNE-Python</p>
<p>In some MNE-Python objects (e.g., <a class="reference internal" href="../generated/mne.Forward.html#mne.Forward" title="mne.Forward"><code class="xref py py-class docutils literal notranslate"><span class="pre">Forward</span></code></a>,
<a class="reference internal" href="../generated/mne.SourceSpaces.html#mne.SourceSpaces" title="mne.SourceSpaces"><code class="xref py py-class docutils literal notranslate"><span class="pre">SourceSpaces</span></code></a>, etc), information about the coordinate frame is
encoded as a constant integer value. The meaning of those integers is
determined <a class="reference external" href="https://github.com/mne-tools/mne-python/blob/master/mne/io/constants.py#L186-L197">in the source code</a>.</p>
</div>
<p>The coordinate systems used in MNE software (and FreeSurfer) and their
relationships are depicted in <a class="reference internal" href="#coordinate-system-figure"><span class="std std-ref">MEG/EEG and MRI coordinate systems</span></a>. Except for the
<em>sensor coordinates</em>, all of the coordinate systems are Cartesian and have the
“RAS” (Right-Anterior-Superior) orientation, <em>i.e.</em>, the <span class="math notranslate nohighlight">\(x\)</span> axis points
to the right, the <span class="math notranslate nohighlight">\(y\)</span> axis to the front, and the <span class="math notranslate nohighlight">\(z\)</span> axis up.</p>
<div class="figure align-default" id="id13">
<span id="coordinate-system-figure"></span><img alt="MEG/EEG and MRI coordinate systems" src="../_images/CoordinateSystems.png" />
<p class="caption"><span class="caption-text">MEG/EEG and MRI coordinate systems</span><a class="headerlink" href="#id13" title="Permalink to this image">¶</a></p>
<div class="legend">
<p>The coordinate transforms present in the fif files in MNE and the
FreeSurfer files as well as those set to fixed values are indicated with
<span class="math notranslate nohighlight">\(T_x\)</span>, where <span class="math notranslate nohighlight">\(x\)</span> identifies the transformation.</p>
</div>
</div>
<p>The coordinate systems related to MEG/EEG data are:</p>
<p><strong>Head coordinates</strong></p>
<blockquote>
<div><p>This is a coordinate system defined with help of the fiducial landmarks
(nasion and the two auricular points). In fif files, EEG electrode
locations are given in this coordinate system. In addition, the head
digitization data acquired in the beginning of an MEG, MEG/EEG, or EEG
acquisition are expressed in head coordinates. For details, see
<a class="reference internal" href="#coordinate-systems"><span class="std std-ref">MEG/EEG and MRI coordinate systems</span></a>.</p>
</div></blockquote>
<p><strong>Device coordinates</strong></p>
<blockquote>
<div><p>This is a coordinate system tied to the MEG device. The relationship of the
Device and Head coordinates is determined during an MEG measurement by
feeding current to three to five head-position indicator (HPI) coils and by
determining their locations with respect to the MEG sensor array from the
magnetic fields they generate.</p>
</div></blockquote>
<p><strong>Sensor coordinates</strong></p>
<blockquote>
<div><p>Each MEG sensor has a local coordinate system defining the orientation and
location of the sensor. With help of this coordinate system, the numerical
integration data needed for the computation of the magnetic field can be
expressed conveniently as discussed in <a class="reference internal" href="#coil-geometry-information"><span class="std std-ref">Coil geometry information</span></a>.
The channel information data in the fif files contain the information to
specify the coordinate transformation between the coordinates of each
sensor and the MEG device coordinates.</p>
</div></blockquote>
<p>The coordinate systems related to MRI data are:</p>
<p><strong>Surface RAS coordinates</strong></p>
<blockquote>
<div><p>The FreeSurfer surface data are expressed in this coordinate system. The
origin of this coordinate system is at the center of the conformed
FreeSurfer MRI volumes (usually 256 x 256 x 256 isotropic 1-mm3  voxels)
and the axes are oriented along the axes of this volume. The BEM surface
and the locations of the sources in the source space are usually expressed
in this coordinate system in the fif files. In this manual, the <em>Surface
RAS coordinates</em> are usually referred to as <em>MRI coordinates</em> unless there
is need to specifically discuss the different MRI-related coordinate
systems.</p>
</div></blockquote>
<p><strong>RAS coordinates</strong></p>
<blockquote>
<div><p>This coordinate system has axes identical to the Surface RAS coordinates
but the location of the origin is different and defined by the original MRI
data, i.e. , the origin is in a scanner-dependent location. There is hardly
any need to refer to this coordinate system explicitly in the analysis with
the MNE software. However, since the Talairach coordinates, discussed
below, are defined with respect to <em>RAS coordinates</em> rather than the
<em>Surface RAS coordinates</em>, the RAS coordinate system is implicitly involved
in the transformation between Surface RAS coordinates and the two
<em>Talairach</em> coordinate systems.</p>
</div></blockquote>
<p><strong>MNI Talairach coordinates</strong></p>
<blockquote>
<div><p>The definition of this coordinate system is discussed, e.g., in
<a class="reference external" href="https://imaging.mrc-cbu.cam.ac.uk/imaging/MniTalairach">https://imaging.mrc-cbu.cam.ac.uk/imaging/MniTalairach</a>. This transformation
is determined during the FreeSurfer reconstruction process. These
coordinates are in MNI305 space.</p>
</div></blockquote>
<p><strong>FreeSurfer Talairach coordinates</strong></p>
<blockquote>
<div><p>The problem with the MNI Talairach coordinates is that the linear MNI
Talairach transform does not match the brains completely to the Talairach
brain. This is probably because the Talairach atlas brain is a rather odd
shape, and as a result, it is difficult to match a standard brain to the
atlas brain using an affine transform. As a result, the MNI brains are
slightly larger (in particular higher, deeper and longer) than the
Talairach brain. The differences are larger as you get further from the
middle of the brain, towards the outside. The FreeSurfer Talairach
coordinates mitigate this problem by additing a an additional
transformation, defined separately for negatice and positive MNI Talairach
<span class="math notranslate nohighlight">\(z\)</span> coordinates. These two transformations, denoted by <span class="math notranslate nohighlight">\(T_-\)</span>
and <span class="math notranslate nohighlight">\(T_+\)</span> in <a class="reference internal" href="#coordinate-system-figure"><span class="std std-ref">MEG/EEG and MRI coordinate systems</span></a>, are fixed as discussed in
<a class="reference external" href="https://imaging.mrc-cbu.cam.ac.uk/imaging/MniTalairach">https://imaging.mrc-cbu.cam.ac.uk/imaging/MniTalairach</a> (<em>Approach 2</em>).</p>
</div></blockquote>
<p>The different coordinate systems are related by coordinate transformations
depicted in <a class="reference internal" href="#coordinate-system-figure"><span class="std std-ref">MEG/EEG and MRI coordinate systems</span></a>. The arrows and coordinate
transformation symbols (<span class="math notranslate nohighlight">\(T_x\)</span>) indicate the transformations actually
present in the FreeSurfer files. Generally,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
x_2 \\
y_2 \\
z_2 \\
1
\end{bmatrix} = T_{12} \begin{bmatrix}
x_1 \\
y_1 \\
z_1 \\
1
\end{bmatrix} = \begin{bmatrix}
R_{11} &amp; R_{12} &amp; R_{13} &amp; x_0 \\
R_{21} &amp; R_{22} &amp; R_{23} &amp; y_0 \\
R_{31} &amp; R_{32} &amp; R_{33} &amp; z_0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix} \begin{bmatrix}
x_1 \\
y_1 \\
z_1 \\
1
\end{bmatrix}\ ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(x_k\)</span>, <span class="math notranslate nohighlight">\(y_k\)</span>,and <span class="math notranslate nohighlight">\(z_k\)</span> are the location coordinates in
two coordinate systems, <span class="math notranslate nohighlight">\(T_{12}\)</span> is the coordinate transformation from
coordinate system “1” to “2”, <span class="math notranslate nohighlight">\(x_0\)</span>, <span class="math notranslate nohighlight">\(y_0\)</span>, and <span class="math notranslate nohighlight">\(z_0\)</span> is the
location of the origin of coordinate system “1” in coordinate system “2”, and
<span class="math notranslate nohighlight">\(R_{jk}\)</span> are the elements of the rotation matrix relating the two
coordinate systems. The coordinate transformations are present in different
files produced by FreeSurfer and MNE.
The fixed transformations <span class="math notranslate nohighlight">\(T_-\)</span> and <span class="math notranslate nohighlight">\(T_+\)</span> are:</p>
<div class="math notranslate nohighlight">
\[\begin{split}T_{-} = \begin{bmatrix}
0.99 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0.9688 &amp; 0.042 &amp; 0 \\
0 &amp; -0.0485 &amp; 0.839 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}\end{split}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}T_{+} = \begin{bmatrix}
0.99 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0.9688 &amp; 0.046 &amp; 0 \\
0 &amp; -0.0485 &amp; 0.9189 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}\end{split}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section does not discuss the transformation between the MRI voxel
indices and the different MRI coordinates. However, it is important to note
that in FreeSurfer, MNE, as well as in Neuromag software an integer voxel
coordinate corresponds to the location of the center of a voxel. Detailed
information on the FreeSurfer MRI systems can be found at
<a class="reference external" href="https://surfer.nmr.mgh.harvard.edu/fswiki/CoordinateSystems">https://surfer.nmr.mgh.harvard.edu/fswiki/CoordinateSystems</a>.
The symbols <span class="math notranslate nohighlight">\(T_x\)</span> are defined in <a class="reference internal" href="#coordinate-system-figure"><span class="std std-ref">MEG/EEG and MRI coordinate systems</span></a>.</p>
</div>
<table class="docutils align-default" id="id14">
<caption><span class="caption-text">Coordinate transformations in FreeSurfer and MNE software packages.</span><a class="headerlink" href="#id14" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 28%" />
<col style="width: 45%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Transformation</p></td>
<td><p>FreeSurfer</p></td>
<td><p>MNE</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(T_1\)</span></p></td>
<td><p>Not present</p></td>
<td><div class="line-block">
<div class="line">Measurement data files</div>
<div class="line">Forward solution files (<code class="docutils literal notranslate"><span class="pre">*fwd.fif</span></code>)</div>
<div class="line">Inverse operator files (<code class="docutils literal notranslate"><span class="pre">*inv.fif</span></code>)</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(T_{s_1}\dots T_{s_n}\)</span></p></td>
<td><p>Not present</p></td>
<td><p>Channel information in files
containing <span class="math notranslate nohighlight">\(T_1\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(T_2\)</span></p></td>
<td><p>Not present</p></td>
<td><div class="line-block">
<div class="line">MRI description filesSeparate</div>
<div class="line">Separate <code class="docutils literal notranslate"><span class="pre">-trans.fif</span></code> files</div>
<div class="line">from <a class="reference internal" href="../generated/commands.html#mne-coreg"><span class="std std-ref">mne coreg</span></a></div>
<div class="line">Forward solution files</div>
<div class="line">Inverse operator files</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(T_3\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mri/*mgz</span></code> files</p></td>
<td><p><a class="reference external" href="https://nipy.org/nibabel/reference/nibabel.freesurfer.html#nibabel.freesurfer.mghformat.MGHImage" title="(in NiBabel v3.2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.freesurfer.mghformat.MGHImage</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(T_4\)</span></p></td>
<td><p>mri/transforms/talairach.xfm</p></td>
<td><p>Internal reading</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(T_-\)</span></p></td>
<td><p>Hardcoded in software</p></td>
<td><p>Hardcoded in software.</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(T_+\)</span></p></td>
<td><p>Hardcoded in software</p></td>
<td><p>Hardcoded in software.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="the-head-and-device-coordinate-systems">
<span id="head-device-coords"></span><h3>The head and device coordinate systems<a class="headerlink" href="#the-head-and-device-coordinate-systems" title="Permalink to this headline">¶</a></h3>
<div class="figure align-default" id="id15">
<img alt="Head coordinate system" src="../_images/HeadCS.png" />
<p class="caption"><span class="caption-text">The head coordinate system</span><a class="headerlink" href="#id15" title="Permalink to this image">¶</a></p>
</div>
<p>The MEG/EEG head coordinate system employed in the MNE software is a
right-handed Cartesian coordinate system. The direction of <span class="math notranslate nohighlight">\(x\)</span> axis is
from left to right, that of <span class="math notranslate nohighlight">\(y\)</span> axis to the front, and the <span class="math notranslate nohighlight">\(z\)</span> axis
thus points up.</p>
<p>The <span class="math notranslate nohighlight">\(x\)</span> axis of the head coordinate system passes through the two
periauricular or preauricular points digitized before acquiring the data with
positive direction to the right. The <span class="math notranslate nohighlight">\(y\)</span> axis passes through the nasion
and is normal to the <span class="math notranslate nohighlight">\(x\)</span> axis. The <span class="math notranslate nohighlight">\(z\)</span> axis points up according to
the right-hand rule and is normal to the <span class="math notranslate nohighlight">\(xy\)</span> plane.</p>
<p>The origin of the MEG device coordinate system is device dependent. Its origin
is located approximately at the center of a sphere which fits the occipital
section of the MEG helmet best with <span class="math notranslate nohighlight">\(x\)</span> axis axis going from left to
right and <span class="math notranslate nohighlight">\(y\)</span> axis pointing front. The <span class="math notranslate nohighlight">\(z\)</span> axis is, again, normal
to the <span class="math notranslate nohighlight">\(xy\)</span> plane with positive direction up.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The above definition is identical to that of the Neuromag MEG/EEG (head)
coordinate system. However, in 4-D Neuroimaging and CTF MEG systems the head
coordinate frame definition is different. The origin of the coordinate
system is at the midpoint of the left and right auricular points. The
<span class="math notranslate nohighlight">\(x\)</span> axis passes through the nasion and the origin with positive
direction to the front. The <span class="math notranslate nohighlight">\(y\)</span> axis is perpendicular to the <span class="math notranslate nohighlight">\(x\)</span>
axis on the and lies in the plane defined by the three fiducial landmarks,
positive direction from right to left. The <span class="math notranslate nohighlight">\(z\)</span> axis is normal to the
plane of the landmarks, pointing up. Note that in this convention the
auricular points are not necessarily located on <span class="math notranslate nohighlight">\(y\)</span> coordinate axis.
The file conversion utilities take care of these idiosyncrasies and convert
all coordinate information to the MNE software head coordinate frame.</p>
</div>
</div>
<div class="section" id="creating-a-surface-based-source-space">
<h3>Creating a surface-based source space<a class="headerlink" href="#creating-a-surface-based-source-space" title="Permalink to this headline">¶</a></h3>
<p>The fif format source space files containing the dipole locations and
orientations are created with <a class="reference internal" href="../generated/mne.setup_source_space.html#mne.setup_source_space" title="mne.setup_source_space"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.setup_source_space()</span></code></a>.</p>
</div>
<div class="section" id="creating-a-volumetric-or-discrete-source-space">
<h3>Creating a volumetric or discrete source space<a class="headerlink" href="#creating-a-volumetric-or-discrete-source-space" title="Permalink to this headline">¶</a></h3>
<p>In addition to source spaces confined to a surface, the MNE software provides
some support for three-dimensional source spaces bounded by a surface as well
as source spaces comprised of discrete, arbitrarily located source points. The
<a class="reference internal" href="../generated/mne.setup_volume_source_space.html#mne.setup_volume_source_space" title="mne.setup_volume_source_space"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.setup_volume_source_space()</span></code></a> utility assists in generating such source
spaces.</p>
</div>
<div class="section" id="creating-the-bem-meshes">
<h3>Creating the BEM meshes<a class="headerlink" href="#creating-the-bem-meshes" title="Permalink to this headline">¶</a></h3>
<p>See <a class="reference internal" href="#bem-model"><span class="std std-ref">The Boundary Element Model (BEM)</span></a>.</p>
<div class="section" id="topology-checks">
<h4>Topology checks<a class="headerlink" href="#topology-checks" title="Permalink to this headline">¶</a></h4>
<p>The following topology checks are performed during the creation of BEM models:</p>
<ul class="simple">
<li><p>The completeness of each surface is confirmed by calculating the total solid
angle subtended by all triangles from a point inside the triangulation. The
result should be very close to <span class="math notranslate nohighlight">\(4 \pi\)</span>. If the result is <span class="math notranslate nohighlight">\(-4 \pi\)</span>
instead, it is conceivable that the ordering of the triangle vertices is
incorrect and the <code class="docutils literal notranslate"><span class="pre">--swap</span></code> option should be specified.</p></li>
<li><p>The correct ordering of the surfaces is verified by checking that the
surfaces are inside each other as expected. This is accomplished by checking
that the sum solid angles subtended by triangles of a surface <span class="math notranslate nohighlight">\(S_k\)</span> at
all vertices of another surface <span class="math notranslate nohighlight">\(S_p\)</span> which is supposed to be inside it
equals <span class="math notranslate nohighlight">\(4 \pi\)</span>. Naturally, this check is applied only if the model has
more than one surface. Since the surface relations are transitive, it is
enough to check that the outer skull surface is inside the skin surface and
that the inner skull surface is inside the outer skull one.</p></li>
<li><p>The extent of each of the triangulated volumes is checked. If the extent is
smaller than 50mm, an error is reported. This may indicate that the vertex
coordinates have been specified in meters instead of millimeters.</p></li>
</ul>
</div>
</div>
<div class="section" id="computing-the-bem-geometry-data">
<h3>Computing the BEM geometry data<a class="headerlink" href="#computing-the-bem-geometry-data" title="Permalink to this headline">¶</a></h3>
<p>The utility <a class="reference internal" href="../generated/mne.make_bem_solution.html#mne.make_bem_solution" title="mne.make_bem_solution"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.make_bem_solution()</span></code></a> computes the geometry information for
BEM.</p>
</div>
<div class="section" id="coil-geometry-information">
<span id="id2"></span><h3>Coil geometry information<a class="headerlink" href="#coil-geometry-information" title="Permalink to this headline">¶</a></h3>
<p>This Section explains the presentation of MEG detection coil geometry
information the approximations used for different detection coils in MNE
software. Two pieces of information are needed to characterize the detectors:</p>
<ul class="simple">
<li><p>The location and orientation a local coordinate system for each detector.</p></li>
<li><p>A unique identifier, which has an one-to-one correspondence to the
geometrical description of the coil.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>MNE ships with several coil geometry configurations. They can be
found in <code class="docutils literal notranslate"><span class="pre">mne/data</span></code>. See <a class="reference internal" href="../auto_examples/visualization/plot_meg_sensors.html#ex-plot-meg-sensors"><span class="std std-ref">Plotting sensor layouts of MEG systems</span></a> for a
comparison between different coil geometries, and
<a class="reference internal" href="#implemented-coil-geometries"><span class="std std-ref">Implemented coil geometries</span></a> for detailed information regarding
the files describing Neuromag coil geometries.</p>
</div>
<div class="section" id="the-sensor-coordinate-system">
<h4>The sensor coordinate system<a class="headerlink" href="#the-sensor-coordinate-system" title="Permalink to this headline">¶</a></h4>
<p>The sensor coordinate system is completely characterized by the location of its
origin and the direction cosines of three orthogonal unit vectors pointing to
the directions of the x, y, and z axis. In fact, the unit vectors contain
redundant information because the orientation can be uniquely defined with
three angles. The measurement fif files list these data in MEG device
coordinates. Transformation to the MEG head coordinate frame can be easily
accomplished by applying the device-to-head coordinate transformation matrix
available in the data files provided that the head-position indicator was used.
Optionally, the MNE software forward calculation applies another coordinate
transformation to the head-coordinate data to bring the coil locations and
orientations to the MRI coordinate system.</p>
<p>If <span class="math notranslate nohighlight">\(r_0\)</span> is a row vector for the origin of the local sensor coordinate
system and <span class="math notranslate nohighlight">\(e_x\)</span>, <span class="math notranslate nohighlight">\(e_y\)</span>, and <span class="math notranslate nohighlight">\(e_z\)</span> are the row vectors for
the three orthogonal unit vectors, all given in device coordinates, a location
of a point <span class="math notranslate nohighlight">\(r_C\)</span> in sensor coordinates is transformed to device
coordinates (<span class="math notranslate nohighlight">\(r_D\)</span>) by</p>
<div class="math notranslate nohighlight">
\[[r_D 1] = [r_C 1] T_{CD}\ ,\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}T = \begin{bmatrix}
e_x &amp; 0 \\
e_y &amp; 0 \\
e_z &amp; 0 \\
r_{0D} &amp; 1
\end{bmatrix}\ .\end{split}\]</div>
</div>
<div class="section" id="calculation-of-the-magnetic-field">
<h4>Calculation of the magnetic field<a class="headerlink" href="#calculation-of-the-magnetic-field" title="Permalink to this headline">¶</a></h4>
<p>The forward calculation in the MNE software computes the signals detected by
each MEG sensor for three orthogonal dipoles at each source space location.
This requires specification of the conductor model, the location and
orientation of the dipoles, and the location and orientation of each MEG sensor
as well as its coil geometry.</p>
<p>The output of each SQUID sensor is a weighted sum of the magnetic fluxes
threading the loops comprising the detection coil. Since the flux threading a
coil loop is an integral of the magnetic field component normal to the coil
plane, the output of the k <sup>th</sup> MEG channel, <span class="math notranslate nohighlight">\(b_k\)</span> can be
approximated by:</p>
<div class="math notranslate nohighlight">
\[b_k = \sum_{p = 1}^{N_k} {w_{kp} B(r_{kp}) \cdot n_{kp}}\]</div>
<p>where <span class="math notranslate nohighlight">\(r_{kp}\)</span> are a set of <span class="math notranslate nohighlight">\(N_k\)</span> integration points covering the
pickup coil loops of the sensor, <span class="math notranslate nohighlight">\(B(r_{kp})\)</span> is the magnetic field due to
the current sources calculated at <span class="math notranslate nohighlight">\(r_{kp}\)</span>, <span class="math notranslate nohighlight">\(n_{kp}\)</span> are the coil
normal directions at these points, and <span class="math notranslate nohighlight">\(w_{kp}\)</span> are the weights
associated to the integration points. This formula essentially presents
numerical integration of the magnetic field over the pickup loops of sensor
<span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>There are three accuracy levels for the numerical integration expressed above.
The <em>simple</em> accuracy means the simplest description of the coil. This accuracy
is not used in the MNE forward calculations. The <em>normal</em> or <em>recommended</em>
accuracy typically uses two integration points for planar gradiometers, one in
each half of the pickup coil and four evenly distributed integration points for
magnetometers. This is the default accuracy used by MNE. If the <code class="docutils literal notranslate"><span class="pre">--accurate</span></code>
option is specified, the forward calculation typically employs a total of eight
integration points for planar gradiometers and sixteen for magnetometers.
Detailed information about the integration points is given in the next section.</p>
</div>
<div class="section" id="implemented-coil-geometries">
<span id="id3"></span><h4>Implemented coil geometries<a class="headerlink" href="#implemented-coil-geometries" title="Permalink to this headline">¶</a></h4>
<p>This section describes the coil geometries currently implemented
in MNE. The coil types fall in two general categories:</p>
<ul class="simple">
<li><p>Axial gradiometers and planar gradiometers
and</p></li>
<li><p>Planar magnetometers.</p></li>
</ul>
<p>For axial sensors, the <em>z</em> axis of the local coordinate system is parallel to
the field component detected, <em>i.e.</em>, normal to the coil plane.For circular
coils, the orientation of the <em>x</em> and <em>y</em> axes on the plane normal to the z
axis is irrelevant. In the square coils employed in the Vectorview (TM) system
the <em>x</em> axis is chosen to be parallel to one of the sides of the magnetometer
coil. For planar sensors, the <em>z</em> axis is likewise normal to the coil plane and
the x axis passes through the centerpoints of the two coil loops so that the
detector gives a positive signal when the normal field component increases
along the <em>x</em> axis.</p>
<p><a class="reference internal" href="#normal-coil-descriptions"><span class="std std-ref">Normal coil descriptions.</span></a> lists the parameters of the <em>normal</em> coil
geometry descriptions <a class="reference internal" href="#accurate-coil-descriptions"><span class="std std-ref">Accurate coil descriptions</span></a> lists the <em>accurate</em>
descriptions. For simple accuracy, please consult the coil definition file, see
<a class="reference internal" href="#coil-definition-file"><span class="std std-ref">The coil definition file</span></a>. The columns of the tables contain the following
data:</p>
<ul class="simple">
<li><p>The number identifying the coil id.
This number is used in the coil descriptions found in the FIF files.</p></li>
<li><p>Description of the coil.</p></li>
<li><p>Number of integration points used</p></li>
<li><p>The locations of the integration points in sensor coordinates.</p></li>
<li><p>Weights assigned to the field values at the integration points.
Some formulas are listed instead of the numerical values to demonstrate
the principle of the calculation. For example, in the normal coil
descriptions of the planar gradiometers the weights are inverses
of the baseline of the gradiometer to show that the output is in
T/m.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The coil geometry information is stored in the file
<code class="file docutils literal notranslate"><span class="pre">mne/data/coil_def.dat</span></code>, which is
automatically created by the MNE-C utility <code class="docutils literal notranslate"><span class="pre">mne_list_coil_def</span></code>.</p>
</div>
<span id="normal-coil-descriptions"></span><table class="docutils align-default" id="id16">
<caption><span class="caption-text">Normal coil descriptions.</span><a class="headerlink" href="#id16" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 7%" />
<col style="width: 27%" />
<col style="width: 4%" />
<col style="width: 37%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Id</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>n</p></th>
<th class="head"><p>r/mm</p></th>
<th class="head"><p>w</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>Neuromag-122
planar gradiometer</p></td>
<td><p>2</p></td>
<td><p>(+/-8.1, 0, 0) mm</p></td>
<td><p>+/-1 ⁄ 16.2mm</p></td>
</tr>
<tr class="row-odd"><td><p>2000</p></td>
<td><p>A point magnetometer</p></td>
<td><p>1</p></td>
<td><p>(0, 0, 0)mm</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>3012</p></td>
<td><p>Vectorview type 1
planar gradiometer</p></td>
<td><p>2</p></td>
<td><p>(+/-8.4, 0, 0.3) mm</p></td>
<td><p>+/-1 ⁄ 16.8mm</p></td>
</tr>
<tr class="row-odd"><td><p>3013</p></td>
<td><p>Vectorview type 2
planar gradiometer</p></td>
<td><p>2</p></td>
<td><p>(+/-8.4, 0, 0.3) mm</p></td>
<td><p>+/-1 ⁄ 16.8mm</p></td>
</tr>
<tr class="row-even"><td><p>3022</p></td>
<td><p>Vectorview type 1
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-6.45, +/-6.45, 0.3)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-odd"><td><p>3023</p></td>
<td><p>Vectorview type 2
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-6.45, +/-6.45, 0.3)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-even"><td><p>3024</p></td>
<td><p>Vectorview type 3
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-5.25, +/-5.25, 0.3)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-odd"><td><p>2000</p></td>
<td><p>An ideal point
magnetometer</p></td>
<td><p>1</p></td>
<td><p>(0.0, 0.0, 0.0)mm</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>4001</p></td>
<td><p>Magnes WH
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-5.75, +/-5.75, 0.0)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-odd"><td><p>4002</p></td>
<td><p>Magnes WH 3600
axial gradiometer</p></td>
<td><p>8</p></td>
<td><p>(+/-4.5, +/-4.5, 0.0)mm
(+/-4.5, +/-4.5, 50.0)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
<tr class="row-even"><td><p>4003</p></td>
<td><p>Magnes reference
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-7.5, +/-7.5, 0.0)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-odd"><td><p>4004</p></td>
<td><p>Magnes reference
gradiometer measuring
diagonal gradients</p></td>
<td><p>8</p></td>
<td><p>(+/-20, +/-20, 0.0)mm
(+/-20, +/-20, 135)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
<tr class="row-even"><td><p>4005</p></td>
<td><p>Magnes reference
gradiometer measuring
off-diagonal gradients</p></td>
<td><p>8</p></td>
<td><p>(87.5, +/-20, 0.0)mm
(47.5, +/-20, 0.0)mm
(-87.5, +/-20, 0.0)mm
(-47.5, +/-20, 0.0)mm</p></td>
<td><p>1/4
-1/4
1/4
-1/4</p></td>
</tr>
<tr class="row-odd"><td><p>5001</p></td>
<td><p>CTF 275 axial
gradiometer</p></td>
<td><p>8</p></td>
<td><p>(+/-4.5, +/-4.5, 0.0)mm
(+/-4.5, +/-4.5, 50.0)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
<tr class="row-even"><td><p>5002</p></td>
<td><p>CTF reference
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-4, +/-4, 0.0)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-odd"><td><p>5003</p></td>
<td><p>CTF reference
gradiometer measuring
diagonal gradients</p></td>
<td><p>8</p></td>
<td><p>(+/-8.6, +/-8.6, 0.0)mm
(+/-8.6, +/-8.6, 78.6)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a plus-minus sign occurs in several coordinates, all possible
combinations have to be included.</p>
</div>
<span id="accurate-coil-descriptions"></span><table class="docutils align-default" id="id17">
<caption><span class="caption-text">Accurate coil descriptions</span><a class="headerlink" href="#id17" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 7%" />
<col style="width: 27%" />
<col style="width: 4%" />
<col style="width: 37%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Id</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>n</p></th>
<th class="head"><p>r/mm</p></th>
<th class="head"><p>w</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>Neuromag-122 planar
gradiometer</p></td>
<td><p>8</p></td>
<td><p>+/-(8.1, 0, 0) mm</p></td>
<td><p>+/-1 ⁄ 16.2mm</p></td>
</tr>
<tr class="row-odd"><td><p>2000</p></td>
<td><p>A point magnetometer</p></td>
<td><p>1</p></td>
<td><p>(0, 0, 0) mm</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>3012</p></td>
<td><p>Vectorview type 1
planar gradiometer</p></td>
<td><p>2</p></td>
<td><p>(+/-8.4, 0, 0.3) mm</p></td>
<td><p>+/-1 ⁄ 16.8mm</p></td>
</tr>
<tr class="row-odd"><td><p>3013</p></td>
<td><p>Vectorview type 2
planar gradiometer</p></td>
<td><p>2</p></td>
<td><p>(+/-8.4, 0, 0.3) mm</p></td>
<td><p>+/-1 ⁄ 16.8mm</p></td>
</tr>
<tr class="row-even"><td><p>3022</p></td>
<td><p>Vectorview type 1
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-6.45, +/-6.45, 0.3)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-odd"><td><p>3023</p></td>
<td><p>Vectorview type 2
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-6.45, +/-6.45, 0.3)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-even"><td><p>3024</p></td>
<td><p>Vectorview type 3
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-5.25, +/-5.25, 0.3)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-odd"><td><p>4001</p></td>
<td><p>Magnes WH magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-5.75, +/-5.75, 0.0)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-even"><td><p>4002</p></td>
<td><p>Magnes WH 3600
axial gradiometer</p></td>
<td><p>4</p></td>
<td><p>(+/-4.5, +/-4.5, 0.0)mm
(+/-4.5, +/-4.5, 0.0)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
<tr class="row-odd"><td><p>4004</p></td>
<td><p>Magnes reference
gradiometer measuring
diagonal gradients</p></td>
<td><p>8</p></td>
<td><p>(+/-20, +/-20, 0.0)mm
(+/-20, +/-20, 135)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
<tr class="row-even"><td><p>4005</p></td>
<td><p>Magnes reference
gradiometer measuring
off-diagonal gradients</p></td>
<td><p>8</p></td>
<td><p>(87.5, +/-20, 0.0)mm
(47.5, +/-20, 0.0)mm
(-87.5, +/-20, 0.0)mm
(-47.5, +/-20, 0.0)mm</p></td>
<td><p>1/4
-1/4
1/4
-1/4</p></td>
</tr>
<tr class="row-odd"><td><p>5001</p></td>
<td><p>CTF 275 axial
gradiometer</p></td>
<td><p>8</p></td>
<td><p>(+/-4.5, +/-4.5, 0.0)mm
(+/-4.5, +/-4.5, 50.0)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
<tr class="row-even"><td><p>5002</p></td>
<td><p>CTF reference
magnetometer</p></td>
<td><p>4</p></td>
<td><p>(+/-4, +/-4, 0.0)mm</p></td>
<td><p>1/4</p></td>
</tr>
<tr class="row-odd"><td><p>5003</p></td>
<td><p>CTF 275 reference
gradiometer measuring
diagonal gradients</p></td>
<td><p>8</p></td>
<td><p>(+/-8.6, +/-8.6, 0.0)mm
(+/-8.6, +/-8.6, 78.6)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
<tr class="row-even"><td><p>5004</p></td>
<td><p>CTF 275 reference
gradiometer measuring
off-diagonal gradients</p></td>
<td><p>8</p></td>
<td><p>(47.8, +/-8.5, 0.0)mm
(30.8, +/-8.5, 0.0)mm
(-47.8, +/-8.5, 0.0)mm
(-30.8, +/-8.5, 0.0)mm</p></td>
<td><p>1/4
-1/4
1/4
-1/4</p></td>
</tr>
<tr class="row-odd"><td><p>6001</p></td>
<td><p>MIT KIT system axial
gradiometer</p></td>
<td><p>8</p></td>
<td><p>(+/-3.875, +/-3.875, 0.0)mm
(+/-3.875, +/-3.875, 0.0)mm</p></td>
<td><p>1/4
-1/4</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="the-coil-definition-file">
<span id="coil-definition-file"></span><h4>The coil definition file<a class="headerlink" href="#the-coil-definition-file" title="Permalink to this headline">¶</a></h4>
<p>The coil geometry information is stored in the text file
<code class="file docutils literal notranslate"><em><span class="pre">$MNE_ROOT</span></em><span class="pre">/share/mne/coil_def.dat</span></code>. In this file, any lines starting
with the pound sign (#) are comments. A coil definition starts with a
description line containing the following fields:</p>
<ul class="simple">
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;class&gt;</span></em></code>: A number indicating class of this coil.</p></li>
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;id&gt;</span></em></code>: Coil ID value. This value is listed in the first column of
Tables <a class="reference internal" href="#normal-coil-descriptions"><span class="std std-ref">Normal coil descriptions.</span></a> and <a class="reference internal" href="#accurate-coil-descriptions"><span class="std std-ref">Accurate coil descriptions</span></a>.</p></li>
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;accuracy&gt;</span></em></code>: The coil representation accuracy. Possible values and
their meanings are listed in <a class="reference internal" href="#coil-accuracies"><span class="std std-ref">Coil representation accuracies.</span></a>.</p></li>
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;np&gt;</span></em></code>: Number of integration points in this representation.</p></li>
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;size/m&gt;</span></em></code>: The size of the coil. For circular coils this is the
diameter of the coil and for square ones the side length of the square. This
information is mainly included to facilitate drawing of the coil geometry. It
should not be employed to infer a coil approximation for the forward
calculations.</p></li>
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;baseline/m&gt;</span></em></code>: The baseline of a this kind of a coil. This will be
zero for magnetometer coils. This information is mainly included to
facilitate drawing of the coil geometry. It should not be employed to infer
a coil approximation for the forward calculations.</p></li>
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;description&gt;</span></em></code>: Short description of this kind of a coil. If the
description contains several words, it is enclosed in quotes.</p></li>
</ul>
<span id="coil-accuracies"></span><table class="docutils align-default" id="id18">
<caption><span class="caption-text">Coil representation accuracies.</span><a class="headerlink" href="#id18" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 8%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>The simplest representation available</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>The standard or <em>normal</em> representation (see <a class="reference internal" href="#normal-coil-descriptions"><span class="std std-ref">Normal coil descriptions.</span></a>)</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>The most <em>accurate</em> representation available (see <a class="reference internal" href="#accurate-coil-descriptions"><span class="std std-ref">Accurate coil descriptions</span></a>)</p></td>
</tr>
</tbody>
</table>
<p>Each coil description line is followed by one or more integration point lines,
consisting of seven numbers:</p>
<ul class="simple">
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;weight&gt;</span></em></code>: Gives the weight for this integration point (last column
in Tables <a class="reference internal" href="#normal-coil-descriptions"><span class="std std-ref">Normal coil descriptions.</span></a> and
<a class="reference internal" href="#accurate-coil-descriptions"><span class="std std-ref">Accurate coil descriptions</span></a>).</p></li>
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;x/m&gt;</span></em> <em><span class="pre">&lt;y/m&gt;</span></em> <em><span class="pre">&lt;z/m&gt;</span></em></code>: Indicates the location of the integration
point (fourth column in Tables <a class="reference internal" href="#normal-coil-descriptions"><span class="std std-ref">Normal coil descriptions.</span></a> and
<a class="reference internal" href="#accurate-coil-descriptions"><span class="std std-ref">Accurate coil descriptions</span></a>).</p></li>
<li><p><code class="samp docutils literal notranslate"><em><span class="pre">&lt;nx&gt;</span></em> <em><span class="pre">&lt;ny&gt;</span></em> <em><span class="pre">&lt;nz&gt;</span></em></code>: Components of a unit vector indicating the
field component to be selected. Note that listing a separate unit vector for
each integration points allows the implementation of curved coils and coils
with the gradiometer loops tilted with respect to each other.</p></li>
</ul>
</div>
</div>
<div class="section" id="computing-the-forward-solution">
<h3>Computing the forward solution<a class="headerlink" href="#computing-the-forward-solution" title="Permalink to this headline">¶</a></h3>
<div class="section" id="purpose">
<h4>Purpose<a class="headerlink" href="#purpose" title="Permalink to this headline">¶</a></h4>
<p>Examples on how to compute the forward solution in MNE-Python using
<a class="reference internal" href="../generated/mne.make_forward_solution.html#mne.make_forward_solution" title="mne.make_forward_solution"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.make_forward_solution()</span></code></a> can be found
<a class="reference internal" href="../auto_tutorials/source-modeling/plot_forward.html#plot-forward-compute-forward-solution"><span class="std std-ref">Compute forward solution</span></a> and
<a class="reference internal" href="cookbook.html#computing-the-forward-solution"><span class="std std-ref">Computing the forward solution</span></a>.</p>
</div>
<div class="section" id="implementation-of-software-gradient-compensation">
<h4>Implementation of software gradient compensation<a class="headerlink" href="#implementation-of-software-gradient-compensation" title="Permalink to this headline">¶</a></h4>
<p>Accounting for noise cancellation in MNE-Python is accomplished in
<a class="reference internal" href="../generated/mne.io.Raw.html#mne.io.Raw.apply_gradient_compensation" title="mne.io.Raw.apply_gradient_compensation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mne.io.Raw.apply_gradient_compensation()</span></code></a>. See
<a class="reference internal" href="../auto_tutorials/sample-datasets/plot_brainstorm_phantom_ctf.html#plot-brainstorm-phantom-ctf"><span class="std std-ref">Brainstorm CTF phantom dataset tutorial</span></a> for an example.</p>
<p>CTF and 4D Neuroimaging data may have been subjected to noise cancellation
employing the data from the reference sensor array. Even though these sensor
are rather far away from the brain sources, <a class="reference internal" href="../generated/mne.make_forward_solution.html#mne.make_forward_solution" title="mne.make_forward_solution"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.make_forward_solution()</span></code></a>
takes them into account in the computations. If the data file has software
gradient compensation activated, it computes the field of at the reference
sensors in addition to the main MEG sensor array and computes a compensated
forward solution.</p>
</div>
<div class="section" id="the-eeg-sphere-model-definition-file">
<h4>The EEG sphere model definition file<a class="headerlink" href="#the-eeg-sphere-model-definition-file" title="Permalink to this headline">¶</a></h4>
<p>In MNE-Python, different sphere models can be specified through
<a class="reference internal" href="../generated/mne.make_sphere_model.html#mne.make_sphere_model" title="mne.make_sphere_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.make_sphere_model()</span></code></a>. The default model has the following structure:</p>
<table class="docutils align-default" id="id19">
<caption><span class="caption-text">Structure of the default EEG model</span><a class="headerlink" href="#id19" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 43%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Layer</p></th>
<th class="head"><p>Relative outer radius</p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(\sigma\)</span> (S/m)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Head</p></td>
<td><p>1.0</p></td>
<td><p>0.33</p></td>
</tr>
<tr class="row-odd"><td><p>Skull</p></td>
<td><p>0.97</p></td>
<td><p>0.04</p></td>
</tr>
<tr class="row-even"><td><p>CSF</p></td>
<td><p>0.92</p></td>
<td><p>1.0</p></td>
</tr>
<tr class="row-odd"><td><p>Brain</p></td>
<td><p>0.90</p></td>
<td><p>0.33</p></td>
</tr>
</tbody>
</table>
<p>Although it is not BEM model per se the <code class="docutils literal notranslate"><span class="pre">sphere</span></code> structure describes the head
geometry so it can be passed as <code class="docutils literal notranslate"><span class="pre">bem</span></code> parameter in MNE-Python functions such
as <a class="reference internal" href="../generated/mne.fit_dipole.html#mne.fit_dipole" title="mne.fit_dipole"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.fit_dipole()</span></code></a>, <a class="reference internal" href="../generated/mne.viz.plot_alignment.html#mne.viz.plot_alignment" title="mne.viz.plot_alignment"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.viz.plot_alignment()</span></code></a> or
<a class="reference internal" href="../generated/mne.make_forward_solution.html#mne.make_forward_solution" title="mne.make_forward_solution"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.make_forward_solution()</span></code></a>.</p>
</div>
<div class="section" id="eeg-forward-solution-in-the-sphere-model">
<span id="eeg-sphere-model"></span><h4>EEG forward solution in the sphere model<a class="headerlink" href="#eeg-forward-solution-in-the-sphere-model" title="Permalink to this headline">¶</a></h4>
<div class="sidebar">
<p class="sidebar-title">Sphere-model examples in MNE-Python</p>
<p>For examples of using the sphere model when computing the forward model
(using <a class="reference internal" href="../generated/mne.make_forward_solution.html#mne.make_forward_solution" title="mne.make_forward_solution"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.make_forward_solution()</span></code></a>), see <a class="reference internal" href="../auto_tutorials/sample-datasets/plot_brainstorm_phantom_ctf.html#plt-brainstorm-phantom-ctf-eeg-sphere-geometry"><span class="std std-ref">Brainstorm CTF phantom
dataset tutorial</span></a>,
<a class="reference internal" href="../auto_tutorials/sample-datasets/plot_brainstorm_phantom_elekta.html#plt-brainstorm-phantom-elekta-eeg-sphere-geometry"><span class="std std-ref">Brainstorm Elekta phantom dataset tutorial</span></a>, and
<a class="reference internal" href="../auto_tutorials/source-modeling/plot_source_alignment.html#plot-source-alignment-without-mri"><span class="std std-ref">Alignment without MRI</span></a>.</p>
</div>
<p>When the sphere model is employed, the computation of the EEG solution can be
substantially accelerated by using approximation methods described by Mosher
<a class="footnote-reference brackets" href="#mosheretal1999" id="id4">3</a>, Zhang <a class="footnote-reference brackets" href="#zhang1995" id="id5">6</a>, and Berg
<a class="footnote-reference brackets" href="#bergscherg1994" id="id6">1</a>.
<a class="reference internal" href="../generated/mne.make_forward_solution.html#mne.make_forward_solution" title="mne.make_forward_solution"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.make_forward_solution()</span></code></a> approximates the solution with three dipoles
in a homogeneous sphere whose locations and amplitudes are determined by
minimizing the cost function:</p>
<div class="math notranslate nohighlight">
\[S(r_1,\dotsc,r_m\ ,\ \mu_1,\dotsc,\mu_m) = \int_{scalp} {(V_{true} - V_{approx})}\,dS\]</div>
<p>where <span class="math notranslate nohighlight">\(r_1,\dotsc,r_m\)</span> and <span class="math notranslate nohighlight">\(\mu_1,\dotsc,\mu_m\)</span> are the locations
and amplitudes of the approximating dipoles and <span class="math notranslate nohighlight">\(V_{true}\)</span> and
<span class="math notranslate nohighlight">\(V_{approx}\)</span> are the potential distributions given by the true and
approximative formulas, respectively. It can be shown that this integral can be
expressed in closed form using an expansion of the potentials in spherical
harmonics. The formula is evaluated for the most superficial dipoles, <em>i.e.</em>,
those lying just inside the inner skull surface.</p>
</div>
</div>
<div class="section" id="averaging-forward-solutions">
<h3>Averaging forward solutions<a class="headerlink" href="#averaging-forward-solutions" title="Permalink to this headline">¶</a></h3>
<p>One possibility to make a grand average over several runs of a experiment is to
average the data across runs and average the forward solutions accordingly. For
this purpose, <a class="reference internal" href="../generated/mne.average_forward_solutions.html#mne.average_forward_solutions" title="mne.average_forward_solutions"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.average_forward_solutions()</span></code></a> computes a weighted average
of several forward solutions. The function averages both MEG and EEG forward
solutions. Usually the EEG forward solution is identical across runs because
the electrode locations do not change.</p>
</div>
</div>
<div class="section" id="the-minimum-norm-current-estimates">
<span id="minimum-norm-estimates"></span><h2><a class="toc-backref" href="#id31">The minimum-norm current estimates</a><a class="headerlink" href="#the-minimum-norm-current-estimates" title="Permalink to this headline">¶</a></h2>
<p>This section describes the mathematical details of the calculation of
minimum-norm estimates. In Bayesian sense, the ensuing current distribution is
the maximum a posteriori (MAP) estimate under the following assumptions:</p>
<ul class="simple">
<li><p>The viable locations of the currents are constrained to the cortex.
Optionally, the current orientations can be fixed to be normal to the
cortical mantle.</p></li>
<li><p>The amplitudes of the currents have a Gaussian prior distribution with a
known source covariance matrix.</p></li>
<li><p>The measured data contain additive noise with a Gaussian distribution with a
known covariance matrix. The noise is not correlated over time.</p></li>
</ul>
<p>Computing the inverse operator is accomplished using
<a class="reference internal" href="../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a> and
<a class="reference internal" href="../generated/mne.minimum_norm.apply_inverse.html#mne.minimum_norm.apply_inverse" title="mne.minimum_norm.apply_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.apply_inverse()</span></code></a>. The use of these functions is presented
in the tutorial <a class="reference internal" href="../auto_tutorials/source-modeling/plot_mne_dspm_source_localization.html#tut-inverse-methods"><span class="std std-ref">Source localization with MNE/dSPM/sLORETA/eLORETA</span></a>.</p>
<div class="section" id="the-linear-inverse-operator">
<h3>The linear inverse operator<a class="headerlink" href="#the-linear-inverse-operator" title="Permalink to this headline">¶</a></h3>
<p>The measured data in the source estimation procedure consists of MEG and EEG
data, recorded on a total of N channels. The task is to estimate a total of
<span class="math notranslate nohighlight">\(Q\)</span>
strengths of sources located on the cortical mantle. If the number of source
locations is <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q = P\)</span> for fixed-orientation sources and
<span class="math notranslate nohighlight">\(Q = 3P\)</span> if the source
orientations are unconstrained. The regularized linear inverse operator
following from regularized maximal likelihood of the above probabilistic model
is given by the <span class="math notranslate nohighlight">\(Q \times N\)</span> matrix</p>
<div class="math notranslate nohighlight">
\[M = R' G^\top (G R' G^\top + C)^{-1}\ ,\]</div>
<p>where <span class="math notranslate nohighlight">\(G\)</span> is the gain matrix relating the source strengths to the measured
MEG/EEG data, <span class="math notranslate nohighlight">\(C\)</span> is the data noise-covariance matrix and <span class="math notranslate nohighlight">\(R'\)</span> is
the source covariance matrix. The dimensions of these matrices are <span class="math notranslate nohighlight">\(N
\times Q\)</span>, <span class="math notranslate nohighlight">\(N \times N\)</span>, and <span class="math notranslate nohighlight">\(Q \times Q\)</span>, respectively. The
<span class="math notranslate nohighlight">\(Q \times 1\)</span> source-strength vector is obtained by multiplying the
<span class="math notranslate nohighlight">\(Q \times 1\)</span> data vector by <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<p>The expected value of the current amplitudes at time <em>t</em> is then given by
<span class="math notranslate nohighlight">\(\hat{j}(t) = Mx(t)\)</span>, where <span class="math notranslate nohighlight">\(x(t)\)</span> is a vector containing the
measured MEG and EEG data values at time <em>t</em>.</p>
<p>For computational convenience, the linear inverse operator is
not computed explicitly. See <a class="reference internal" href="#mne-solution"><span class="std std-ref">Computation of the solution</span></a> for mathematical
details, and <a class="reference internal" href="cookbook.html#cihcfjei"><span class="std std-ref">Calculating the inverse operator</span></a> for a detailed example.</p>
</div>
<div class="section" id="regularization">
<span id="mne-regularization"></span><h3>Regularization<a class="headerlink" href="#regularization" title="Permalink to this headline">¶</a></h3>
<p>The a priori variance of the currents is, in practice, unknown. We can express
this by writing <span class="math notranslate nohighlight">\(R' = R/ \lambda^2 = R \lambda^{-2}\)</span>, which yields the
inverse operator</p>
<div class="math notranslate nohighlight" id="equation-inv-m">
<span class="eqno">(13)<a class="headerlink" href="#equation-inv-m" title="Permalink to this equation">¶</a></span>\[\begin{split} M &amp;= R' G^\top (G R' G^\top + C)^{-1} \\
   &amp;= R \lambda^{-2} G^\top (G R \lambda^{-2} G^\top + C)^{-1} \\
   &amp;= R \lambda^{-2} G^\top \lambda^2 (G R G^\top + \lambda^2 C)^{-1} \\
   &amp;= R G^\top (G R G^\top + \lambda^2 C)^{-1}\ ,\end{split}\]</div>
<p>where the unknown current amplitude is now interpreted in terms of the
regularization parameter <span class="math notranslate nohighlight">\(\lambda^2\)</span>. Larger <span class="math notranslate nohighlight">\(\lambda^2\)</span> values
correspond to spatially smoother and weaker current amplitudes, whereas smaller
<span class="math notranslate nohighlight">\(\lambda^2\)</span> values lead to the opposite.</p>
<p>We can arrive at the regularized linear inverse operator also by minimizing a
cost function <span class="math notranslate nohighlight">\(S\)</span> with respect to the estimated current <span class="math notranslate nohighlight">\(\hat{j}\)</span>
(given the measurement vector <span class="math notranslate nohighlight">\(x\)</span> at any given time <span class="math notranslate nohighlight">\(t\)</span>) as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\min_\hat{j} \Bigl\{ S \Bigr\} &amp;= \min_\hat{j} \Bigl\{ \tilde{e}^\top \tilde{e} + \lambda^2 \hat{j}^\top R^{-1} \hat{j} \Bigr\} \\
                               &amp;= \min_\hat{j} \Bigl\{ (x - G\hat{j})^\top C^{-1} (x - G\hat{j}) + \lambda^2 \hat{j}^\top R^{-1} \hat{j} \Bigr\} \,\end{split}\]</div>
<p>where the first term consists of the difference between the whitened measured
data (see <a class="reference internal" href="#whitening-and-scaling"><span class="std std-ref">Whitening and scaling</span></a>) and those predicted by the model while the
second term is a weighted-norm of the current estimate. It is seen that, with
increasing <span class="math notranslate nohighlight">\(\lambda^2\)</span>, the source term receive more weight and larger
discrepancy between the measured and predicted data is tolerable.</p>
</div>
<div class="section" id="whitening-and-scaling">
<span id="id7"></span><h3>Whitening and scaling<a class="headerlink" href="#whitening-and-scaling" title="Permalink to this headline">¶</a></h3>
<p>The MNE software employs data whitening so that a ‘whitened’ inverse operator
assumes the form</p>
<div class="math notranslate nohighlight" id="equation-inv-m-tilde">
<span class="eqno">(14)<a class="headerlink" href="#equation-inv-m-tilde" title="Permalink to this equation">¶</a></span>\[\tilde{M} = M C^{^1/_2} = R \tilde{G}^\top (\tilde{G} R \tilde{G}^\top + \lambda^2 I)^{-1}\ ,\]</div>
<p>where</p>
<div class="math notranslate nohighlight" id="equation-inv-g-tilde">
<span class="eqno">(15)<a class="headerlink" href="#equation-inv-g-tilde" title="Permalink to this equation">¶</a></span>\[\tilde{G} = C^{-^1/_2}G\]</div>
<p>is the spatially whitened gain matrix. We arrive at the whitened inverse
operator equation <a class="reference internal" href="#equation-inv-m-tilde">(14)</a> by making the substitution for
<span class="math notranslate nohighlight">\(G\)</span> from <a class="reference internal" href="#equation-inv-g-tilde">(15)</a> in <a class="reference internal" href="#equation-inv-m">(13)</a> as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\tilde{M} = M C^{^1/_2} &amp;= R G^\top (G R G^\top + \lambda^2 C)^{-1} C^{^1/_2} \\
                         &amp;= R \tilde{G}^\top C^{^1/_2} (C^{^1/_2} \tilde{G} R \tilde{G}^\top C^{^1/_2} + \lambda^2 C)^{-1} C^{^1/_2} \\
                         &amp;= R \tilde{G}^\top C^{^1/_2} (C^{^1/_2} (\tilde{G} R \tilde{G}^\top + \lambda^2 I) C^{^1/_2})^{-1} C^{^1/_2} \\
                         &amp;= R \tilde{G}^\top C^{^1/_2} C^{-^1/_2} (\tilde{G} R \tilde{G}^\top + \lambda^2 I)^{-1} C^{-^1/_2} C^{^1/_2} \\
                         &amp;= R \tilde{G}^\top (\tilde{G} R \tilde{G}^\top + \lambda^2 I)^{-1}\ .\end{split}\]</div>
<p>The expected current values are</p>
<div class="math notranslate nohighlight" id="equation-inv-j-hat-t">
<span class="eqno">(16)<a class="headerlink" href="#equation-inv-j-hat-t" title="Permalink to this equation">¶</a></span>\[\begin{split} \hat{j}(t) &amp;= Mx(t) \\
            &amp;= M C^{^1/_2} C^{-^1/_2} x(t) \\
            &amp;= \tilde{M} \tilde{x}(t)\end{split}\]</div>
<p>knowing <a class="reference internal" href="#equation-inv-m-tilde">(14)</a> and taking</p>
<div class="math notranslate nohighlight" id="equation-inv-tilde-x-t">
<span class="eqno">(17)<a class="headerlink" href="#equation-inv-tilde-x-t" title="Permalink to this equation">¶</a></span>\[ \tilde{x}(t) = C^{-^1/_2}x(t)\]</div>
<p>as the whitened measurement vector at time <em>t</em>. The spatial
whitening operator <span class="math notranslate nohighlight">\(C^{-^1/_2}\)</span> is obtained with the help of the
eigenvalue decomposition
<span class="math notranslate nohighlight">\(C = U_C \Lambda_C^2 U_C^\top\)</span> as <span class="math notranslate nohighlight">\(C^{-^1/_2} = \Lambda_C^{-1} U_C^\top\)</span>.
In the MNE software the noise-covariance matrix is stored as the one applying
to raw data. To reflect the decrease of noise due to averaging, this matrix,
<span class="math notranslate nohighlight">\(C_0\)</span>, is scaled by the number of averages, <span class="math notranslate nohighlight">\(L\)</span>, <em>i.e.</em>, <span class="math notranslate nohighlight">\(C =
C_0 / L\)</span>.</p>
<p>As shown above, regularization of the inverse solution is equivalent to a
change in the variance of the current amplitudes in the Bayesian <em>a priori</em>
distribution.</p>
<p>A convenient choice for the source-covariance matrix <span class="math notranslate nohighlight">\(R\)</span> is such that
<span class="math notranslate nohighlight">\(\text{trace}(\tilde{G} R \tilde{G}^\top) / \text{trace}(I) = 1\)</span>. With this
choice we can approximate <span class="math notranslate nohighlight">\(\lambda^2 \sim 1/SNR\)</span>, where SNR is the
(power) signal-to-noise ratio of the whitened data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The definition of the signal to noise-ratio/ <span class="math notranslate nohighlight">\(\lambda^2\)</span> relationship
given above works nicely for the whitened forward solution. In the
un-whitened case scaling with the trace ratio <span class="math notranslate nohighlight">\(\text{trace}(GRG^\top) /
\text{trace}(C)\)</span> does not make sense, since the diagonal elements summed
have, in general, different units of measure. For example, the MEG data are
expressed in T or T/m whereas the unit of EEG is Volts.</p>
</div>
<p>See <a class="reference internal" href="../auto_tutorials/source-modeling/plot_compute_covariance.html#tut-compute-covariance"><span class="std std-ref">Computing a covariance matrix</span></a> for example of noise covariance computation
and whitening.</p>
</div>
<div class="section" id="regularization-of-the-noise-covariance-matrix">
<span id="cov-regularization-math"></span><h3>Regularization of the noise-covariance matrix<a class="headerlink" href="#regularization-of-the-noise-covariance-matrix" title="Permalink to this headline">¶</a></h3>
<p>Since finite amount of data is usually available to compute an estimate of the
noise-covariance matrix <span class="math notranslate nohighlight">\(C\)</span>, the smallest eigenvalues of its estimate are
usually inaccurate and smaller than the true eigenvalues. Depending on the
seriousness of this problem, the following quantities can be affected:</p>
<ul class="simple">
<li><p>The model data predicted by the current estimate,</p></li>
<li><p>Estimates of signal-to-noise ratios, which lead to estimates of the required
regularization, see <a class="reference internal" href="#mne-regularization"><span class="std std-ref">Regularization</span></a>,</p></li>
<li><p>The estimated current values, and</p></li>
<li><p>The noise-normalized estimates, see <a class="reference internal" href="#noise-normalization"><span class="std std-ref">Noise normalization</span></a>.</p></li>
</ul>
<p>Fortunately, the latter two are least likely to be affected due to
regularization of the estimates. However, in some cases especially the EEG part
of the noise-covariance matrix estimate can be deficient, <em>i.e.</em>, it may
possess very small eigenvalues and thus regularization of the noise-covariance
matrix is advisable.</p>
<p>Historically, the MNE software accomplishes the regularization by replacing a
noise-covariance matrix estimate <span class="math notranslate nohighlight">\(C\)</span> with</p>
<div class="math notranslate nohighlight">
\[C' = C + \sum_k {\varepsilon_k \bar{\sigma_k}^2 I^{(k)}}\ ,\]</div>
<p>where the index <span class="math notranslate nohighlight">\(k\)</span> goes across the different channel groups (MEG planar
gradiometers, MEG axial gradiometers and magnetometers, and EEG),
<span class="math notranslate nohighlight">\(\varepsilon_k\)</span> are the corresponding regularization factors,
<span class="math notranslate nohighlight">\(\bar{\sigma_k}\)</span> are the average variances across the channel groups, and
<span class="math notranslate nohighlight">\(I^{(k)}\)</span> are diagonal matrices containing ones at the positions
corresponding to the channels contained in each channel group.</p>
<p>See <a class="reference internal" href="../auto_tutorials/source-modeling/plot_compute_covariance.html#plot-compute-covariance-howto"><span class="std std-ref">How should I regularize the covariance matrix?</span></a> for details on computing and
regularizing the channel covariance matrix.</p>
</div>
<div class="section" id="computation-of-the-solution">
<span id="mne-solution"></span><h3>Computation of the solution<a class="headerlink" href="#computation-of-the-solution" title="Permalink to this headline">¶</a></h3>
<p>The most straightforward approach to calculate the MNE is to employ the
expression of the original or whitened inverse operator directly. However, for
computational convenience we prefer to take another route, which employs the
singular-value decomposition (SVD) of the matrix</p>
<div class="math notranslate nohighlight" id="equation-inv-a">
<span class="eqno">(18)<a class="headerlink" href="#equation-inv-a" title="Permalink to this equation">¶</a></span>\[\begin{split} A &amp;= \tilde{G} R^{^1/_2} \\
   &amp;= U \Lambda V^\top\end{split}\]</div>
<p>where the superscript <span class="math notranslate nohighlight">\(^1/_2\)</span> indicates a square root of <span class="math notranslate nohighlight">\(R\)</span>. For a
diagonal matrix, one simply takes the square root of <span class="math notranslate nohighlight">\(R\)</span> while in the
more general case one can use the Cholesky factorization <span class="math notranslate nohighlight">\(R = R_C R_C^\top\)</span>
and thus <span class="math notranslate nohighlight">\(R^{^1/_2} = R_C\)</span>.</p>
<p>Combining the SVD from <a class="reference internal" href="#equation-inv-a">(18)</a> with the inverse equation <a class="reference internal" href="#equation-inv-m">(13)</a> it is
easy to show that</p>
<div class="math notranslate nohighlight" id="equation-inv-m-tilde-svd">
<span class="eqno">(19)<a class="headerlink" href="#equation-inv-m-tilde-svd" title="Permalink to this equation">¶</a></span>\[\begin{split} \tilde{M} &amp;= R \tilde{G}^\top (\tilde{G} R \tilde{G}^\top + \lambda^2 I)^{-1} \\
           &amp;= R^{^1/_2} A^\top (A A^\top + \lambda^2 I)^{-1} \\
           &amp;= R^{^1/_2} V \Lambda U^\top (U \Lambda V^\top V \Lambda U^\top + \lambda^2 I)^{-1} \\
           &amp;= R^{^1/_2} V \Lambda U^\top (U (\Lambda^2 + \lambda^2 I) U^\top)^{-1} \\
           &amp;= R^{^1/_2} V \Lambda U^\top U (\Lambda^2 + \lambda^2 I)^{-1} U^\top \\
           &amp;= R^{^1/_2} V \Lambda (\Lambda^2 + \lambda^2 I)^{-1} U^\top \\
           &amp;= R^{^1/_2} V \Gamma U^\top\end{split}\]</div>
<p>where the elements of the diagonal matrix <span class="math notranslate nohighlight">\(\Gamma\)</span> are simply</p>
<div class="math notranslate nohighlight" id="equation-inv-gamma-k">
<span class="eqno">(20)<a class="headerlink" href="#equation-inv-gamma-k" title="Permalink to this equation">¶</a></span>\[ \gamma_k = \frac{\lambda_k}{\lambda_k^2 + \lambda^2}\ .\]</div>
<p>From our expected current equation <a class="reference internal" href="#equation-inv-j-hat-t">(16)</a> and our whitened
measurement equation <a class="reference internal" href="#equation-inv-tilde-x-t">(17)</a>, if we take</p>
<div class="math notranslate nohighlight" id="equation-inv-w-t">
<span class="eqno">(21)<a class="headerlink" href="#equation-inv-w-t" title="Permalink to this equation">¶</a></span>\[\begin{split} w(t) &amp;= U^\top \tilde{x}(t) \\
      &amp;= U^\top C^{-^1/_2} x(t)\ ,\end{split}\]</div>
<p>we can see that the expression for the expected current is just</p>
<div class="math notranslate nohighlight" id="equation-inv-j-hat-t-svd">
<span class="eqno">(22)<a class="headerlink" href="#equation-inv-j-hat-t-svd" title="Permalink to this equation">¶</a></span>\[\begin{split} \hat{j}(t) &amp;= R^{^1/_2} V \Gamma w(t) \\
            &amp;= \sum_k {\bar{v_k} \gamma_k w_k(t)}\ ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\bar{v_k} = R^{^1/_2} v_k\)</span>, with <span class="math notranslate nohighlight">\(v_k\)</span> being the
<span class="math notranslate nohighlight">\(k\)</span> th column of <span class="math notranslate nohighlight">\(V\)</span>. It is thus seen that the current estimate is
a weighted sum of the “weighted” eigenleads <span class="math notranslate nohighlight">\(v_k\)</span>.</p>
<p>It is easy to see that <span class="math notranslate nohighlight">\(w(t) \propto \sqrt{L}\)</span>. To maintain the relation
<span class="math notranslate nohighlight">\((\tilde{G} R \tilde{G}^\top) / \text{trace}(I) = 1\)</span> when <span class="math notranslate nohighlight">\(L\)</span> changes
we must have <span class="math notranslate nohighlight">\(R \propto 1/L\)</span>. With this approach, <span class="math notranslate nohighlight">\(\lambda_k\)</span> is
independent of  <span class="math notranslate nohighlight">\(L\)</span> and, for fixed <span class="math notranslate nohighlight">\(\lambda\)</span>, we see directly that
<span class="math notranslate nohighlight">\(j(t)\)</span> is independent of <span class="math notranslate nohighlight">\(L\)</span>.</p>
<p>The minimum-norm estimate is computed using this procedure in
<a class="reference internal" href="../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a>, and its usage is illustrated
in <a class="reference internal" href="cookbook.html#cihcfjei"><span class="std std-ref">Calculating the inverse operator</span></a>.</p>
</div>
<div class="section" id="noise-normalization">
<span id="id8"></span><h3>Noise normalization<a class="headerlink" href="#noise-normalization" title="Permalink to this headline">¶</a></h3>
<p>Noise normalization serves three purposes:</p>
<ul class="simple">
<li><p>It converts the expected current value into a dimensionless statistical test
variable. Thus the resulting time and location dependent values are often
referred to as dynamic statistical parameter maps (dSPM).</p></li>
<li><p>It reduces the location bias of the estimates. In particular, the tendency of
the MNE to prefer superficial currents is eliminated.</p></li>
<li><p>The width of the point-spread function becomes less dependent on the source
location on the cortical mantle. The point-spread is defined as the MNE
resulting from the signals coming from a point current source (a current
dipole) located at a certain point on the cortex.</p></li>
</ul>
<p>In practice, noise normalization is implemented as a division by the square
root of the estimated variance of each voxel. In computing these noise
normalization factors, it’s convenient to reuse our “weighted eigenleads”
definition from equation <a class="reference internal" href="#equation-inv-j-hat-t">(16)</a> in matrix form as</p>
<div class="math notranslate nohighlight" id="equation-inv-eigenleads-weighted">
<span class="eqno">(23)<a class="headerlink" href="#equation-inv-eigenleads-weighted" title="Permalink to this equation">¶</a></span>\[ \bar{V} = R^{^1/_2} V\ .\]</div>
<div class="section" id="dspm">
<h4>dSPM<a class="headerlink" href="#dspm" title="Permalink to this headline">¶</a></h4>
<p>Noise-normalized linear estimates introduced by Dale et al.
<a class="footnote-reference brackets" href="#daleetal1999" id="id9">2</a> require division of the expected current amplitude by
its variance. In practice, this requires the computation of the diagonal
elements of the following matrix, using SVD equation <a class="reference internal" href="#equation-inv-m-tilde">(14)</a> and
<a class="reference internal" href="#equation-inv-eigenleads-weighted">(23)</a>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}M C M^\top &amp;= M C^{^1/_2} C^{^1/_2} M^\top \\
        &amp;= \tilde{M} \tilde{M}^\top \\
        &amp;= R^{^1/_2} V \Gamma U^\top U \Gamma V^\top R^{^1/_2} \\
        &amp;= \bar{V} \Gamma^2 \bar{V}^\top\ .\end{split}\]</div>
<p>Because we only care about the diagonal entries here, we can find the
variances for each source as</p>
<div class="math notranslate nohighlight">
\[\sigma_k^2 = \gamma_k^2\]</div>
<p>Under the conditions expressed at the end of <a class="reference internal" href="#mne-solution"><span class="std std-ref">Computation of the solution</span></a>, it
follows that the <em>t</em>-statistic values associated with fixed-orientation
sources) are thus proportional to <span class="math notranslate nohighlight">\(\sqrt{L}\)</span> while the <em>F</em>-statistic
employed with free-orientation sources is proportional to <span class="math notranslate nohighlight">\(L\)</span>,
correspondingly.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The MNE software usually computes the <em>square roots</em> of the F-statistic to
be displayed on the inflated cortical surfaces. These are also proportional
to <span class="math notranslate nohighlight">\(\sqrt{L}\)</span>.</p>
</div>
</div>
<div class="section" id="sloreta">
<h4>sLORETA<a class="headerlink" href="#sloreta" title="Permalink to this headline">¶</a></h4>
<p>sLORETA <a class="footnote-reference brackets" href="#pascual-marqui2002" id="id10">7</a> estimates the current variances as the
diagonal entries of the
resolution matrix, which is the product of the inverse and forward operators.
In other words, the diagonal entries of (using <a class="reference internal" href="#equation-inv-m-tilde-svd">(19)</a>,
<a class="reference internal" href="#equation-inv-g-tilde">(15)</a>, and <a class="reference internal" href="#equation-inv-a">(18)</a>)</p>
<div class="math notranslate nohighlight">
\[\begin{split}M G &amp;= M C^{^1/_2} C^{-^1/_2} G \\
    &amp;= \tilde{M} \tilde{G} \\
    &amp;= R^{^1/_2} V \Gamma U^\top \tilde{G} R^{^1/_2} R^{-^1/_2} \\
    &amp;= R^{^1/_2} V \Gamma U^\top U \Lambda V^\top R^{-^1/_2} \\
    &amp;= R^{^1/_2} V \Gamma U^\top U \Lambda V^\top R^{^1/_2} R^{-1} \\
    &amp;= \bar{V} \Gamma U^\top U \Lambda \bar{V}^\top R^{-1} \\
    &amp;= \bar{V} \Gamma \Lambda \bar{V}^\top R^{-1}\ .\end{split}\]</div>
<p>Because <span class="math notranslate nohighlight">\(R\)</span> is diagonal and we only care about the diagonal entries,
we can find our variance estimates as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\sigma_k^2 &amp;= \gamma_k \lambda_k R_{k,k}^{-1} \\
           &amp;= \left(\frac{\lambda_k}{(\lambda_k^2 + \lambda^2)}\right) \left(\frac{\lambda_k}{1}\right) \left(\frac{1}{\lambda^2}\right) \\
           &amp;= \frac{\lambda_k^2}{(\lambda_k^2 + \lambda^2) \lambda^2} \\
           &amp;= \left(\frac{\lambda_k^2}{(\lambda_k^2 + \lambda^2)^2}\right) \left(\frac{\lambda^2 + \lambda_k^2}{\lambda^2}\right) \\
           &amp;= \left(\frac{\lambda_k}{\lambda_k^2 + \lambda^2}\right)^2 \left(1 + \frac{\lambda_k^2}{\lambda^2}\right) \\
           &amp;= \gamma_k^2 \left(1 + \frac{\lambda_k^2}{\lambda^2}\right)\ .\end{split}\]</div>
</div>
</div>
<div class="section" id="eloreta">
<h3>eLORETA<a class="headerlink" href="#eloreta" title="Permalink to this headline">¶</a></h3>
<p>While dSPM and sLORETA solve for noise normalization weights
<span class="math notranslate nohighlight">\(\sigma^2_k\)</span> that are applied to standard minimum-norm estimates
<span class="math notranslate nohighlight">\(\hat{j}(t)\)</span>, eLORETA <a class="footnote-reference brackets" href="#pascual-marqui2011" id="id11">4</a> instead solves for
a source covariance
matrix <span class="math notranslate nohighlight">\(R\)</span> that achieves zero localization bias. For fixed-orientation
solutions the resulting matrix <span class="math notranslate nohighlight">\(R\)</span> will be a diagonal matrix, and for
free-orientation solutions it will be a block-diagonal matrix with
<span class="math notranslate nohighlight">\(3 \times 3\)</span> blocks.</p>
<p>In <a class="footnote-reference brackets" href="#pascual-marqui2011" id="id12">4</a> eq. 2.13 states that the following system
of equations can be used to find the weights, <span class="math notranslate nohighlight">\(\forall i \in {1, ..., P}\)</span>
(note that here we represent the equations from that paper using our notation):</p>
<div class="math notranslate nohighlight">
\[r_i = \left[ G_i^\top \left( GRG^\top + \lambda^2C \right)^{-1} G_i \right] ^{-^1/_2}\]</div>
<p>And an iterative algorithm can be used to find the values for the weights
<span class="math notranslate nohighlight">\(r_i\)</span> that satisfy these equations as:</p>
<ol class="arabic simple">
<li><p>Initialize identity weights.</p></li>
<li><p>Compute <span class="math notranslate nohighlight">\(N= \left( GRG^\top + \lambda^2C \right)^{-1}\)</span>.</p></li>
<li><p>Holding <span class="math notranslate nohighlight">\(N\)</span> fixed, compute new weights <span class="math notranslate nohighlight">\(r_i = \left[ G_i^\top N G_i \right]^{-^1/_2}\)</span>.</p></li>
<li><p>Using new weights, go to step (2) until convergence.</p></li>
</ol>
<p>In particular, for step (2) we can use our substitution from <a class="reference internal" href="#equation-inv-g-tilde">(15)</a>
as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}N &amp;= (G R G^\top + \lambda^2 C)^{-1} \\
  &amp;= (C^{^1/_2} \tilde{G} R \tilde{G}^\top C^{^1/_2} + \lambda^2 C)^{-1} \\
  &amp;= (C^{^1/_2} (\tilde{G} R \tilde{G}^\top + \lambda^2 I) C^{^1/_2})^{-1} \\
  &amp;= C^{-^1/_2} (\tilde{G} R \tilde{G}^\top + \lambda^2 I)^{-1} C^{-^1/_2} \\
  &amp;= C^{-^1/_2} (\tilde{G} R \tilde{G}^\top + \lambda^2 I)^{-1} C^{-^1/_2}\ .\end{split}\]</div>
<p>Then defining <span class="math notranslate nohighlight">\(\tilde{N}\)</span> as the whitened version of <span class="math notranslate nohighlight">\(N\)</span>, i.e.,
the regularized pseudoinverse of <span class="math notranslate nohighlight">\(\tilde{G}R\tilde{G}^\top\)</span>, we can
compute <span class="math notranslate nohighlight">\(N\)</span> as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}N &amp;= C^{-^1/_2} (U_{\tilde{G}R\tilde{G}^\top} \Lambda_{\tilde{G}R\tilde{G}^\top} V_{\tilde{G}R\tilde{G}^\top}^\top + \lambda^2 I)^{-1} C^{-^1/_2} \\
  &amp;= C^{-^1/_2} (U_{\tilde{G}R\tilde{G}^\top} (\Lambda_{\tilde{G}R\tilde{G}^\top} + \lambda^2 I) V_{\tilde{G}R\tilde{G}^\top}^\top)^{-1} C^{-^1/_2} \\
  &amp;= C^{-^1/_2} V_{\tilde{G}R\tilde{G}^\top} (\Lambda_{\tilde{G}R\tilde{G}^\top} + \lambda^2 I)^{-1} U_{\tilde{G}R\tilde{G}^\top}^\top C^{-^1/_2} \\
  &amp;= C^{-^1/_2} \tilde{N} C^{-^1/_2}\ .\end{split}\]</div>
<p>In step (3) we left and right multiply with subsets of <span class="math notranslate nohighlight">\(G\)</span>, but making
the substitution <a class="reference internal" href="#equation-inv-g-tilde">(15)</a> we see that we equivalently compute:</p>
<div class="math notranslate nohighlight">
\[\begin{split}r_i &amp;= \left[ G_i^\top N G_i \right]^{-^1/_2} \\
    &amp;= \left[ (C^{^1/_2} \tilde{G}_i)^\top N C^{^1/_2} \tilde{G}_i \right]^{-^1/_2} \\
    &amp;= \left[ \tilde{G}_i^\top C^{^1/_2} N C^{^1/_2} \tilde{G}_i \right]^{-^1/_2} \\
    &amp;= \left[ \tilde{G}_i^\top C^{^1/_2} C^{-^1/_2} \tilde{N} C^{-^1/_2} C^{^1/_2} \tilde{G}_i \right]^{-^1/_2} \\
    &amp;= \left[ \tilde{G}_i^\top \tilde{N} \tilde{G}_i \right]^{-^1/_2}\ .\end{split}\]</div>
<p>For convenience, we thus never need to compute <span class="math notranslate nohighlight">\(N\)</span> itself but can instead
compute the whitened version <span class="math notranslate nohighlight">\(\tilde{N}\)</span>.</p>
</div>
<div class="section" id="predicted-data">
<h3>Predicted data<a class="headerlink" href="#predicted-data" title="Permalink to this headline">¶</a></h3>
<p>Under noiseless conditions the SNR is infinite and thus leads to
<span class="math notranslate nohighlight">\(\lambda^2 = 0\)</span> and the minimum-norm estimate explains the measured data
perfectly. Under realistic conditions, however, <span class="math notranslate nohighlight">\(\lambda^2 &gt; 0\)</span> and there
is a misfit between measured data and those predicted by the MNE. Comparison of
the predicted data, here denoted by <span class="math notranslate nohighlight">\(x(t)\)</span>, and measured one can give
valuable insight on the correctness of the regularization applied.</p>
<p>In the SVD approach we easily find</p>
<div class="math notranslate nohighlight">
\[\hat{x}(t) = G \hat{j}(t) = C^{^1/_2} U \Pi w(t)\ ,\]</div>
<p>where the diagonal matrix <span class="math notranslate nohighlight">\(\Pi\)</span> has elements <span class="math notranslate nohighlight">\(\pi_k = \lambda_k
\gamma_k\)</span> The predicted data is thus expressed as the weighted sum of the
‘recolored eigenfields’ in <span class="math notranslate nohighlight">\(C^{^1/_2} U\)</span>.</p>
</div>
<div class="section" id="cortical-patch-statistics">
<h3>Cortical patch statistics<a class="headerlink" href="#cortical-patch-statistics" title="Permalink to this headline">¶</a></h3>
<p>If the <code class="docutils literal notranslate"><span class="pre">add_dists=True</span></code> option was used in source space creation,
the source space file will contain
Cortical Patch Statistics (CPS) for each vertex of the cortical surface. The
CPS provide information about the source space point closest to it as well as
the distance from the vertex to this source space point. The vertices for which
a given source space point is the nearest one define the cortical patch
associated with with the source space point. Once these data are available, it
is straightforward to compute the following cortical patch statistics for each
source location <span class="math notranslate nohighlight">\(d\)</span>:</p>
<ul class="simple">
<li><p>The average over the normals of at the vertices in a patch,
<span class="math notranslate nohighlight">\(\bar{n_d}\)</span>,</p></li>
<li><p>The areas of the patches, <span class="math notranslate nohighlight">\(A_d\)</span>, and</p></li>
<li><p>The average deviation of the vertex normals in a patch from their average,
<span class="math notranslate nohighlight">\(\sigma_d\)</span>, given in degrees.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">use_cps</span></code> parameter in <a class="reference internal" href="../generated/mne.convert_forward_solution.html#mne.convert_forward_solution" title="mne.convert_forward_solution"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.convert_forward_solution()</span></code></a>, and
<a class="reference internal" href="../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a> controls whether to use
cortical patch statistics (CPS) to define normal orientations or not (see
<a class="reference internal" href="cookbook.html#chdbbcej"><span class="std std-ref">Cortical surface reconstruction with FreeSurfer</span></a>).</p>
</div>
<div class="section" id="orientation-constraints">
<span id="inverse-orientation-constraints"></span><h3>Orientation constraints<a class="headerlink" href="#orientation-constraints" title="Permalink to this headline">¶</a></h3>
<p>The principal sources of MEG and EEG signals are generally believed to be
postsynaptic currents in the cortical pyramidal neurons. Since the net primary
current associated with these microscopic events is oriented normal to the
cortical mantle, it is reasonable to use the cortical normal orientation as a
constraint in source estimation. In addition to allowing completely free source
orientations, the MNE software implements three orientation constraints based
of the surface normal data:</p>
<ul class="simple">
<li><p>Source orientation can be rigidly fixed to the surface normal direction by
specifying <code class="docutils literal notranslate"><span class="pre">fixed=True</span></code> in <a class="reference internal" href="../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a>.
If cortical patch statistics are available the average
normal over each patch, <span class="math notranslate nohighlight">\(\bar{n_d}\)</span>, are used to define the source
orientation. Otherwise, the vertex normal at the source space location is
employed.</p></li>
<li><p>A <em>location independent or fixed loose orientation constraint</em> (fLOC) can be
employed by specifying <code class="docutils literal notranslate"><span class="pre">fixed=False</span></code> and <code class="docutils literal notranslate"><span class="pre">loose=1.0</span></code> when
calling <a class="reference internal" href="../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a> (see
<a class="reference internal" href="../auto_tutorials/source-modeling/plot_dipole_orientations.html#plot-dipole-orientations-floc-orientations"><span class="std std-ref">Loose dipole orientations</span></a>).
In this approach, a source coordinate
system based on the local surface orientation at the source location is
employed. By default, the three columns of the gain matrix G, associated with
a given source location, are the fields of unit dipoles pointing to the
directions of the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, and <span class="math notranslate nohighlight">\(z\)</span> axis of the coordinate
system employed in the forward calculation (usually the <a class="reference internal" href="#head-device-coords"><span class="std std-ref">MEG head
coordinate frame</span></a>). For LOC the orientation is changed so
that the first two source components lie in the plane normal to the surface
normal at the source location and the third component is aligned with it.
Thereafter, the variance of the source components tangential to the cortical
surface are reduced by a factor defined by the <code class="docutils literal notranslate"><span class="pre">--loose</span></code> option.</p></li>
<li><p>A <em>variable loose orientation constraint</em> (vLOC) can be employed by
specifying <code class="docutils literal notranslate"><span class="pre">fixed=False</span></code> and <code class="docutils literal notranslate"><span class="pre">loose</span></code> parameters when calling
<a class="reference internal" href="../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a> (see
<a class="reference internal" href="../auto_tutorials/source-modeling/plot_dipole_orientations.html#plot-dipole-orientations-vloc-orientations"><span class="std std-ref">Limiting orientations, but not fixing them</span></a>). This
is similar to <em>fLOC</em> except that the value given with the <code class="docutils literal notranslate"><span class="pre">loose</span></code>
parameter will be multiplied by <span class="math notranslate nohighlight">\(\sigma_d\)</span>, defined above.</p></li>
</ul>
</div>
<div class="section" id="depth-weighting">
<h3>Depth weighting<a class="headerlink" href="#depth-weighting" title="Permalink to this headline">¶</a></h3>
<p>The minimum-norm estimates have a bias towards superficial currents. This
tendency can be alleviated by adjusting the source covariance matrix <span class="math notranslate nohighlight">\(R\)</span>
to favor deeper source locations. In the depth weighting scheme employed in MNE
analyze, the elements of <span class="math notranslate nohighlight">\(R\)</span> corresponding to the <span class="math notranslate nohighlight">\(p\)</span> th source
location are be scaled by a factor</p>
<div class="math notranslate nohighlight">
\[f_p = (g_{1p}^\top g_{1p} + g_{2p}^\top g_{2p} + g_{3p}^\top g_{3p})^{-\gamma}\ ,\]</div>
<p>where <span class="math notranslate nohighlight">\(g_{1p}\)</span>, <span class="math notranslate nohighlight">\(g_{2p}\)</span>, and <span class="math notranslate nohighlight">\(g_{3p}\)</span> are the three columns
of <span class="math notranslate nohighlight">\(G\)</span> corresponding to source location <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(\gamma\)</span> is
the order of the depth weighting, which is specified via the <code class="docutils literal notranslate"><span class="pre">depth</span></code> option
in <a class="reference internal" href="../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a>.</p>
</div>
<div class="section" id="effective-number-of-averages">
<h3>Effective number of averages<a class="headerlink" href="#effective-number-of-averages" title="Permalink to this headline">¶</a></h3>
<p>It is often the case that the epoch to be analyzed is a linear combination over
conditions rather than one of the original averages computed. As stated above,
the noise-covariance matrix computed is originally one corresponding to raw
data. Therefore, it has to be scaled correctly to correspond to the actual or
effective number of epochs in the condition to be analyzed. In general, we have</p>
<div class="math notranslate nohighlight">
\[C = C_0 / L_{eff}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{eff}\)</span> is the effective number of averages. To calculate
<span class="math notranslate nohighlight">\(L_{eff}\)</span> for an arbitrary linear combination of conditions</p>
<div class="math notranslate nohighlight">
\[y(t) = \sum_{i = 1}^n {w_i x_i(t)}\]</div>
<p>we make use of the the fact that the noise-covariance matrix</p>
<div class="math notranslate nohighlight">
\[C_y = \sum_{i = 1}^n {w_i^2 C_{x_i}} = C_0 \sum_{i = 1}^n {w_i^2 / L_i}\]</div>
<p>which leads to</p>
<div class="math notranslate nohighlight">
\[1 / L_{eff} = \sum_{i = 1}^n {w_i^2 / L_i}\]</div>
<p>An important special case  of the above is a weighted average, where</p>
<div class="math notranslate nohighlight">
\[w_i = L_i / \sum_{i = 1}^n {L_i}\]</div>
<p>and, therefore</p>
<div class="math notranslate nohighlight">
\[L_{eff} = \sum_{i = 1}^n {L_i}\]</div>
<p>Instead of a weighted average, one often computes a weighted sum, a simplest
case being a difference or sum of two categories. For a difference <span class="math notranslate nohighlight">\(w_1 =
1\)</span> and <span class="math notranslate nohighlight">\(w_2 = -1\)</span> and thus</p>
<div class="math notranslate nohighlight">
\[1 / L_{eff} = 1 / L_1 + 1 / L_2\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[L_{eff} = \frac{L_1 L_2}{L_1 + L_2}\]</div>
<p>Interestingly, the same holds for a sum, where <span class="math notranslate nohighlight">\(w_1 = w_2 = 1\)</span>.
Generalizing, for any combination of sums and differences, where <span class="math notranslate nohighlight">\(w_i =
1\)</span> or <span class="math notranslate nohighlight">\(w_i = -1\)</span>, <span class="math notranslate nohighlight">\(i = 1 \dotso n\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[1 / L_{eff} = \sum_{i = 1}^n {1/{L_i}}\]</div>
</div>
</div>
<div class="section" id="morphing-and-averaging-source-estimates">
<span id="ch-morph"></span><h2><a class="toc-backref" href="#id32">Morphing and averaging source estimates</a><a class="headerlink" href="#morphing-and-averaging-source-estimates" title="Permalink to this headline">¶</a></h2>
<div class="section" id="why-morphing">
<h3>Why morphing?<a class="headerlink" href="#why-morphing" title="Permalink to this headline">¶</a></h3>
<div class="sidebar">
<p class="sidebar-title">Morphing examples in MNE-Python</p>
<p>Examples of morphing in MNE-Python include <a class="reference internal" href="../auto_tutorials/source-modeling/plot_mne_solutions.html#tut-mne-fixed-free"><span class="std std-ref">this tutorial</span></a> on surface source estimation or these examples on
<a class="reference internal" href="../auto_examples/inverse/plot_morph_surface_stc.html#ex-morph-surface"><span class="std std-ref">surface</span></a> and <a class="reference internal" href="../auto_examples/inverse/plot_morph_volume_stc.html#ex-morph-volume"><span class="std std-ref">volumetric</span></a>
source estimation.</p>
</div>
<p>Modern neuroimaging techniques, such as source reconstruction or fMRI analyses,
make use of advanced mathematical models and hardware to map brain activity
patterns into a subject-specific anatomical brain space. This enables the study
of spatio-temporal brain activity. The representation of spatio-temporal brain
data is often mapped onto the anatomical brain structure to relate functional
and anatomical maps. Thereby activity patterns are overlaid with anatomical
locations that supposedly produced the activity. Anatomical MR images are often
used as such or are transformed into an inflated surface representations to
serve as  “canvas” for the visualization.</p>
<p>In order to compute group-level statistics, data representations across
subjects must be morphed to a common frame, such that anatomically and
functional similar structures are represented at the same spatial location for
<em>all subjects equally</em>. Since brains vary, <a class="reference internal" href="../glossary.html#term-morphing"><span class="xref std std-term">morphing</span></a> comes into play to
tell us how the data produced by subject A would be represented on the brain of
subject B (and vice-versa).</p>
</div>
<div class="section" id="the-morphing-maps">
<h3>The morphing maps<a class="headerlink" href="#the-morphing-maps" title="Permalink to this headline">¶</a></h3>
<p>The MNE software accomplishes morphing with help of morphing maps.
The morphing is performed with help of the registered
spherical surfaces (<code class="docutils literal notranslate"><span class="pre">lh.sphere.reg</span></code> and <code class="docutils literal notranslate"><span class="pre">rh.sphere.reg</span></code> ) which must be
produced in FreeSurfer. A morphing map is a linear mapping from cortical
surface values in subject A (<span class="math notranslate nohighlight">\(x^{(A)}\)</span>) to those in another subject B
(<span class="math notranslate nohighlight">\(x^{(B)}\)</span>)</p>
<div class="math notranslate nohighlight">
\[x^{(B)} = M^{(AB)} x^{(A)}\ ,\]</div>
<p>where <span class="math notranslate nohighlight">\(M^{(AB)}\)</span> is a sparse matrix with at most three nonzero elements
on each row. These elements are determined as follows. First, using the aligned
spherical surfaces, for each vertex <span class="math notranslate nohighlight">\(x_j^{(B)}\)</span>, find the triangle
<span class="math notranslate nohighlight">\(T_j^{(A)}\)</span> on the spherical surface of subject A which contains the
location <span class="math notranslate nohighlight">\(x_j^{(B)}\)</span>. Next, find the numbers of the vertices of this
triangle and set the corresponding elements on the <em>j</em> th row of
<span class="math notranslate nohighlight">\(M^{(AB)}\)</span> so that <span class="math notranslate nohighlight">\(x_j^{(B)}\)</span> will be a linear interpolation
between the triangle vertex values reflecting the location <span class="math notranslate nohighlight">\(x_j^{(B)}\)</span>
within the triangle <span class="math notranslate nohighlight">\(T_j^{(A)}\)</span>.</p>
<p>It follows from the above definition that in general</p>
<div class="math notranslate nohighlight">
\[M^{(AB)} \neq (M^{(BA)})^{-1}\ ,\]</div>
<p><em>i.e.</em>,</p>
<div class="math notranslate nohighlight">
\[x_{(A)} \neq M^{(BA)} M^{(AB)} x^{(A)}\ ,\]</div>
<p>even if</p>
<div class="math notranslate nohighlight">
\[x^{(A)} \approx M^{(BA)} M^{(AB)} x^{(A)}\ ,\]</div>
<p><em>i.e.</em>, the mapping is <em>almost</em> a bijection.</p>
</div>
<div class="section" id="about-smoothing">
<h3>About smoothing<a class="headerlink" href="#about-smoothing" title="Permalink to this headline">¶</a></h3>
<p>The current estimates are normally defined only in a decimated grid which is a
sparse subset of the vertices in the triangular tessellation of the cortical
surface. Therefore, any sparse set of values is distributed to neighboring
vertices to make the visualized results easily understandable. This procedure
has been traditionally called smoothing but a more appropriate name might be
smudging or blurring in accordance with similar operations in image processing
programs.</p>
<p>In MNE software terms, smoothing of the vertex data is an iterative procedure,
which produces a blurred image <span class="math notranslate nohighlight">\(x^{(N)}\)</span> from the original sparse image
<span class="math notranslate nohighlight">\(x^{(0)}\)</span> by applying in each iteration step a sparse blurring matrix:</p>
<div class="math notranslate nohighlight">
\[x^{(p)} = S^{(p)} x^{(p - 1)}\ .\]</div>
<p>On each row <span class="math notranslate nohighlight">\(j\)</span> of the matrix <span class="math notranslate nohighlight">\(S^{(p)}\)</span> there are <span class="math notranslate nohighlight">\(N_j^{(p -
1)}\)</span> nonzero entries whose values equal <span class="math notranslate nohighlight">\(1/N_j^{(p - 1)}\)</span>. Here
<span class="math notranslate nohighlight">\(N_j^{(p - 1)}\)</span> is the number of immediate neighbors of vertex <span class="math notranslate nohighlight">\(j\)</span>
which had non-zero values at iteration step <span class="math notranslate nohighlight">\(p - 1\)</span>. Matrix
<span class="math notranslate nohighlight">\(S^{(p)}\)</span> thus assigns the average of the non-zero neighbors as the new
value for vertex <span class="math notranslate nohighlight">\(j\)</span>. One important feature of this procedure is that it
tends to preserve the amplitudes while blurring the surface image.</p>
<p>Once the indices non-zero vertices in <span class="math notranslate nohighlight">\(x^{(0)}\)</span> and the topology of the
triangulation are fixed the matrices <span class="math notranslate nohighlight">\(S^{(p)}\)</span> are fixed and independent
of the data. Therefore, it would be in principle possible to construct a
composite blurring matrix</p>
<div class="math notranslate nohighlight">
\[S^{(N)} = \prod_{p = 1}^N {S^{(p)}}\ .\]</div>
<p>However, it turns out to be computationally more effective to do blurring with
an iteration. The above formula for <span class="math notranslate nohighlight">\(S^{(N)}\)</span> also shows that the
smudging (smoothing) operation is linear.</p>
</div>
</div>
<div class="section" id="references">
<h2><a class="toc-backref" href="#id33">References</a><a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p id="bibtex-footbibliography-overview/implementation-0"><dl class="footnote brackets">
<dt class="label" id="bergscherg1994"><span class="brackets"><a class="fn-backref" href="#id6">1</a></span></dt>
<dd><p>Patrick Berg and Michael Scherg. A fast method for forward computation of multiple-shell spherical head models. <em>Electroencephalography and Clinical Neurophysiology</em>, 90(1):58–64, 1994. <a class="reference external" href="https://doi.org/10.1016/0013-4694(94)90113-9">doi:10.1016/0013-4694(94)90113-9</a>.</p>
</dd>
<dt class="label" id="daleetal1999"><span class="brackets"><a class="fn-backref" href="#id9">2</a></span></dt>
<dd><p>Anders M. Dale, Bruce Fischl, and Martin I. Sereno. Cortical surface-based analysis: I. segmentation and surface reconstruction. <em>NeuroImage</em>, 9(2):179–194, 1999. <a class="reference external" href="https://doi.org/10.1006/nimg.1998.0395">doi:10.1006/nimg.1998.0395</a>.</p>
</dd>
<dt class="label" id="mosheretal1999"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>John C. Mosher, Richard M. Leahy, and Paul S. Lewis. EEG and MEG: forward solutions for inverse methods. <em>IEEE Transactions on Biomedical Engineering</em>, 46(3):245–259, 1999. <a class="reference external" href="https://doi.org/10.1109/10.748978">doi:10.1109/10.748978</a>.</p>
</dd>
<dt class="label" id="pascual-marqui2011"><span class="brackets">4</span><span class="fn-backref">(<a href="#id11">1</a>,<a href="#id12">2</a>)</span></dt>
<dd><p>Roberto D. Pascual-Marqui, Dietrich Lehmann, Martha Koukkou, Kieko Kochi, Peter Anderer, Bernd Saletu, Hideaki Tanaka, Koichi Hirata, E. Roy John, Leslie Prichep, Rolando Biscay-Lirio, and Toshihiko Kinoshita. Assessing interactions in the brain with exact low-resolution electromagnetic tomography. <em>Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences</em>, 369(1952):3768–3784, October 2011. URL: <a class="reference external" href="https://royalsocietypublishing.org/doi/full/10.1098/rsta.2011.0081">https://royalsocietypublishing.org/doi/full/10.1098/rsta.2011.0081</a>, <a class="reference external" href="https://doi.org/10.1098/rsta.2011.0081">doi:10.1098/rsta.2011.0081</a>.</p>
</dd>
<dt class="label" id="perrinetal1989"><span class="brackets"><a class="fn-backref" href="#id1">5</a></span></dt>
<dd><p>François M. Perrin, Jacques Pernier, Olivier M. Bertrand, and Jean Franćois Echallier. Spherical splines for scalp potential and current density mapping. <em>Electroencephalography and Clinical Neurophysiology</em>, 72(2):184–187, 1989. <a class="reference external" href="https://doi.org/10.1016/0013-4694(89)90180-6">doi:10.1016/0013-4694(89)90180-6</a>.</p>
</dd>
<dt class="label" id="zhang1995"><span class="brackets"><a class="fn-backref" href="#id5">6</a></span></dt>
<dd><p>Zhi Zhang. A fast method to compute surface potentials generated by dipoles within multilayer anisotropic spheres. <em>Physics in Medicine and Biology</em>, 40(3):335–349, 1995. <a class="reference external" href="https://doi.org/10.1088/0031-9155/40/3/001">doi:10.1088/0031-9155/40/3/001</a>.</p>
</dd>
<dt class="label" id="pascual-marqui2002"><span class="brackets"><a class="fn-backref" href="#id10">7</a></span></dt>
<dd><p>Roberto D. Pascual-Marqui. Standardized low-resolution brain electromagnetic tomography (sLORETA): technical details. <em>Methods and Findings in Experimental and Clinical Pharmacology</em>, 24(D):5–12, 2002.</p>
</dd>
</dl>
</p>
</div>
</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container"><div class="row">
    <div class="container col-md-12 institutions">
      <ul class="list-unstyled">
        <li><a href="https://www.massgeneral.org/"><img class="institution" src="../_static/institution_logos/MGH.svg" title="Massachusetts General Hospital" alt="Massachusetts General Hospital"/></a></li>
        <li><a href="https://martinos.org/"><img class="institution" src="../_static/institution_logos/Martinos.png" title="Athinoula A. Martinos Center for Biomedical Imaging" alt="Athinoula A. Martinos Center for Biomedical Imaging"/></a></li>
        <li><a href="https://hms.harvard.edu/"><img class="institution" src="../_static/institution_logos/Harvard.png" title="Harvard Medical School" alt="Harvard Medical School"/></a></li>
        <li><a href="https://web.mit.edu/"><img class="institution" src="../_static/institution_logos/MIT.svg" title="Massachusetts Institute of Technology" alt="Massachusetts Institute of Technology"/></a></li>
        <li><a href="https://www.nyu.edu/"><img class="institution" src="../_static/institution_logos/NYU.png" title="New York University" alt="New York University"/></a></li>
        <li><a href="http://www.cea.fr/"><img class="institution" src="../_static/institution_logos/CEA.png" title="Commissariat à l´énergie atomique et aux énergies alternatives" alt="Commissariat à l´énergie atomique et aux énergies alternatives"/></a></li>
        <li><a href="https://sci.aalto.fi/"><img class="institution" src="../_static/institution_logos/Aalto.svg" title="Aalto-yliopiston perustieteiden korkeakoulu" alt="Aalto-yliopiston perustieteiden korkeakoulu"/></a></li>
        <li><a href="https://www.telecom-paris.fr/"><img class="institution" src="../_static/institution_logos/Telecom_Paris_Tech.png" title="Télécom ParisTech" alt="Télécom ParisTech"/></a></li>
        <li><a href="https://www.washington.edu/"><img class="institution" src="../_static/institution_logos/Washington.png" title="University of Washington" alt="University of Washington"/></a></li>
        <li><a href="https://icm-institute.org/"><img class="institution" src="../_static/institution_logos/ICM.jpg" title="Institut du Cerveau et de la Moelle épinière" alt="Institut du Cerveau et de la Moelle épinière"/></a></li>
        <li><a href="https://www.bu.edu/"><img class="institution" src="../_static/institution_logos/BU.svg" title="Boston University" alt="Boston University"/></a></li>
        <li><a href="https://www.inserm.fr/"><img class="institution" src="../_static/institution_logos/Inserm.svg" title="Institut national de la santé et de la recherche médicale" alt="Institut national de la santé et de la recherche médicale"/></a></li>
        <li><a href="https://www.fz-juelich.de/"><img class="institution" src="../_static/institution_logos/Julich.svg" title="Forschungszentrum Jülich" alt="Forschungszentrum Jülich"/></a></li>
        <li><a href="https://www.tu-ilmenau.de/"><img class="institution" src="../_static/institution_logos/Ilmenau.gif" title="Technische Universität Ilmenau" alt="Technische Universität Ilmenau"/></a></li>
        <li><a href="https://bids.berkeley.edu/"><img class="institution" src="../_static/institution_logos/BIDS.png" title="Berkeley Institute for Data Science" alt="Berkeley Institute for Data Science"/></a></li>
        <li><a href="https://www.inria.fr/"><img class="institution" src="../_static/institution_logos/inria.png" title="Institut national de recherche en informatique et en automatique" alt="Institut national de recherche en informatique et en automatique"/></a></li>
        <li><a href="https://www.au.dk/"><img class="institution" src="../_static/institution_logos/Aarhus.png" title="Aarhus Universitet" alt="Aarhus Universitet"/></a></li>
        <li><a href="https://www.uni-graz.at/"><img class="institution" src="../_static/institution_logos/Graz.jpg" title="Karl-Franzens-Universität Graz" alt="Karl-Franzens-Universität Graz"/></a></li>
      </ul>
      <p class="text-center text-muted small">&copy; Copyright 2012-2020, MNE Developers. Last updated on 2020-03-27.</p>
    </div></div></div>
  </footer>
  <script src="https://mne.tools/versionwarning.js"></script>
  </body>
</html>