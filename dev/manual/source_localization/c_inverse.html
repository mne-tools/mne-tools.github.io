<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>The minimum-norm current estimates &#8212; MNE 0.18.dev0 documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/reset-syntax.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />

    <script type="text/javascript" src="../../_static/copybutton.js"></script>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>


    <link rel="stylesheet" href="../../_static/style.css " type="text/css" />
    <link rel="stylesheet" href="../../_static/font-awesome.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/flag-icon.css" type="text/css" />



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>


  </head><body>

<div class="row devbar alert alert-danger">
This documentation is for <strong>development version 0.18.dev0</strong>.
</div>





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/mne_logo_small.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.18.dev0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../getting_started.html">Install</a></li>
                <li><a href="../../documentation.html">Documentation</a></li>
                <li><a href="../../python_reference.html">API</a></li>
                <li><a href="../../glossary.html">Glossary</a></li>
                <li><a href="../../auto_examples/index.html">Examples</a></li>
                <li><a href="../../contributing.html">Contribute</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
<div class="navbar-form navbar-right navbar-btn dropdown btn-group-sm" style="margin-left: 20px; margin-top: 5px; margin-bottom: 5px">
  <button type="button" class="btn btn-danger navbar-btn dropdown-toggle" id="dropdownMenu1" data-toggle="dropdown">
    v0.18.dev0
    <span class="caret"></span>
  </button>
  <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
    <li><a href="https://mne-tools.github.io/dev/index.html">Development</a></li>
    <li><a href="https://mne-tools.github.io/stable/index.html">v0.17 (stable)</a></li>
    <li><a href="https://mne-tools.github.io/0.16/index.html">v0.16</a></li>
    <li><a href="https://mne-tools.github.io/0.15/index.html">v0.15</a></li>
    <li><a href="https://mne-tools.github.io/0.14/index.html">v0.14</a></li>
    <li><a href="https://mne-tools.github.io/0.13/index.html">v0.13</a></li>
    <li><a href="https://mne-tools.github.io/0.12/index.html">v0.12</a></li>
    <li><a href="https://mne-tools.github.io/0.11/index.html">v0.11</a></li>
  </ul>
</div>


            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          

        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/mne_logo_small.png" alt="Logo"/>
            </a></p><ul>
<li><a class="reference internal" href="#">The minimum-norm current estimates</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#minimum-norm-estimates">Minimum-norm estimates</a><ul>
<li><a class="reference internal" href="#the-linear-inverse-operator">The linear inverse operator</a></li>
<li><a class="reference internal" href="#regularization">Regularization</a></li>
<li><a class="reference internal" href="#whitening-and-scaling">Whitening and scaling</a></li>
<li><a class="reference internal" href="#regularization-of-the-noise-covariance-matrix">Regularization of the noise-covariance matrix</a></li>
<li><a class="reference internal" href="#computation-of-the-solution">Computation of the solution</a></li>
<li><a class="reference internal" href="#noise-normalization">Noise normalization</a></li>
<li><a class="reference internal" href="#predicted-data">Predicted data</a></li>
<li><a class="reference internal" href="#cortical-patch-statistics">Cortical patch statistics</a></li>
<li><a class="reference internal" href="#the-orientation-constraints">The orientation constraints</a></li>
<li><a class="reference internal" href="#depth-weighting">Depth weighting</a></li>
<li><a class="reference internal" href="#fmri-guided-estimates">fMRI-guided estimates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#effective-number-of-averages">Effective number of averages</a></li>
<li><a class="reference internal" href="#inverse-operator-decomposition">Inverse-operator decomposition</a></li>
<li><a class="reference internal" href="#producing-movies-and-snapshots">Producing movies and snapshots</a></li>
<li><a class="reference internal" href="#computing-inverse-from-raw-and-evoked-data">Computing inverse from raw and evoked data</a><ul>
<li><a class="reference internal" href="#implementation-details">Implementation details</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<form action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-12 content">
      
  <div class="section" id="the-minimum-norm-current-estimates">
<span id="c-legacy-ch-mne"></span><h1>The minimum-norm current estimates<a class="headerlink" href="#the-minimum-norm-current-estimates" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id1">Overview</a></li>
<li><a class="reference internal" href="#minimum-norm-estimates" id="id2">Minimum-norm estimates</a><ul>
<li><a class="reference internal" href="#the-linear-inverse-operator" id="id3">The linear inverse operator</a></li>
<li><a class="reference internal" href="#regularization" id="id4">Regularization</a></li>
<li><a class="reference internal" href="#whitening-and-scaling" id="id5">Whitening and scaling</a></li>
<li><a class="reference internal" href="#regularization-of-the-noise-covariance-matrix" id="id6">Regularization of the noise-covariance matrix</a></li>
<li><a class="reference internal" href="#computation-of-the-solution" id="id7">Computation of the solution</a></li>
<li><a class="reference internal" href="#noise-normalization" id="id8">Noise normalization</a></li>
<li><a class="reference internal" href="#predicted-data" id="id9">Predicted data</a></li>
<li><a class="reference internal" href="#cortical-patch-statistics" id="id10">Cortical patch statistics</a></li>
<li><a class="reference internal" href="#the-orientation-constraints" id="id11">The orientation constraints</a></li>
<li><a class="reference internal" href="#depth-weighting" id="id12">Depth weighting</a></li>
<li><a class="reference internal" href="#fmri-guided-estimates" id="id13">fMRI-guided estimates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#effective-number-of-averages" id="id14">Effective number of averages</a></li>
<li><a class="reference internal" href="#inverse-operator-decomposition" id="id15">Inverse-operator decomposition</a></li>
<li><a class="reference internal" href="#producing-movies-and-snapshots" id="id16">Producing movies and snapshots</a></li>
<li><a class="reference internal" href="#computing-inverse-from-raw-and-evoked-data" id="id17">Computing inverse from raw and evoked data</a><ul>
<li><a class="reference internal" href="#implementation-details" id="id18">Implementation details</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id1">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>This page describes the mathematical concepts and the
computation of the minimum-norm estimates.
Using the UNIX commands this is accomplished with two programs:
<a class="reference internal" href="../c_reference.html#mne-inverse-operator"><span class="std std-ref">mne_inverse_operator</span></a> and <a class="reference internal" href="../c_reference.html#mne-make-movie"><span class="std std-ref">mne_make_movie</span></a> or in Python
using <a class="reference internal" href="../../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a>
and the <code class="docutils literal notranslate"><span class="pre">apply</span></code> functions. The use of these functions is
presented in the tutorial
<a class="reference internal" href="../../auto_tutorials/plot_mne_dspm_source_localization.html#sphx-glr-auto-tutorials-plot-mne-dspm-source-localization-py"><span class="std std-ref">Source localization with MNE/dSPM/sLORETA/eLORETA</span></a>.</p>
<p>The page starts with a mathematical description of the method.
The interactive program for inspecting data and inverse solutions,
<a class="reference internal" href="../c_reference.html#mne-analyze"><span class="std std-ref">mne_analyze</span></a>, is covered in <a class="reference internal" href="../gui/analyze.html#c-legacy-ch-interactive-analysis"><span class="std std-ref">Interactive analysis with mne_analyze</span></a>.</p>
</div>
<div class="section" id="minimum-norm-estimates">
<span id="c-legacy-cbbdjfbj"></span><h2><a class="toc-backref" href="#id2">Minimum-norm estimates</a><a class="headerlink" href="#minimum-norm-estimates" title="Permalink to this headline">¶</a></h2>
<p>This section describes the mathematical details of the calculation
of minimum-norm estimates. In Bayesian sense, the ensuing current
distribution is the maximum a posteriori (MAP) estimate under the
following assumptions:</p>
<ul class="simple">
<li>The viable locations of the currents
are constrained to the cortex. Optionally, the current orientations
can be fixed to be normal to the cortical mantle.</li>
<li>The amplitudes of the currents have a Gaussian prior distribution
with a known source covariance matrix.</li>
<li>The measured data contain additive noise with a Gaussian distribution with
a known covariance matrix. The noise is not correlated over time.</li>
</ul>
<div class="section" id="the-linear-inverse-operator">
<h3><a class="toc-backref" href="#id3">The linear inverse operator</a><a class="headerlink" href="#the-linear-inverse-operator" title="Permalink to this headline">¶</a></h3>
<p>The measured data in the source estimation procedure consists
of MEG and EEG data, recorded on a total of N channels. The task
is to estimate a total of M strengths of sources located on the
cortical mantle. If the number of source locations is P, M = P for
fixed-orientation sources and M = 3P if the source orientations
are unconstrained. The regularized linear inverse operator following
from the Bayesian approach is given by the <span class="math notranslate nohighlight">\(M \times N\)</span> matrix</p>
<div class="math notranslate nohighlight">
\[M = R' G^T (G R' G^T + C)^{-1}\ ,\]</div>
<p>where G is the gain matrix relating the source strengths
to the measured MEG/EEG data, <span class="math notranslate nohighlight">\(C\)</span> is the data noise-covariance matrix
and <span class="math notranslate nohighlight">\(R'\)</span> is the source covariance matrix.
The dimensions of these matrices are <span class="math notranslate nohighlight">\(N \times M\)</span>, <span class="math notranslate nohighlight">\(N \times N\)</span>,
and <span class="math notranslate nohighlight">\(M \times M\)</span>, respectively. The <span class="math notranslate nohighlight">\(M \times 1\)</span> source-strength
vector is obtained by multiplying the <span class="math notranslate nohighlight">\(N \times 1\)</span> data
vector by <span class="math notranslate nohighlight">\(M\)</span>.</p>
<p>The expected value of the current amplitudes at time <em>t</em> is
then given by <span class="math notranslate nohighlight">\(\hat{j}(t) = Mx(t)\)</span>, where <span class="math notranslate nohighlight">\(x(t)\)</span> is
a vector containing the measured MEG and EEG data values at time <em>t</em>.</p>
</div>
<div class="section" id="regularization">
<span id="c-legacy-mne-regularization"></span><h3><a class="toc-backref" href="#id4">Regularization</a><a class="headerlink" href="#regularization" title="Permalink to this headline">¶</a></h3>
<p>The a priori variance of the currents is, in practise, unknown.
We can express this by writing <span class="math notranslate nohighlight">\(R' = R/ \lambda^2\)</span>,
which yields the inverse operator</p>
<div class="math notranslate nohighlight">
\[M = R G^T (G R G^T + \lambda^2 C)^{-1}\ ,\]</div>
<p>where the unknown current amplitude is now interpreted in
terms of the regularization parameter <span class="math notranslate nohighlight">\(\lambda^2\)</span>.
Small <span class="math notranslate nohighlight">\(\lambda^2\)</span> corresponds to large current amplitudes
and complex estimate current patterns while a large <span class="math notranslate nohighlight">\(\lambda^2\)</span> means the
amplitude of the current is limited and a simpler, smooth, current
estimate is obtained.</p>
<p>We can arrive in the regularized linear inverse operator
also by minimizing the cost function</p>
<div class="math notranslate nohighlight">
\[S = \tilde{e}^T \tilde{e} + \lambda^2 j^T R^{-1} j\ ,\]</div>
<p>where the first term consists of the difference between the
whitened measured data (see <a class="reference internal" href="#c-legacy-chddhage"><span class="std std-ref">Whitening and scaling</span></a>) and those predicted
by the model while the second term is a weighted-norm of the current
estimate. It is seen that, with increasing <span class="math notranslate nohighlight">\(\lambda^2\)</span>,
the source term receive more weight and larger discrepancy between
the measured and predicted data is tolerable.</p>
</div>
<div class="section" id="whitening-and-scaling">
<span id="c-legacy-chddhage"></span><h3><a class="toc-backref" href="#id5">Whitening and scaling</a><a class="headerlink" href="#whitening-and-scaling" title="Permalink to this headline">¶</a></h3>
<p>The MNE software employs data whitening so that a ‘whitened’ inverse operator
assumes the form</p>
<div class="math notranslate nohighlight">
\[\tilde{M} = R \tilde{G}^T (\tilde{G} R \tilde{G}^T + I)^{-1}\ ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\tilde{G} = C^{-^1/_2}G\)</span> is the spatially
whitened gain matrix. The expected current values are <span class="math notranslate nohighlight">\(\hat{j} = Mx(t)\)</span>,
where <span class="math notranslate nohighlight">\(x(t) = C^{-^1/_2}x(t)\)</span> is a the whitened measurement
vector at <em>t</em>. The spatial whitening operator
is obtained with the help of the eigenvalue decomposition <span class="math notranslate nohighlight">\(C = U_C \Lambda_C^2 U_C^T\)</span> as <span class="math notranslate nohighlight">\(C^{-^1/_2} = \Lambda_C^{-1} U_C^T\)</span>.
In the MNE software the noise-covariance matrix is stored as the
one applying to raw data. To reflect the decrease of noise due to
averaging, this matrix, <span class="math notranslate nohighlight">\(C_0\)</span>, is scaled
by the number of averages, <span class="math notranslate nohighlight">\(L\)</span>, <em>i.e.</em>, <span class="math notranslate nohighlight">\(C = C_0 / L\)</span>.</p>
<p>As shown above, regularization of the inverse solution is
equivalent to a change in the variance of the current amplitudes
in the Bayesian <em>a priori</em> distribution.</p>
<p>Convenient choice for the source-covariance matrix <span class="math notranslate nohighlight">\(R\)</span> is
such that <span class="math notranslate nohighlight">\(\text{trace}(\tilde{G} R \tilde{G}^T) / \text{trace}(I) = 1\)</span>. With this choice we
can approximate <span class="math notranslate nohighlight">\(\lambda^2 \sim 1/SNR\)</span>, where SNR is
the (power) signal-to-noise ratio of the whitened data.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The definition of the signal to noise-ratio/ <span class="math notranslate nohighlight">\(\lambda^2\)</span> relationship
given above works nicely for the whitened forward solution. In the
un-whitened case scaling with the trace ratio
<span class="math notranslate nohighlight">\(\text{trace}(GRG^T) / \text{trace}(C)\)</span>
does not make sense, since the diagonal elements summed have, in general,
different units of measure. For example, the MEG data are expressed
in T or T/m whereas the unit of EEG is Volts.</p>
</div>
<p>See <a class="reference internal" href="../../auto_tutorials/plot_compute_covariance.html#tut-compute-covariance"><span class="std std-ref">Computing a covariance matrix</span></a> for example of noise covariance
computation and whitening.</p>
</div>
<div class="section" id="regularization-of-the-noise-covariance-matrix">
<span id="c-legacy-cov-regularization"></span><h3><a class="toc-backref" href="#id6">Regularization of the noise-covariance matrix</a><a class="headerlink" href="#regularization-of-the-noise-covariance-matrix" title="Permalink to this headline">¶</a></h3>
<p>Since finite amount of data is usually available to compute
an estimate of the noise-covariance matrix <span class="math notranslate nohighlight">\(C\)</span>,
the smallest eigenvalues of its estimate are usually inaccurate
and smaller than the true eigenvalues. Depending on the seriousness
of this problem, the following quantities can be affected:</p>
<ul class="simple">
<li>The model data predicted by the current estimate,</li>
<li>Estimates of signal-to-noise ratios, which lead to estimates
of the required regularization, see <a class="reference internal" href="#c-legacy-mne-regularization"><span class="std std-ref">Regularization</span></a>,</li>
<li>The estimated current values, and</li>
<li>The noise-normalized estimates, see <a class="reference internal" href="#c-legacy-noise-normalization"><span class="std std-ref">Noise normalization</span></a>.</li>
</ul>
<p>Fortunately, the latter two are least likely to be affected
due to regularization of the estimates. However, in some cases especially
the EEG part of the noise-covariance matrix estimate can be deficient, <em>i.e.</em>,
it may possess very small eigenvalues and thus regularization of
the noise-covariance matrix is advisable.</p>
<p>Historically, the MNE software accomplishes the regularization by replacing
a noise-covariance matrix estimate <span class="math notranslate nohighlight">\(C\)</span> with</p>
<div class="math notranslate nohighlight">
\[C' = C + \sum_k {\varepsilon_k \bar{\sigma_k}^2 I^{(k)}}\ ,\]</div>
<p>where the index <span class="math notranslate nohighlight">\(k\)</span> goes across
the different channel groups (MEG planar gradiometers, MEG axial
gradiometers and magnetometers, and EEG), <span class="math notranslate nohighlight">\(\varepsilon_k\)</span> are
the corresponding regularization factors, <span class="math notranslate nohighlight">\(\bar{\sigma_k}\)</span> are
the average variances across the channel groups, and <span class="math notranslate nohighlight">\(I^{(k)}\)</span> are
diagonal matrices containing ones at the positions corresponding
to the channels contained in each channel group.</p>
<p>Using the UNIX tools <a class="reference internal" href="../c_reference.html#mne-inverse-operator"><span class="std std-ref">mne_inverse_operator</span></a>, the values
<span class="math notranslate nohighlight">\(\varepsilon_k\)</span> can be adjusted with the regularization options
<code class="docutils literal notranslate"><span class="pre">--magreg</span></code> , <code class="docutils literal notranslate"><span class="pre">--gradreg</span></code> , and <code class="docutils literal notranslate"><span class="pre">--eegreg</span></code> specified at the time of the
inverse operator decomposition, see <a class="reference internal" href="#c-legacy-inverse-operator"><span class="std std-ref">Inverse-operator decomposition</span></a>. The convenience script
<a class="reference internal" href="../c_reference.html#mne-do-inverse-operator"><span class="std std-ref">mne_do_inverse_operator</span></a> has the <code class="docutils literal notranslate"><span class="pre">--magreg</span></code> and <code class="docutils literal notranslate"><span class="pre">--gradreg</span></code> combined to
a single option, <code class="docutils literal notranslate"><span class="pre">--megreg</span></code> , see <a class="reference internal" href="../cookbook.html#cihcfjei"><span class="std std-ref">Calculating the inverse operator</span></a>.
Suggested range of values for <span class="math notranslate nohighlight">\(\varepsilon_k\)</span> is <span class="math notranslate nohighlight">\(0.05 \dotso 0.2\)</span>.</p>
</div>
<div class="section" id="computation-of-the-solution">
<span id="c-legacy-mne-solution"></span><h3><a class="toc-backref" href="#id7">Computation of the solution</a><a class="headerlink" href="#computation-of-the-solution" title="Permalink to this headline">¶</a></h3>
<p>The most straightforward approach to calculate the MNE is
to employ expression for the original or whitened inverse operator
directly. However, for computational convenience we prefer to take
another route, which employs the singular-value decomposition (SVD)
of the matrix</p>
<div class="math notranslate nohighlight">
\[A = \tilde{G} R^{^1/_2} = U \Lambda V^T\]</div>
<p>where the superscript <span class="math notranslate nohighlight">\(^1/_2\)</span> indicates a
square root of <span class="math notranslate nohighlight">\(R\)</span>. For a diagonal matrix,
one simply takes the square root of <span class="math notranslate nohighlight">\(R\)</span> while
in the more general case one can use the Cholesky factorization <span class="math notranslate nohighlight">\(R = R_C R_C^T\)</span> and
thus <span class="math notranslate nohighlight">\(R^{^1/_2} = R_C\)</span>.</p>
<p>With the above SVD it is easy to show that</p>
<div class="math notranslate nohighlight">
\[\tilde{M} = R^{^1/_2} V \Gamma U^T\]</div>
<p>where the elements of the diagonal matrix <span class="math notranslate nohighlight">\(\Gamma\)</span> are</p>
<div class="math notranslate nohighlight">
\[\gamma_k = \frac{1}{\lambda_k} \frac{\lambda_k^2}{\lambda_k^2 + \lambda^2}\ .\]</div>
<p>With <span class="math notranslate nohighlight">\(w(t) = U^T C^{-^1/_2} x(t)\)</span> the expression for
the expected current is</p>
<div class="math notranslate nohighlight">
\[\hat{j}(t) = R^C V \Gamma w(t) = \sum_k {\bar{v_k} \gamma_k w_k(t)}\ ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\bar{v_k} = R^C v_k\)</span>, <span class="math notranslate nohighlight">\(v_k\)</span> being
the <span class="math notranslate nohighlight">\(k\)</span> th column of <span class="math notranslate nohighlight">\(V\)</span>. It is thus seen that the current estimate is
a weighted sum of the ‘modified’ eigenleads <span class="math notranslate nohighlight">\(v_k\)</span>.</p>
<p>It is easy to see that <span class="math notranslate nohighlight">\(w(t) \propto \sqrt{L}\)</span>.
To maintain the relation <span class="math notranslate nohighlight">\((\tilde{G} R \tilde{G}^T) / \text{trace}(I) = 1\)</span> when <span class="math notranslate nohighlight">\(L\)</span> changes
we must have <span class="math notranslate nohighlight">\(R \propto 1/L\)</span>. With this approach, <span class="math notranslate nohighlight">\(\lambda_k\)</span> is
independent of  <span class="math notranslate nohighlight">\(L\)</span> and, for fixed <span class="math notranslate nohighlight">\(\lambda\)</span>,
we see directly that <span class="math notranslate nohighlight">\(j(t)\)</span> is independent
of <span class="math notranslate nohighlight">\(L\)</span>.</p>
</div>
<div class="section" id="noise-normalization">
<span id="c-legacy-noise-normalization"></span><h3><a class="toc-backref" href="#id8">Noise normalization</a><a class="headerlink" href="#noise-normalization" title="Permalink to this headline">¶</a></h3>
<p>The noise-normalized linear estimates introduced by Dale
et al. require division of the expected current amplitude by its
variance. Noise normalization serves three purposes:</p>
<ul class="simple">
<li>It converts the expected current value
into a dimensionless statistical test variable. Thus the resulting
time and location dependent values are often referred to as dynamic
statistical parameter maps (dSPM).</li>
<li>It reduces the location bias of the estimates. In particular,
the tendency of the MNE to prefer superficial currents is eliminated.</li>
<li>The width of the point-spread function becomes less dependent
on the source location on the cortical mantle. The point-spread
is defined as the MNE resulting from the signals coming from a point
current source (a current dipole) located at a certain point on
the cortex.</li>
</ul>
<p>In practice, noise normalization requires the computation
of the diagonal elements of the matrix</p>
<div class="math notranslate nohighlight">
\[M C M^T = \tilde{M} \tilde{M}^T\ .\]</div>
<p>With help of the singular-value decomposition approach we
see directly that</p>
<div class="math notranslate nohighlight">
\[\tilde{M} \tilde{M}^T\ = \bar{V} \Gamma^2 \bar{V}^T\ .\]</div>
<p>Under the conditions expressed at the end of <a class="reference internal" href="#c-legacy-mne-solution"><span class="std std-ref">Computation of the solution</span></a>, it follows that the <em>t</em>-statistic values associated
with fixed-orientation sources) are thus proportional to <span class="math notranslate nohighlight">\(\sqrt{L}\)</span> while
the <em>F</em>-statistic employed with free-orientation sources is proportional
to <span class="math notranslate nohighlight">\(L\)</span>, correspondingly.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A section discussing statistical considerations    related to the noise normalization procedure will be added to this    manual in one of the subsequent releases.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The MNE software usually computes the square    roots of the F-statistic to be displayed on the inflated cortical    surfaces. These are also proportional to <span class="math notranslate nohighlight">\(\sqrt{L}\)</span>.</p>
</div>
</div>
<div class="section" id="predicted-data">
<span id="c-legacy-chdcacdc"></span><h3><a class="toc-backref" href="#id9">Predicted data</a><a class="headerlink" href="#predicted-data" title="Permalink to this headline">¶</a></h3>
<p>Under noiseless conditions the SNR is infinite and thus leads
to <span class="math notranslate nohighlight">\(\lambda^2 = 0\)</span> and the minimum-norm estimate
explains the measured data perfectly. Under realistic conditions,
however, <span class="math notranslate nohighlight">\(\lambda^2 &gt; 0\)</span> and there is a misfit
between measured data and those predicted by the MNE. Comparison
of the predicted data, here denoted by <span class="math notranslate nohighlight">\(x(t)\)</span>,
and measured one can give valuable insight on the correctness of
the regularization applied.</p>
<p>In the SVD approach we easily find</p>
<div class="math notranslate nohighlight">
\[\hat{x}(t) = G \hat{j}(t) = C^{^1/_2} U \Pi w(t)\ ,\]</div>
<p>where the diagonal matrix <span class="math notranslate nohighlight">\(\Pi\)</span> has
elements <span class="math notranslate nohighlight">\(\pi_k = \lambda_k \gamma_k\)</span> The predicted data is
thus expressed as the weighted sum of the ‘recolored eigenfields’ in <span class="math notranslate nohighlight">\(C^{^1/_2} U\)</span>.</p>
</div>
<div class="section" id="cortical-patch-statistics">
<span id="c-legacy-patch-stats"></span><h3><a class="toc-backref" href="#id10">Cortical patch statistics</a><a class="headerlink" href="#cortical-patch-statistics" title="Permalink to this headline">¶</a></h3>
<p>If the <code class="docutils literal notranslate"><span class="pre">--cps</span></code> option was used in source space
creation (see <a class="reference internal" href="../cookbook.html#setting-up-source-space"><span class="std std-ref">Setting up the source space</span></a>) or if mne_add_patch_info described
in <a class="reference internal" href="../c_reference.html#mne-add-patch-info"><span class="std std-ref">mne_add_patch_info</span></a> was run manually the source space file
will contain for each vertex of the cortical surface the information
about the source space point closest to it as well as the distance
from the vertex to this source space point. The vertices for which
a given source space point is the nearest one define the cortical
patch associated with with the source space point. Once these data
are available, it is straightforward to compute the following cortical
patch statistics (CPS) for each source location <span class="math notranslate nohighlight">\(d\)</span>:</p>
<ul class="simple">
<li>The average over the normals of at the
vertices in a patch, <span class="math notranslate nohighlight">\(\bar{n_d}\)</span>,</li>
<li>The areas of the patches, <span class="math notranslate nohighlight">\(A_d\)</span>,
and</li>
<li>The average deviation of the vertex normals in a patch from
their average, <span class="math notranslate nohighlight">\(\sigma_d\)</span>, given in degrees.</li>
</ul>
</div>
<div class="section" id="the-orientation-constraints">
<h3><a class="toc-backref" href="#id11">The orientation constraints</a><a class="headerlink" href="#the-orientation-constraints" title="Permalink to this headline">¶</a></h3>
<p>The principal sources of MEG and EEG signals are generally
believed to be postsynaptic currents in the cortical pyramidal neurons.
Since the net primary current associated with these microscopic
events is oriented normal to the cortical mantle, it is reasonable
to use the cortical normal orientation as a constraint in source
estimation. In addition to allowing completely free source orientations,
the MNE software implements three orientation constraints based
of the surface normal data:</p>
<ul class="simple">
<li>Source orientation can be rigidly fixed
to the surface normal direction (the <code class="docutils literal notranslate"><span class="pre">--fixed</span></code> option).
If cortical patch statistics are available the average normal over
each patch, <span class="math notranslate nohighlight">\(\bar{n_d}\)</span>, are used to define
the source orientation. Otherwise, the vertex normal at the source
space location is employed.</li>
<li>A <em>location independent or fixed loose orientation
constraint</em> (fLOC) can be employed (the <code class="docutils literal notranslate"><span class="pre">--loose</span></code> option).
In this approach, a source coordinate system based on the local
surface orientation at the source location is employed. By default,
the three columns of the gain matrix G, associated with a given
source location, are the fields of unit dipoles pointing to the
directions of the x, y, and z axis of the coordinate system employed
in the forward calculation (usually the MEG head coordinate frame).
For LOC the orientation is changed so that the first two source
components lie in the plane normal to the surface normal at the source
location and the third component is aligned with it. Thereafter, the
variance of the source components tangential to the cortical surface are
reduced by a factor defined by the <code class="docutils literal notranslate"><span class="pre">--loose</span></code> option.</li>
<li>A <em>variable loose orientation constraint</em> (vLOC)
can be employed (the <code class="docutils literal notranslate"><span class="pre">--loosevar</span></code> option). This is similar
to fLOC except that the value given with the <code class="docutils literal notranslate"><span class="pre">--loosevar</span></code> option
will be multiplied by <span class="math notranslate nohighlight">\(\sigma_d\)</span>, defined above.</li>
</ul>
</div>
<div class="section" id="depth-weighting">
<span id="c-legacy-depth-weighting"></span><h3><a class="toc-backref" href="#id12">Depth weighting</a><a class="headerlink" href="#depth-weighting" title="Permalink to this headline">¶</a></h3>
<p>The minimum-norm estimates have a bias towards superficial
currents. This tendency can be alleviated by adjusting the source
covariance matrix <span class="math notranslate nohighlight">\(R\)</span> to favor deeper source locations. In the depth
weighting scheme employed in MNE analyze, the elements of <span class="math notranslate nohighlight">\(R\)</span> corresponding
to the <span class="math notranslate nohighlight">\(p\)</span> th source location are be
scaled by a factor</p>
<div class="math notranslate nohighlight">
\[f_p = (g_{1p}^T g_{1p} + g_{2p}^T g_{2p} + g_{3p}^T g_{3p})^{-\gamma}\ ,\]</div>
<p>where <span class="math notranslate nohighlight">\(g_{1p}\)</span>, <span class="math notranslate nohighlight">\(g_{2p}\)</span>, and <span class="math notranslate nohighlight">\(g_{3p}\)</span> are the three columns
of <span class="math notranslate nohighlight">\(G\)</span> corresponding to source location <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(\gamma\)</span> is
the order of the depth weighting, specified with the <code class="docutils literal notranslate"><span class="pre">--weightexp</span></code> option
to mne_inverse_operator . The
maximal amount of depth weighting can be adjusted <code class="docutils literal notranslate"><span class="pre">--weightlimit</span></code> option.</p>
</div>
<div class="section" id="fmri-guided-estimates">
<span id="c-legacy-mne-fmri-estimates"></span><h3><a class="toc-backref" href="#id13">fMRI-guided estimates</a><a class="headerlink" href="#fmri-guided-estimates" title="Permalink to this headline">¶</a></h3>
<p>The fMRI weighting in MNE software means that the source-covariance matrix
is modified to favor areas of significant fMRI activation. For this purpose,
the fMRI activation map is thresholded first at the value defined by
the <code class="docutils literal notranslate"><span class="pre">--fmrithresh</span></code> option to mne_do_inverse_operator or mne_inverse_operator .
Thereafter, the source-covariance matrix values corresponding to
the the sites under the threshold are multiplied by <span class="math notranslate nohighlight">\(f_{off}\)</span>, set
by the <code class="docutils literal notranslate"><span class="pre">--fmrioff</span></code> option.</p>
<p>It turns out that the fMRI weighting has a strong influence
on the MNE but the noise-normalized estimates are much less affected
by it.</p>
</div>
</div>
<div class="section" id="effective-number-of-averages">
<span id="c-legacy-cbbdgiae"></span><h2><a class="toc-backref" href="#id14">Effective number of averages</a><a class="headerlink" href="#effective-number-of-averages" title="Permalink to this headline">¶</a></h2>
<p>It is often the case that the epoch to be analyzed is a linear
combination over conditions rather than one of the original averages
computed. As stated above, the noise-covariance matrix computed
is originally one corresponding to raw data. Therefore, it has to
be scaled correctly to correspond to the actual or effective number
of epochs in the condition to be analyzed. In general, we have</p>
<div class="math notranslate nohighlight">
\[C = C_0 / L_{eff}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{eff}\)</span> is the effective
number of averages. To calculate <span class="math notranslate nohighlight">\(L_{eff}\)</span> for
an arbitrary linear combination of conditions</p>
<div class="math notranslate nohighlight">
\[y(t) = \sum_{i = 1}^n {w_i x_i(t)}\]</div>
<p>we make use of the the fact that the noise-covariance matrix</p>
<div class="math notranslate nohighlight">
\[C_y = \sum_{i = 1}^n {w_i^2 C_{x_i}} = C_0 \sum_{i = 1}^n {w_i^2 / L_i}\]</div>
<p>which leads to</p>
<div class="math notranslate nohighlight">
\[1 / L_{eff} = \sum_{i = 1}^n {w_i^2 / L_i}\]</div>
<p>An important special case  of the above is a weighted average,
where</p>
<div class="math notranslate nohighlight">
\[w_i = L_i / \sum_{i = 1}^n {L_i}\]</div>
<p>and, therefore</p>
<div class="math notranslate nohighlight">
\[L_{eff} = \sum_{i = 1}^n {L_i}\]</div>
<p>Instead of a weighted average, one often computes a weighted
sum, a simplest case being a difference or sum of two categories.
For a difference <span class="math notranslate nohighlight">\(w_1 = 1\)</span> and <span class="math notranslate nohighlight">\(w_2 = -1\)</span> and
thus</p>
<div class="math notranslate nohighlight">
\[1 / L_{eff} = 1 / L_1 + 1 / L_2\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[L_{eff} = \frac{L_1 L_2}{L_1 + L_2}\]</div>
<p>Interestingly, the same holds for a sum, where <span class="math notranslate nohighlight">\(w_1 = w_2 = 1\)</span>.
Generalizing, for any combination of sums and differences, where <span class="math notranslate nohighlight">\(w_i = 1\)</span> or <span class="math notranslate nohighlight">\(w_i = -1\)</span>, <span class="math notranslate nohighlight">\(i = 1 \dotso n\)</span>,
we have</p>
<div class="math notranslate nohighlight">
\[1 / L_{eff} = \sum_{i = 1}^n {1/{L_i}}\]</div>
</div>
<div class="section" id="inverse-operator-decomposition">
<span id="c-legacy-inverse-operator"></span><h2><a class="toc-backref" href="#id15">Inverse-operator decomposition</a><a class="headerlink" href="#inverse-operator-decomposition" title="Permalink to this headline">¶</a></h2>
<p>The program <a class="reference internal" href="../c_reference.html#mne-inverse-operator"><span class="std std-ref">mne_inverse_operator</span></a> calculates
the decomposition <span class="math notranslate nohighlight">\(A = \tilde{G} R^C = U \Lambda \bar{V^T}\)</span>,
described in <a class="reference internal" href="#c-legacy-mne-solution"><span class="std std-ref">Computation of the solution</span></a>. It is normally invoked from the convenience
script <a class="reference internal" href="../c_reference.html#mne-do-inverse-operator"><span class="std std-ref">mne_do_inverse_operator</span></a>.</p>
</div>
<div class="section" id="producing-movies-and-snapshots">
<span id="c-legacy-movies-and-snapshots"></span><h2><a class="toc-backref" href="#id16">Producing movies and snapshots</a><a class="headerlink" href="#producing-movies-and-snapshots" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="../c_reference.html#mne-make-movie"><span class="std std-ref">mne_make_movie</span></a> is a program
for producing movies and snapshot graphics frames without any graphics
output to the screen. In addition, <a class="reference internal" href="../c_reference.html#mne-make-movie"><span class="std std-ref">mne_make_movie</span></a> can
produce stc or w files which contain the numerical current estimate
data in a simple binary format for postprocessing. These files can
be displayed in <a class="reference internal" href="../c_reference.html#mne-analyze"><span class="std std-ref">mne_analyze</span></a>,
see <a class="reference internal" href="../gui/analyze.html#c-legacy-ch-interactive-analysis"><span class="std std-ref">Interactive analysis with mne_analyze</span></a>, utilized in the cross-subject averaging
process, see <a class="reference internal" href="c_morph.html#c-legacy-ch-morph"><span class="std std-ref">Morphing and averaging</span></a>,
and read into Matlab using the MNE Matlab toolbox, see <a class="reference internal" href="../matlab.html#ch-matlab"><span class="std std-ref">MNE-MATLAB toolbox</span></a>.</p>
</div>
<div class="section" id="computing-inverse-from-raw-and-evoked-data">
<span id="c-legacy-computing-inverse"></span><h2><a class="toc-backref" href="#id17">Computing inverse from raw and evoked data</a><a class="headerlink" href="#computing-inverse-from-raw-and-evoked-data" title="Permalink to this headline">¶</a></h2>
<p>The purpose of the utility <a class="reference internal" href="../c_reference.html#mne-compute-raw-inverse"><span class="std std-ref">mne_compute_raw_inverse</span></a> is
to compute inverse solutions from either evoked-response or raw
data at specified ROIs (labels) and to save the results in a fif
file which can be viewed with <a class="reference internal" href="../c_reference.html#mne-browse-raw"><span class="std std-ref">mne_browse_raw</span></a>,
read to Matlab directly using the MNE Matlab Toolbox, see <a class="reference internal" href="../matlab.html#ch-matlab"><span class="std std-ref">MNE-MATLAB toolbox</span></a>,
or converted to Matlab format using either <a class="reference internal" href="../c_reference.html#mne-convert-mne-data"><span class="std std-ref">mne_convert_mne_data</span></a>,
<a class="reference internal" href="../c_reference.html#mne-raw2mat"><span class="std std-ref">mne_raw2mat</span></a>, or <a class="reference internal" href="../c_reference.html#mne-epochs2mat"><span class="std std-ref">mne_epochs2mat</span></a>. See
<a class="reference internal" href="../c_reference.html#mne-compute-raw-inverse"><span class="std std-ref">mne_compute_raw_inverse</span></a> for command-line options.</p>
<div class="section" id="implementation-details">
<span id="c-legacy-implementation-details"></span><h3><a class="toc-backref" href="#id18">Implementation details</a><a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h3>
<p>The fif files output from mne_compute_raw_inverse have
various fields of the channel information set to facilitate interpretation
by postprocessing software as follows:</p>
<p><strong>channel name</strong></p>
<blockquote>
<div>Will be set to J[xyz] &lt;<em>number</em>&gt; ,
where the source component is indicated by the coordinat axis name
and number is the vertex number, starting from zero, in the complete
triangulation of the hemisphere in question.</div></blockquote>
<p><strong>logical channel number</strong></p>
<blockquote>
<div>Will be set to is the vertex number, starting from zero, in the
complete triangulation of the hemisphere in question.</div></blockquote>
<p><strong>sensor location</strong></p>
<blockquote>
<div>The location of the vertex in head coordinates or in MRI coordinates,
determined by the <code class="docutils literal notranslate"><span class="pre">--mricoord</span></code> flag.</div></blockquote>
<p><strong>sensor orientation</strong></p>
<blockquote>
<div>The <em>x</em>-direction unit vector will point to the
direction of the current. Other unit vectors are set to zero. Again,
the coordinate system in which the orientation is expressed depends
on the <code class="docutils literal notranslate"><span class="pre">--mricoord</span></code> flag.</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">--align_z</span></code> flag tries to align the signs
of the signals at different vertices of the label. For this purpose,
the surface normals within the label are collected into a <span class="math notranslate nohighlight">\(n_{vert} \times 3\)</span> matrix.
The preferred orientation will be taken as the first right singular
vector of this matrix, corresponding to its largest singular value.
If the dot product of the surface normal of a vertex is negative,
the sign of the estimates at this vertex are inverted. The inversion
is reflected in the current direction vector listed in the channel
information, see above.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The raw data files output by <a class="reference internal" href="../c_reference.html#mne-compute-raw-inverse"><span class="std std-ref">mne_compute_raw_inverse</span></a> can be converted to mat files with <a class="reference internal" href="../c_reference.html#mne-raw2mat"><span class="std std-ref">mne_raw2mat</span></a>. Alternatively, the files can be read directly from Matlab using the routines in the MNE Matlab toolbox, see <a class="reference internal" href="../matlab.html#ch-matlab"><span class="std std-ref">MNE-MATLAB toolbox</span></a>. The evoked data output can be easily read directly from Matlab using the fiff_load_evoked routine in the MNE Matlab toolbox. Both raw data and evoked output files can be loaded into <a class="reference internal" href="../c_reference.html#mne-browse-raw"><span class="std std-ref">mne_browse_raw</span></a>, see <a class="reference internal" href="../gui/browse.html#ch-browse"><span class="std std-ref">Browsing raw data with mne_browse_raw</span></a>.</p>
</div>
</div>
</div>
</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container"><img src="../../_static/institutions.png" alt="Institutions"></div>
  <div class="container">
    <ul class="list-inline">
      <li><a href="https://github.com/mne-tools/mne-python">GitHub</a></li>
      <li>·</li>
      <li><a href="https://mail.nmr.mgh.harvard.edu/mailman/listinfo/mne_analysis">Mailing list</a></li>
      <li>·</li>
      <li><a href="https://gitter.im/mne-tools/mne-python">Gitter</a></li>
      <li>·</li>
      <li><a href="whats_new.html">What's new</a></li>
      <li>·</li>
      <li><a href="faq.html#cite">Cite MNE</a></li>
      <li class="pull-right"><a href="#">Back to top</a></li>
    </ul>
    <p>&copy; Copyright 2012-2019, MNE Developers. Last updated on 2019-01-24.</p>
  </div>
</footer>
  </body>
</html>