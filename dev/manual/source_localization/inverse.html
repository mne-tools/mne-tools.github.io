<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>The minimum-norm current estimates &#8212; MNE 0.19.dev0 documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap_divs.css" />
    <link rel="stylesheet" href="../../_static/reset-syntax.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap_divs.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />

    <script type="text/javascript" src="../../_static/copybutton.js"></script>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>


    <link rel="stylesheet" href="../../_static/style.css " type="text/css" />
    <link rel="stylesheet" href="../../_static/font-awesome.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/font-source-code-pro.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/font-source-sans-pro.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/flag-icon.css" type="text/css" />



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>



<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>



  </head><body>

<div class="row devbar alert alert-danger">
This documentation is for <strong>development version 0.19.dev0</strong>.
</div>





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/mne_logo_small.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.19.dev0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../install/index.html">Install</a></li>
                <li><a href="../../documentation.html">Documentation</a></li>
                <li><a href="../../python_reference.html">API</a></li>
                <li><a href="../../glossary.html">Glossary</a></li>
                <li><a href="../../auto_examples/index.html">Examples</a></li>
                <li><a href="../../auto_tutorials/index.html">Tutorials</a></li>
                <li><a href="../../install/contributing.html">Contribute</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
<div class="navbar-form navbar-right navbar-btn dropdown btn-group-sm" style="margin-left: 20px; margin-top: 5px; margin-bottom: 5px">
  <button type="button" class="btn btn-danger navbar-btn dropdown-toggle" id="dropdownMenu1" data-toggle="dropdown">
    v0.19.dev0
    <span class="caret"></span>
  </button>
  <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
    <li><a href="https://mne-tools.github.io/dev/index.html">Development</a></li>
    <li><a href="https://mne-tools.github.io/stable/index.html">v0.18 (stable)</a></li>
    <li><a href="https://mne-tools.github.io/0.17/index.html">v0.17</a></li>
    <li><a href="https://mne-tools.github.io/0.16/index.html">v0.16</a></li>
    <li><a href="https://mne-tools.github.io/0.15/index.html">v0.15</a></li>
    <li><a href="https://mne-tools.github.io/0.14/index.html">v0.14</a></li>
    <li><a href="https://mne-tools.github.io/0.13/index.html">v0.13</a></li>
    <li><a href="https://mne-tools.github.io/0.12/index.html">v0.12</a></li>
    <li><a href="https://mne-tools.github.io/0.11/index.html">v0.11</a></li>
  </ul>
</div>


            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          

        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/mne_logo_small.png" alt="Logo"/>
            </a></p><ul>
<li><a class="reference internal" href="#">The minimum-norm current estimates</a><ul>
<li><a class="reference internal" href="#minimum-norm-estimates">Minimum-norm estimates</a><ul>
<li><a class="reference internal" href="#the-linear-inverse-operator">The linear inverse operator</a></li>
<li><a class="reference internal" href="#regularization">Regularization</a></li>
<li><a class="reference internal" href="#whitening-and-scaling">Whitening and scaling</a></li>
<li><a class="reference internal" href="#regularization-of-the-noise-covariance-matrix">Regularization of the noise-covariance matrix</a></li>
<li><a class="reference internal" href="#computation-of-the-solution">Computation of the solution</a></li>
<li><a class="reference internal" href="#noise-normalization">Noise normalization</a></li>
<li><a class="reference internal" href="#predicted-data">Predicted data</a></li>
<li><a class="reference internal" href="#cortical-patch-statistics">Cortical patch statistics</a></li>
<li><a class="reference internal" href="#the-orientation-constraints">The orientation constraints</a></li>
<li><a class="reference internal" href="#depth-weighting">Depth weighting</a></li>
</ul>
</li>
<li><a class="reference internal" href="#effective-number-of-averages">Effective number of averages</a></li>
</ul>
</li>
</ul>

<form action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="the-minimum-norm-current-estimates">
<span id="ch-mne"></span><h1>The minimum-norm current estimates<a class="headerlink" href="#the-minimum-norm-current-estimates" title="Permalink to this headline">¶</a></h1>
<p>This page describes the mathematical concepts and the
computation of the minimum-norm estimates needed
in order to obtain the linear inverse operator using
<a class="reference internal" href="../../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a>.
Its usage is presented in the tutorial <a class="reference internal" href="../../auto_tutorials/source-modeling/plot_mne_dspm_source_localization.html#tut-inverse-methods"><span class="std std-ref">Source localization with MNE/dSPM/sLORETA/eLORETA</span></a>.</p>
<div class="contents local topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#minimum-norm-estimates" id="id3">Minimum-norm estimates</a></p>
<ul>
<li><p><a class="reference internal" href="#the-linear-inverse-operator" id="id4">The linear inverse operator</a></p></li>
<li><p><a class="reference internal" href="#regularization" id="id5">Regularization</a></p></li>
<li><p><a class="reference internal" href="#whitening-and-scaling" id="id6">Whitening and scaling</a></p></li>
<li><p><a class="reference internal" href="#regularization-of-the-noise-covariance-matrix" id="id7">Regularization of the noise-covariance matrix</a></p></li>
<li><p><a class="reference internal" href="#computation-of-the-solution" id="id8">Computation of the solution</a></p></li>
<li><p><a class="reference internal" href="#noise-normalization" id="id9">Noise normalization</a></p></li>
<li><p><a class="reference internal" href="#predicted-data" id="id10">Predicted data</a></p></li>
<li><p><a class="reference internal" href="#cortical-patch-statistics" id="id11">Cortical patch statistics</a></p></li>
<li><p><a class="reference internal" href="#the-orientation-constraints" id="id12">The orientation constraints</a></p></li>
<li><p><a class="reference internal" href="#depth-weighting" id="id13">Depth weighting</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#effective-number-of-averages" id="id14">Effective number of averages</a></p></li>
</ul>
</div>
<div class="section" id="minimum-norm-estimates">
<span id="cbbdjfbj"></span><h2><a class="toc-backref" href="#id3">Minimum-norm estimates</a><a class="headerlink" href="#minimum-norm-estimates" title="Permalink to this headline">¶</a></h2>
<p>This section describes the mathematical details of the calculation
of minimum-norm estimates. In Bayesian sense, the ensuing current
distribution is the maximum a posteriori (MAP) estimate under the
following assumptions:</p>
<ul class="simple">
<li><p>The viable locations of the currents
are constrained to the cortex. Optionally, the current orientations
can be fixed to be normal to the cortical mantle.</p></li>
<li><p>The amplitudes of the currents have a Gaussian prior distribution
with a known source covariance matrix.</p></li>
<li><p>The measured data contain additive noise with a Gaussian distribution with
a known covariance matrix. The noise is not correlated over time.</p></li>
</ul>
<div class="section" id="the-linear-inverse-operator">
<h3><a class="toc-backref" href="#id4">The linear inverse operator</a><a class="headerlink" href="#the-linear-inverse-operator" title="Permalink to this headline">¶</a></h3>
<p>The measured data in the source estimation procedure consists
of MEG and EEG data, recorded on a total of N channels. The task
is to estimate a total of M strengths of sources located on the
cortical mantle. If the number of source locations is P, M = P for
fixed-orientation sources and M = 3P if the source orientations
are unconstrained. The regularized linear inverse operator following
from the Bayesian approach is given by the <span class="math notranslate nohighlight">\(M \times N\)</span> matrix</p>
<div class="math notranslate nohighlight">
\[M = R' G^T (G R' G^T + C)^{-1}\ ,\]</div>
<p>where G is the gain matrix relating the source strengths
to the measured MEG/EEG data, <span class="math notranslate nohighlight">\(C\)</span> is the data noise-covariance matrix
and <span class="math notranslate nohighlight">\(R'\)</span> is the source covariance matrix.
The dimensions of these matrices are <span class="math notranslate nohighlight">\(N \times M\)</span>, <span class="math notranslate nohighlight">\(N \times N\)</span>,
and <span class="math notranslate nohighlight">\(M \times M\)</span>, respectively. The <span class="math notranslate nohighlight">\(M \times 1\)</span> source-strength
vector is obtained by multiplying the <span class="math notranslate nohighlight">\(N \times 1\)</span> data
vector by <span class="math notranslate nohighlight">\(M\)</span>.</p>
<p>The expected value of the current amplitudes at time <em>t</em> is
then given by <span class="math notranslate nohighlight">\(\hat{j}(t) = Mx(t)\)</span>, where <span class="math notranslate nohighlight">\(x(t)\)</span> is
a vector containing the measured MEG and EEG data values at time <em>t</em>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For computational convenience, in MNE-Python the linear inverse operator is not computed explicitly. See <a class="reference internal" href="#mne-solution"><span class="std std-ref">Computation of the solution</span></a> for mathematical details, and <a class="reference internal" href="../cookbook.html#cihcfjei"><span class="std std-ref">Calculating the inverse operator</span></a> for a detailed example.</p>
</div>
</div>
<div class="section" id="regularization">
<span id="mne-regularization"></span><h3><a class="toc-backref" href="#id5">Regularization</a><a class="headerlink" href="#regularization" title="Permalink to this headline">¶</a></h3>
<p>The a priori variance of the currents is, in practise, unknown.
We can express this by writing <span class="math notranslate nohighlight">\(R' = R/ \lambda^2\)</span>,
which yields the inverse operator</p>
<div class="math notranslate nohighlight">
\[M = R G^T (G R G^T + \lambda^2 C)^{-1}\ ,\]</div>
<p>where the unknown current amplitude is now interpreted in
terms of the regularization parameter <span class="math notranslate nohighlight">\(\lambda^2\)</span>.
Small <span class="math notranslate nohighlight">\(\lambda^2\)</span> corresponds to large current amplitudes
and complex estimate current patterns while a large <span class="math notranslate nohighlight">\(\lambda^2\)</span> means the
amplitude of the current is limited and a simpler, smooth, current
estimate is obtained.</p>
<p>We can arrive in the regularized linear inverse operator
also by minimizing the cost function</p>
<div class="math notranslate nohighlight">
\[S = \tilde{e}^T \tilde{e} + \lambda^2 j^T R^{-1} j\ ,\]</div>
<p>where the first term consists of the difference between the
whitened measured data (see <a class="reference internal" href="#chddhage"><span class="std std-ref">Whitening and scaling</span></a>) and those predicted
by the model while the second term is a weighted-norm of the current
estimate. It is seen that, with increasing <span class="math notranslate nohighlight">\(\lambda^2\)</span>,
the source term receive more weight and larger discrepancy between
the measured and predicted data is tolerable.</p>
</div>
<div class="section" id="whitening-and-scaling">
<span id="chddhage"></span><h3><a class="toc-backref" href="#id6">Whitening and scaling</a><a class="headerlink" href="#whitening-and-scaling" title="Permalink to this headline">¶</a></h3>
<p>The MNE software employs data whitening so that a ‘whitened’ inverse operator
assumes the form</p>
<div class="math notranslate nohighlight">
\[\tilde{M} = R \tilde{G}^T (\tilde{G} R \tilde{G}^T + I)^{-1}\ ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\tilde{G} = C^{-^1/_2}G\)</span> is the spatially
whitened gain matrix. The expected current values are <span class="math notranslate nohighlight">\(\hat{j} = Mx(t)\)</span>,
where <span class="math notranslate nohighlight">\(x(t) = C^{-^1/_2}x(t)\)</span> is a the whitened measurement
vector at <em>t</em>. The spatial whitening operator
is obtained with the help of the eigenvalue decomposition <span class="math notranslate nohighlight">\(C = U_C \Lambda_C^2 U_C^T\)</span> as <span class="math notranslate nohighlight">\(C^{-^1/_2} = \Lambda_C^{-1} U_C^T\)</span>.
In the MNE software the noise-covariance matrix is stored as the
one applying to raw data. To reflect the decrease of noise due to
averaging, this matrix, <span class="math notranslate nohighlight">\(C_0\)</span>, is scaled
by the number of averages, <span class="math notranslate nohighlight">\(L\)</span>, <em>i.e.</em>, <span class="math notranslate nohighlight">\(C = C_0 / L\)</span>.</p>
<p>As shown above, regularization of the inverse solution is
equivalent to a change in the variance of the current amplitudes
in the Bayesian <em>a priori</em> distribution.</p>
<p>Convenient choice for the source-covariance matrix <span class="math notranslate nohighlight">\(R\)</span> is
such that <span class="math notranslate nohighlight">\(\text{trace}(\tilde{G} R \tilde{G}^T) / \text{trace}(I) = 1\)</span>. With this choice we
can approximate <span class="math notranslate nohighlight">\(\lambda^2 \sim 1/SNR\)</span>, where SNR is
the (power) signal-to-noise ratio of the whitened data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The definition of the signal to noise-ratio/ <span class="math notranslate nohighlight">\(\lambda^2\)</span> relationship
given above works nicely for the whitened forward solution. In the
un-whitened case scaling with the trace ratio
<span class="math notranslate nohighlight">\(\text{trace}(GRG^T) / \text{trace}(C)\)</span>
does not make sense, since the diagonal elements summed have, in general,
different units of measure. For example, the MEG data are expressed
in T or T/m whereas the unit of EEG is Volts.</p>
</div>
<p>See <a class="reference internal" href="../../auto_tutorials/source-modeling/plot_compute_covariance.html#tut-compute-covariance"><span class="std std-ref">Computing a covariance matrix</span></a> for example of noise covariance
computation and whitening.</p>
</div>
<div class="section" id="regularization-of-the-noise-covariance-matrix">
<span id="cov-regularization"></span><h3><a class="toc-backref" href="#id7">Regularization of the noise-covariance matrix</a><a class="headerlink" href="#regularization-of-the-noise-covariance-matrix" title="Permalink to this headline">¶</a></h3>
<p>Since finite amount of data is usually available to compute
an estimate of the noise-covariance matrix <span class="math notranslate nohighlight">\(C\)</span>,
the smallest eigenvalues of its estimate are usually inaccurate
and smaller than the true eigenvalues. Depending on the seriousness
of this problem, the following quantities can be affected:</p>
<ul class="simple">
<li><p>The model data predicted by the current estimate,</p></li>
<li><p>Estimates of signal-to-noise ratios, which lead to estimates
of the required regularization, see <a class="reference internal" href="#mne-regularization"><span class="std std-ref">Regularization</span></a>,</p></li>
<li><p>The estimated current values, and</p></li>
<li><p>The noise-normalized estimates, see <a class="reference internal" href="#noise-normalization"><span class="std std-ref">Noise normalization</span></a>.</p></li>
</ul>
<p>Fortunately, the latter two are least likely to be affected
due to regularization of the estimates. However, in some cases especially
the EEG part of the noise-covariance matrix estimate can be deficient, <em>i.e.</em>,
it may possess very small eigenvalues and thus regularization of
the noise-covariance matrix is advisable.</p>
<p>Historically, the MNE software accomplishes the regularization by replacing
a noise-covariance matrix estimate <span class="math notranslate nohighlight">\(C\)</span> with</p>
<div class="math notranslate nohighlight">
\[C' = C + \sum_k {\varepsilon_k \bar{\sigma_k}^2 I^{(k)}}\ ,\]</div>
<p>where the index <span class="math notranslate nohighlight">\(k\)</span> goes across
the different channel groups (MEG planar gradiometers, MEG axial
gradiometers and magnetometers, and EEG), <span class="math notranslate nohighlight">\(\varepsilon_k\)</span> are
the corresponding regularization factors, <span class="math notranslate nohighlight">\(\bar{\sigma_k}\)</span> are
the average variances across the channel groups, and <span class="math notranslate nohighlight">\(I^{(k)}\)</span> are
diagonal matrices containing ones at the positions corresponding
to the channels contained in each channel group.</p>
<p>See <a class="reference internal" href="../../auto_tutorials/source-modeling/plot_compute_covariance.html#plot-compute-covariance-howto"><span class="std std-ref">How should I regularize the covariance matrix?</span></a> for details.</p>
</div>
<div class="section" id="computation-of-the-solution">
<span id="inverse-operator"></span><span id="mne-solution"></span><h3><a class="toc-backref" href="#id8">Computation of the solution</a><a class="headerlink" href="#computation-of-the-solution" title="Permalink to this headline">¶</a></h3>
<p>The most straightforward approach to calculate the MNE is
to employ expression for the original or whitened inverse operator
directly. However, for computational convenience we prefer to take
another route, which employs the singular-value decomposition (SVD)
of the matrix</p>
<div class="math notranslate nohighlight">
\[A = \tilde{G} R^{^1/_2} = U \Lambda V^T\]</div>
<p>where the superscript <span class="math notranslate nohighlight">\(^1/_2\)</span> indicates a
square root of <span class="math notranslate nohighlight">\(R\)</span>. For a diagonal matrix,
one simply takes the square root of <span class="math notranslate nohighlight">\(R\)</span> while
in the more general case one can use the Cholesky factorization <span class="math notranslate nohighlight">\(R = R_C R_C^T\)</span> and
thus <span class="math notranslate nohighlight">\(R^{^1/_2} = R_C\)</span>.</p>
<p>With the above SVD it is easy to show that</p>
<div class="math notranslate nohighlight">
\[\tilde{M} = R^{^1/_2} V \Gamma U^T\]</div>
<p>where the elements of the diagonal matrix <span class="math notranslate nohighlight">\(\Gamma\)</span> are</p>
<div class="math notranslate nohighlight">
\[\gamma_k = \frac{1}{\lambda_k} \frac{\lambda_k^2}{\lambda_k^2 + \lambda^2}\ .\]</div>
<p>With <span class="math notranslate nohighlight">\(w(t) = U^T C^{-^1/_2} x(t)\)</span> the expression for
the expected current is</p>
<div class="math notranslate nohighlight">
\[\hat{j}(t) = R^C V \Gamma w(t) = \sum_k {\bar{v_k} \gamma_k w_k(t)}\ ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\bar{v_k} = R^C v_k\)</span>, <span class="math notranslate nohighlight">\(v_k\)</span> being
the <span class="math notranslate nohighlight">\(k\)</span> th column of <span class="math notranslate nohighlight">\(V\)</span>. It is thus seen that the current estimate is
a weighted sum of the ‘modified’ eigenleads <span class="math notranslate nohighlight">\(v_k\)</span>.</p>
<p>It is easy to see that <span class="math notranslate nohighlight">\(w(t) \propto \sqrt{L}\)</span>.
To maintain the relation <span class="math notranslate nohighlight">\((\tilde{G} R \tilde{G}^T) / \text{trace}(I) = 1\)</span> when <span class="math notranslate nohighlight">\(L\)</span> changes
we must have <span class="math notranslate nohighlight">\(R \propto 1/L\)</span>. With this approach, <span class="math notranslate nohighlight">\(\lambda_k\)</span> is
independent of  <span class="math notranslate nohighlight">\(L\)</span> and, for fixed <span class="math notranslate nohighlight">\(\lambda\)</span>,
we see directly that <span class="math notranslate nohighlight">\(j(t)\)</span> is independent
of <span class="math notranslate nohighlight">\(L\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is computed using <a class="reference internal" href="../../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a> and its usage is illustrated in <a class="reference internal" href="../cookbook.html#cihcfjei"><span class="std std-ref">Calculating the inverse operator</span></a>.</p>
</div>
</div>
<div class="section" id="noise-normalization">
<span id="id1"></span><h3><a class="toc-backref" href="#id9">Noise normalization</a><a class="headerlink" href="#noise-normalization" title="Permalink to this headline">¶</a></h3>
<p>The noise-normalized linear estimates introduced by Dale
et al. require division of the expected current amplitude by its
variance. Noise normalization serves three purposes:</p>
<ul class="simple">
<li><p>It converts the expected current value
into a dimensionless statistical test variable. Thus the resulting
time and location dependent values are often referred to as dynamic
statistical parameter maps (dSPM).</p></li>
<li><p>It reduces the location bias of the estimates. In particular,
the tendency of the MNE to prefer superficial currents is eliminated.</p></li>
<li><p>The width of the point-spread function becomes less dependent
on the source location on the cortical mantle. The point-spread
is defined as the MNE resulting from the signals coming from a point
current source (a current dipole) located at a certain point on
the cortex.</p></li>
</ul>
<p>In practice, noise normalization requires the computation
of the diagonal elements of the matrix</p>
<div class="math notranslate nohighlight">
\[M C M^T = \tilde{M} \tilde{M}^T\ .\]</div>
<p>With help of the singular-value decomposition approach we
see directly that</p>
<div class="math notranslate nohighlight">
\[\tilde{M} \tilde{M}^T\ = \bar{V} \Gamma^2 \bar{V}^T\ .\]</div>
<p>Under the conditions expressed at the end of <a class="reference internal" href="#mne-solution"><span class="std std-ref">Computation of the solution</span></a>, it follows that the <em>t</em>-statistic values associated
with fixed-orientation sources) are thus proportional to <span class="math notranslate nohighlight">\(\sqrt{L}\)</span> while
the <em>F</em>-statistic employed with free-orientation sources is proportional
to <span class="math notranslate nohighlight">\(L\)</span>, correspondingly.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A section discussing statistical considerations    related to the noise normalization procedure will be added to this    manual in one of the subsequent releases.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The MNE software usually computes the square    roots of the F-statistic to be displayed on the inflated cortical    surfaces. These are also proportional to <span class="math notranslate nohighlight">\(\sqrt{L}\)</span>.</p>
</div>
</div>
<div class="section" id="predicted-data">
<span id="chdcacdc"></span><h3><a class="toc-backref" href="#id10">Predicted data</a><a class="headerlink" href="#predicted-data" title="Permalink to this headline">¶</a></h3>
<p>Under noiseless conditions the SNR is infinite and thus leads
to <span class="math notranslate nohighlight">\(\lambda^2 = 0\)</span> and the minimum-norm estimate
explains the measured data perfectly. Under realistic conditions,
however, <span class="math notranslate nohighlight">\(\lambda^2 &gt; 0\)</span> and there is a misfit
between measured data and those predicted by the MNE. Comparison
of the predicted data, here denoted by <span class="math notranslate nohighlight">\(x(t)\)</span>,
and measured one can give valuable insight on the correctness of
the regularization applied.</p>
<p>In the SVD approach we easily find</p>
<div class="math notranslate nohighlight">
\[\hat{x}(t) = G \hat{j}(t) = C^{^1/_2} U \Pi w(t)\ ,\]</div>
<p>where the diagonal matrix <span class="math notranslate nohighlight">\(\Pi\)</span> has
elements <span class="math notranslate nohighlight">\(\pi_k = \lambda_k \gamma_k\)</span> The predicted data is
thus expressed as the weighted sum of the ‘recolored eigenfields’ in <span class="math notranslate nohighlight">\(C^{^1/_2} U\)</span>.</p>
</div>
<div class="section" id="cortical-patch-statistics">
<span id="patch-stats"></span><h3><a class="toc-backref" href="#id11">Cortical patch statistics</a><a class="headerlink" href="#cortical-patch-statistics" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">use_cps</span></code> parameter in
<a class="reference internal" href="../../generated/mne.convert_forward_solution.html#mne.convert_forward_solution" title="mne.convert_forward_solution"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.convert_forward_solution()</span></code></a>, and
<a class="reference internal" href="../../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a>
controls whether to use cortical patch statistics (CPS) to define normal orientations
or not (see <a class="reference internal" href="../cookbook.html#chdbbcej"><span class="std std-ref">Cortical surface reconstruction with FreeSurfer</span></a>).
The CPS contain for each vertex of the cortical surface the information
about the source space point closest to it as well as the distance
from the vertex to this source space point. The vertices for which
a given source space point is the nearest one define the cortical
patch associated with with the source space point. Once these data
are available, it is straightforward to compute the following
for each source location <span class="math notranslate nohighlight">\(d\)</span>:</p>
<ul class="simple">
<li><p>The average over the normals of at the
vertices in a patch, <span class="math notranslate nohighlight">\(\bar{n_d}\)</span>,</p></li>
<li><p>The areas of the patches, <span class="math notranslate nohighlight">\(A_d\)</span>,
and</p></li>
<li><p>The average deviation of the vertex normals in a patch from
their average, <span class="math notranslate nohighlight">\(\sigma_d\)</span>, given in degrees.</p></li>
</ul>
</div>
<div class="section" id="the-orientation-constraints">
<span id="inverse-orientation-constrains"></span><h3><a class="toc-backref" href="#id12">The orientation constraints</a><a class="headerlink" href="#the-orientation-constraints" title="Permalink to this headline">¶</a></h3>
<p>The principal sources of MEG and EEG signals are generally
believed to be postsynaptic currents in the cortical pyramidal neurons.
Since the net primary current associated with these microscopic
events is oriented normal to the cortical mantle, it is reasonable
to use the cortical normal orientation as a constraint in source
estimation. In addition to allowing completely free source orientations,
the MNE software implements three orientation constraints based
of the surface normal data:</p>
<ul class="simple">
<li><p>Source orientation can be rigidly fixed
by specifying <code class="docutils literal notranslate"><span class="pre">fixed=True</span></code> when calling
<a class="reference internal" href="../../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a>.
In such case, the dipole orientations are
fixed to be orthogonal to the surface of the cortex, pointing outwards.
If cortical patch statistics are available the average normal over
each patch, <span class="math notranslate nohighlight">\(\bar{n_d}\)</span>, are used to define
the source orientation. Otherwise, the vertex normal at the source
space location is employed.
See <a class="reference internal" href="../../auto_tutorials/source-modeling/plot_dipole_orientations.html#plot-dipole-orientations-fixed-orientations"><span class="std std-ref">Fixed dipole orientations</span></a></p></li>
<li><p>A <em>location independent or fixed loose orientation
constraint</em> (fLOC) can be employed
by specifying <code class="docutils literal notranslate"><span class="pre">fixed=False</span></code> and <code class="docutils literal notranslate"><span class="pre">loose=1.0</span></code> when calling
<a class="reference internal" href="../../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a>.
In this approach, a source coordinate system based on the local
surface orientation at the source location is employed. By default,
the three columns of the gain matrix G, associated with a given
source location, are the fields of unit dipoles pointing to the
directions of the x, y, and z axis of the coordinate system employed
in the forward calculation
(usually the <a class="reference internal" href="forward.html#bjebibai"><span class="std std-ref">MEG head coordinate frame</span></a>).
For LOC the orientation is changed so that the first two source
components lie in the plane normal to the surface normal at the source
location and the third component is aligned with it. Thereafter, the
variance of the source components tangential to the cortical surface are
reduced by a factor defined by the <code class="docutils literal notranslate"><span class="pre">loose</span></code> parameter.
See <a class="reference internal" href="../../auto_tutorials/source-modeling/plot_dipole_orientations.html#plot-dipole-orientations-floc-orientations"><span class="std std-ref">Loose dipole orientations</span></a></p></li>
<li><p>A <em>variable loose orientation constraint</em> (vLOC)
can be employed
by specifying <code class="docutils literal notranslate"><span class="pre">fixed=False</span></code> and <code class="docutils literal notranslate"><span class="pre">loose</span></code> parameters when calling
<a class="reference internal" href="../../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a>.
This is similar
to fLOC except that the value given with the <code class="docutils literal notranslate"><span class="pre">loose</span></code> parameter
will be multiplied by <span class="math notranslate nohighlight">\(\sigma_d\)</span>, defined above.
See <a class="reference internal" href="../../auto_tutorials/source-modeling/plot_dipole_orientations.html#plot-dipole-orientations-vloc-orientations"><span class="std std-ref">Limiting orientations, but not fixing them</span></a></p></li>
</ul>
</div>
<div class="section" id="depth-weighting">
<span id="id2"></span><h3><a class="toc-backref" href="#id13">Depth weighting</a><a class="headerlink" href="#depth-weighting" title="Permalink to this headline">¶</a></h3>
<p>The minimum-norm estimates have a bias towards superficial
currents. This tendency can be alleviated by adjusting the source
covariance matrix <span class="math notranslate nohighlight">\(R\)</span> to favor deeper source locations. In the depth
weighting scheme employed in MNE analyze, the elements of <span class="math notranslate nohighlight">\(R\)</span> corresponding
to the <span class="math notranslate nohighlight">\(p\)</span> th source location are be
scaled by a factor</p>
<div class="math notranslate nohighlight">
\[f_p = (g_{1p}^T g_{1p} + g_{2p}^T g_{2p} + g_{3p}^T g_{3p})^{-\gamma}\ ,\]</div>
<p>where <span class="math notranslate nohighlight">\(g_{1p}\)</span>, <span class="math notranslate nohighlight">\(g_{2p}\)</span>, and <span class="math notranslate nohighlight">\(g_{3p}\)</span> are the three columns
of <span class="math notranslate nohighlight">\(G\)</span> corresponding to source location <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(\gamma\)</span> is
the order of the depth weighting.
The maximal amount of depth weighting can be adjusted with <code class="docutils literal notranslate"><span class="pre">depth</span></code> parameter in
<a class="reference internal" href="../../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></code></a>.</p>
</div>
</div>
<div class="section" id="effective-number-of-averages">
<span id="cbbdgiae"></span><h2><a class="toc-backref" href="#id14">Effective number of averages</a><a class="headerlink" href="#effective-number-of-averages" title="Permalink to this headline">¶</a></h2>
<p>It is often the case that the epoch to be analyzed is a linear
combination over conditions rather than one of the original averages
computed. As stated above, the noise-covariance matrix computed
is originally one corresponding to raw data. Therefore, it has to
be scaled correctly to correspond to the actual or effective number
of epochs in the condition to be analyzed. In general, we have</p>
<div class="math notranslate nohighlight">
\[C = C_0 / L_{eff}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{eff}\)</span> is the effective
number of averages. To calculate <span class="math notranslate nohighlight">\(L_{eff}\)</span> for
an arbitrary linear combination of conditions</p>
<div class="math notranslate nohighlight">
\[y(t) = \sum_{i = 1}^n {w_i x_i(t)}\]</div>
<p>we make use of the the fact that the noise-covariance matrix</p>
<div class="math notranslate nohighlight">
\[C_y = \sum_{i = 1}^n {w_i^2 C_{x_i}} = C_0 \sum_{i = 1}^n {w_i^2 / L_i}\]</div>
<p>which leads to</p>
<div class="math notranslate nohighlight">
\[1 / L_{eff} = \sum_{i = 1}^n {w_i^2 / L_i}\]</div>
<p>An important special case  of the above is a weighted average,
where</p>
<div class="math notranslate nohighlight">
\[w_i = L_i / \sum_{i = 1}^n {L_i}\]</div>
<p>and, therefore</p>
<div class="math notranslate nohighlight">
\[L_{eff} = \sum_{i = 1}^n {L_i}\]</div>
<p>Instead of a weighted average, one often computes a weighted
sum, a simplest case being a difference or sum of two categories.
For a difference <span class="math notranslate nohighlight">\(w_1 = 1\)</span> and <span class="math notranslate nohighlight">\(w_2 = -1\)</span> and
thus</p>
<div class="math notranslate nohighlight">
\[1 / L_{eff} = 1 / L_1 + 1 / L_2\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[L_{eff} = \frac{L_1 L_2}{L_1 + L_2}\]</div>
<p>Interestingly, the same holds for a sum, where <span class="math notranslate nohighlight">\(w_1 = w_2 = 1\)</span>.
Generalizing, for any combination of sums and differences, where <span class="math notranslate nohighlight">\(w_i = 1\)</span> or <span class="math notranslate nohighlight">\(w_i = -1\)</span>, <span class="math notranslate nohighlight">\(i = 1 \dotso n\)</span>,
we have</p>
<div class="math notranslate nohighlight">
\[1 / L_{eff} = \sum_{i = 1}^n {1/{L_i}}\]</div>
</div>
</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container institutions">
    <a href="https://www.massgeneral.org/"><img class="institution_lg" src="../../_static/institution_logos/MGH.svg" title="Massachusetts General Hospital" alt="Massachusetts General Hospital"/></a>
    <a href="https://martinos.org/"><img class="institution_lg" src="../../_static/institution_logos/Martinos.png" title="Athinoula A. Martinos Center for Biomedical Imaging" alt="Athinoula A. Martinos Center for Biomedical Imaging"/></a>
    <a href="https://hms.harvard.edu/"><img class="institution_lg" src="../../_static/institution_logos/Harvard.png" title="Harvard Medical School" alt="Harvard Medical School"/></a>
    <a href="https://web.mit.edu/"><img class="institution_sm" src="../../_static/institution_logos/MIT.svg" title="Massachusetts Institute of Technology" alt="Massachusetts Institute of Technology"/></a>
    <a href="https://www.nyu.edu/"><img class="institution_md" src="../../_static/institution_logos/NYU.png" title="New York University" alt="New York University"/></a>
    <a href="http://www.cea.fr/"><img class="institution_md" src="../../_static/institution_logos/CEA.png" title="Commissariat à l´énergie atomique et aux énergies alternatives" alt="Commissariat à l´énergie atomique et aux énergies alternatives"/></a>
    <a href="https://sci.aalto.fi/"><img class="institution_md" src="../../_static/institution_logos/Aalto.svg" title="Aalto-yliopiston perustieteiden korkeakoulu" alt="Aalto-yliopiston perustieteiden korkeakoulu"/></a>
    <a href="https://www.telecom-paris.fr/"><img class="institution_md" src="../../_static/institution_logos/Telecom_Paris_Tech.png" title="Télécom ParisTech" alt="Télécom ParisTech"/></a>
    <a href="https://www.washington.edu/"><img class="institution_sm" src="../../_static/institution_logos/Washington.png" title="University of Washington" alt="University of Washington"/></a>
    <a href="https://icm-institute.org/"><img class="institution_lg" src="../../_static/institution_logos/ICM.jpg" title="Institut du Cerveau et de la Moelle épinière" alt="Institut du Cerveau et de la Moelle épinière"/></a>
    <a href="https://www.bu.edu/"><img class="institution_sm" src="../../_static/institution_logos/BU.svg" title="Boston University" alt="Boston University"/></a>
    <a href="https://www.inserm.fr/"><img class="institution_xs" src="../../_static/institution_logos/Inserm.svg" title="Institut national de la santé et de la recherche médicale" alt="Institut national de la santé et de la recherche médicale"/></a>
    <a href="https://www.fz-juelich.de/"><img class="institution_sm" src="../../_static/institution_logos/Julich.svg" title="Forschungszentrum Jülich" alt="Forschungszentrum Jülich"/></a>
    <a href="https://www.tu-ilmenau.de/"><img class="institution_sm" src="../../_static/institution_logos/Ilmenau.gif" title="Technische Universität Ilmenau" alt="Technische Universität Ilmenau"/></a>
    <a href="https://bids.berkeley.edu/"><img class="institution_md" src="../../_static/institution_logos/BIDS.png" title="Berkeley Institute for Data Science" alt="Berkeley Institute for Data Science"/></a>
    <a href="https://www.inria.fr/"><img class="institution_sm" src="../../_static/institution_logos/inria.png" title="Institut national de recherche en informatique et en automatique" alt="Institut national de recherche en informatique et en automatique"/></a>
    <a href="https://www.au.dk/"><img class="institution_sm" src="../../_static/institution_logos/Aarhus.png" title="Aarhus Universitet" alt="Aarhus Universitet"/></a>
    <a href="https://www.uni-graz.at/"><img class="institution_md" src="../../_static/institution_logos/Graz.jpg" title="Karl-Franzens-Universität Graz" alt="Karl-Franzens-Universität Graz"/></a>
  </div>
  <div class="container">
    <ul class="list-inline">
      <li><a href="https://github.com/mne-tools/mne-python">GitHub</a></li>
      <li>·</li>
      <li><a href="https://mail.nmr.mgh.harvard.edu/mailman/listinfo/mne_analysis">Mailing list</a></li>
      <li>·</li>
      <li><a href="https://gitter.im/mne-tools/mne-python">Gitter</a></li>
      <li>·</li>
      <li><a href="whats_new.html">What's new</a></li>
      <li>·</li>
      <li><a href="faq.html#cite">Cite MNE</a></li>
      <li class="pull-right"><a href="#">Back to top</a></li>
    </ul>
    <p>&copy; Copyright 2012-2019, MNE Developers. Last updated on 2019-08-30.</p>
  </div>
</footer>
  </body>
</html>