<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mne.io.RawArray &#8212; MNE 0.14.git documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.3.6/flatly/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.14.git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="MNE 0.14.git documentation" href="../index.html" />
    <link rel="up" title="Python API Reference" href="../python_reference.html" />
    <link rel="next" title="mne.Annotations" href="mne.Annotations.html" />
    <link rel="prev" title="mne.io.RawFIF" href="mne.io.RawFIF.html" />

<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,400,700' rel='stylesheet' type='text/css'>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="http://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>


  </head>
  <body role="document">

<div class="devbar">
This documentation is for the development version (0.14.git) - <a href="http://martinos.org/mne/stable">Stable version</a>
</div>





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/mne_logo_small.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.14.git</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../getting_started.html">Get started</a></li>
                <li><a href="../tutorials.html">Tutorials</a></li>
                <li><a href="../auto_examples/index.html">Gallery</a></li>
                <li><a href="../python_reference.html">API</a></li>
                <li><a href="../manual/index.html">Manual</a></li>
                <li><a href="../faq.html">FAQ</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contribute to MNE</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../python_reference.html">Python API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../manual/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whats_new.html">What&#8217;s new</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cite.html">How to cite MNE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">Related publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cited.html">Publications from MNE users</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">mne.io.RawArray</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/mne_logo_small.png" alt="Logo"/>
            </a></p><ul>
<li><a class="reference internal" href="#">mne.io.RawArray</a></li>
</ul>

  <li>
    <a href="mne.io.RawFIF.html" title="Previous Chapter: mne.io.RawFIF"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; mne.io.RawFIF</span>
    </a>
  </li>
  <li>
    <a href="mne.Annotations.html" title="Next Chapter: mne.Annotations"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">mne.Annotations &raquo;</span>
    </a>
  </li>
<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-12 content">
      
  <div class="section" id="mne-io-rawarray">
<h1>mne.io.RawArray<a class="headerlink" href="#mne-io-rawarray" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="mne.io.RawArray">
<em class="property">class </em><code class="descclassname">mne.io.</code><code class="descname">RawArray</code><span class="sig-paren">(</span><em>data</em>, <em>info</em>, <em>first_samp=0</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Raw object from numpy array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array, shape (n_channels, n_times)</p>
<blockquote>
<div><p>The channels&#8217; time series.</p>
</div></blockquote>
<p><strong>info</strong> : instance of Info</p>
<blockquote>
<div><p>Info dictionary. Consider using <cite>create_info</cite> to populate
this structure. This may be modified in place by the class.</p>
</div></blockquote>
<p><strong>first_samp</strong> : int</p>
<blockquote>
<div><p>First sample offset used during recording (default 0).</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.</span></p>
</div>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal"><span class="pre">EpochsArray</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">EvokedArray</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">create_info</span></code></p>
</div>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.annotations" title="mne.io.RawArray.annotations"><code class="xref py py-obj docutils literal"><span class="pre">annotations</span></code></a></td>
<td>Annotations for marking segments of data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.ch_names" title="mne.io.RawArray.ch_names"><code class="xref py py-obj docutils literal"><span class="pre">ch_names</span></code></a></td>
<td>Channel names.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.compensation_grade" title="mne.io.RawArray.compensation_grade"><code class="xref py py-obj docutils literal"><span class="pre">compensation_grade</span></code></a></td>
<td>The current gradient compensation grade.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.first_samp" title="mne.io.RawArray.first_samp"><code class="xref py py-obj docutils literal"><span class="pre">first_samp</span></code></a></td>
<td>The first data sample.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.last_samp" title="mne.io.RawArray.last_samp"><code class="xref py py-obj docutils literal"><span class="pre">last_samp</span></code></a></td>
<td>The last data sample.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.n_times" title="mne.io.RawArray.n_times"><code class="xref py py-obj docutils literal"><span class="pre">n_times</span></code></a></td>
<td>Number of time points.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.proj" title="mne.io.RawArray.proj"><code class="xref py py-obj docutils literal"><span class="pre">proj</span></code></a></td>
<td>Whether or not projections are active.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.times" title="mne.io.RawArray.times"><code class="xref py py-obj docutils literal"><span class="pre">times</span></code></a></td>
<td>Time points.</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.__contains__" title="mne.io.RawArray.__contains__"><code class="xref py py-obj docutils literal"><span class="pre">__contains__</span></code></a>(ch_type)</td>
<td>Check channel type membership.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.__getitem__" title="mne.io.RawArray.__getitem__"><code class="xref py py-obj docutils literal"><span class="pre">__getitem__</span></code></a>(item)</td>
<td>Get raw data and times.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.__hash__" title="mne.io.RawArray.__hash__"><code class="xref py py-obj docutils literal"><span class="pre">__hash__</span></code></a>()</td>
<td>Hash the object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.__len__" title="mne.io.RawArray.__len__"><code class="xref py py-obj docutils literal"><span class="pre">__len__</span></code></a>()</td>
<td>The number of time points.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.add_channels" title="mne.io.RawArray.add_channels"><code class="xref py py-obj docutils literal"><span class="pre">add_channels</span></code></a>(add_list[,&nbsp;force_update_info])</td>
<td>Append new channels to the instance.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.add_events" title="mne.io.RawArray.add_events"><code class="xref py py-obj docutils literal"><span class="pre">add_events</span></code></a>(events[,&nbsp;stim_channel])</td>
<td>Add events to stim channel.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.add_proj" title="mne.io.RawArray.add_proj"><code class="xref py py-obj docutils literal"><span class="pre">add_proj</span></code></a>(projs[,&nbsp;remove_existing,&nbsp;verbose])</td>
<td>Add SSP projection vectors.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.anonymize" title="mne.io.RawArray.anonymize"><code class="xref py py-obj docutils literal"><span class="pre">anonymize</span></code></a>()</td>
<td>Anonymize measurement information in place.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.append" title="mne.io.RawArray.append"><code class="xref py py-obj docutils literal"><span class="pre">append</span></code></a>(raws[,&nbsp;preload])</td>
<td>Concatenate raw instances as if they were continuous.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.apply_function" title="mne.io.RawArray.apply_function"><code class="xref py py-obj docutils literal"><span class="pre">apply_function</span></code></a>(fun,&nbsp;picks,&nbsp;dtype,&nbsp;n_jobs,&nbsp;...)</td>
<td>Apply a function to a subset of channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.apply_gradient_compensation" title="mne.io.RawArray.apply_gradient_compensation"><code class="xref py py-obj docutils literal"><span class="pre">apply_gradient_compensation</span></code></a>(grade[,&nbsp;verbose])</td>
<td>Apply CTF gradient compensation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.apply_hilbert" title="mne.io.RawArray.apply_hilbert"><code class="xref py py-obj docutils literal"><span class="pre">apply_hilbert</span></code></a>(picks[,&nbsp;envelope,&nbsp;n_jobs,&nbsp;...])</td>
<td>Compute analytic signal or envelope for a subset of channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.apply_proj" title="mne.io.RawArray.apply_proj"><code class="xref py py-obj docutils literal"><span class="pre">apply_proj</span></code></a>()</td>
<td>Apply the signal space projection (SSP) operators to the data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.close" title="mne.io.RawArray.close"><code class="xref py py-obj docutils literal"><span class="pre">close</span></code></a>()</td>
<td>Clean up the object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.copy" title="mne.io.RawArray.copy"><code class="xref py py-obj docutils literal"><span class="pre">copy</span></code></a>()</td>
<td>Return copy of Raw instance.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.crop" title="mne.io.RawArray.crop"><code class="xref py py-obj docutils literal"><span class="pre">crop</span></code></a>([tmin,&nbsp;tmax])</td>
<td>Crop raw data file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.del_proj" title="mne.io.RawArray.del_proj"><code class="xref py py-obj docutils literal"><span class="pre">del_proj</span></code></a>(idx)</td>
<td>Remove SSP projection vector.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.drop_channels" title="mne.io.RawArray.drop_channels"><code class="xref py py-obj docutils literal"><span class="pre">drop_channels</span></code></a>(ch_names)</td>
<td>Drop some channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.estimate_rank" title="mne.io.RawArray.estimate_rank"><code class="xref py py-obj docutils literal"><span class="pre">estimate_rank</span></code></a>([tstart,&nbsp;tstop,&nbsp;tol,&nbsp;...])</td>
<td>Estimate rank of the raw data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.filter" title="mne.io.RawArray.filter"><code class="xref py py-obj docutils literal"><span class="pre">filter</span></code></a>(l_freq,&nbsp;h_freq[,&nbsp;picks,&nbsp;...])</td>
<td>Filter a subset of channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.interpolate_bads" title="mne.io.RawArray.interpolate_bads"><code class="xref py py-obj docutils literal"><span class="pre">interpolate_bads</span></code></a>([reset_bads,&nbsp;mode])</td>
<td>Interpolate bad MEG and EEG channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.load_bad_channels" title="mne.io.RawArray.load_bad_channels"><code class="xref py py-obj docutils literal"><span class="pre">load_bad_channels</span></code></a>([bad_file,&nbsp;force])</td>
<td>Mark channels as bad from a text file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.load_data" title="mne.io.RawArray.load_data"><code class="xref py py-obj docutils literal"><span class="pre">load_data</span></code></a>([verbose])</td>
<td>Load raw data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.notch_filter" title="mne.io.RawArray.notch_filter"><code class="xref py py-obj docutils literal"><span class="pre">notch_filter</span></code></a>(freqs[,&nbsp;picks,&nbsp;filter_length,&nbsp;...])</td>
<td>Notch filter a subset of channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.pick_channels" title="mne.io.RawArray.pick_channels"><code class="xref py py-obj docutils literal"><span class="pre">pick_channels</span></code></a>(ch_names)</td>
<td>Pick some channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.pick_types" title="mne.io.RawArray.pick_types"><code class="xref py py-obj docutils literal"><span class="pre">pick_types</span></code></a>([meg,&nbsp;eeg,&nbsp;stim,&nbsp;eog,&nbsp;ecg,&nbsp;emg,&nbsp;...])</td>
<td>Pick some channels by type and names.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.plot" title="mne.io.RawArray.plot"><code class="xref py py-obj docutils literal"><span class="pre">plot</span></code></a>([events,&nbsp;duration,&nbsp;start,&nbsp;n_channels,&nbsp;...])</td>
<td>Plot raw data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.plot_projs_topomap" title="mne.io.RawArray.plot_projs_topomap"><code class="xref py py-obj docutils literal"><span class="pre">plot_projs_topomap</span></code></a>([ch_type,&nbsp;layout,&nbsp;axes])</td>
<td>Plot SSP vector.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.plot_psd" title="mne.io.RawArray.plot_psd"><code class="xref py py-obj docutils literal"><span class="pre">plot_psd</span></code></a>([tmin,&nbsp;tmax,&nbsp;fmin,&nbsp;fmax,&nbsp;proj,&nbsp;...])</td>
<td>Plot the power spectral density across channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.plot_psd_topo" title="mne.io.RawArray.plot_psd_topo"><code class="xref py py-obj docutils literal"><span class="pre">plot_psd_topo</span></code></a>([tmin,&nbsp;tmax,&nbsp;fmin,&nbsp;fmax,&nbsp;...])</td>
<td>Plot channel-wise frequency spectra as topography.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.plot_sensors" title="mne.io.RawArray.plot_sensors"><code class="xref py py-obj docutils literal"><span class="pre">plot_sensors</span></code></a>([kind,&nbsp;ch_type,&nbsp;title,&nbsp;...])</td>
<td>Plot sensor positions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.rename_channels" title="mne.io.RawArray.rename_channels"><code class="xref py py-obj docutils literal"><span class="pre">rename_channels</span></code></a>(mapping)</td>
<td>Rename channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.resample" title="mne.io.RawArray.resample"><code class="xref py py-obj docutils literal"><span class="pre">resample</span></code></a>(sfreq[,&nbsp;npad,&nbsp;window,&nbsp;stim_picks,&nbsp;...])</td>
<td>Resample all channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.save" title="mne.io.RawArray.save"><code class="xref py py-obj docutils literal"><span class="pre">save</span></code></a>(fname[,&nbsp;picks,&nbsp;tmin,&nbsp;tmax,&nbsp;...])</td>
<td>Save raw data to file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.set_channel_types" title="mne.io.RawArray.set_channel_types"><code class="xref py py-obj docutils literal"><span class="pre">set_channel_types</span></code></a>(mapping)</td>
<td>Define the sensor type of channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.set_eeg_reference" title="mne.io.RawArray.set_eeg_reference"><code class="xref py py-obj docutils literal"><span class="pre">set_eeg_reference</span></code></a>([ref_channels])</td>
<td>Rereference EEG channels to new reference channel(s).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.set_montage" title="mne.io.RawArray.set_montage"><code class="xref py py-obj docutils literal"><span class="pre">set_montage</span></code></a>(montage[,&nbsp;verbose])</td>
<td>Set EEG sensor configuration.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.time_as_index" title="mne.io.RawArray.time_as_index"><code class="xref py py-obj docutils literal"><span class="pre">time_as_index</span></code></a>(times[,&nbsp;use_rounding])</td>
<td>Convert time to indices.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.to_data_frame" title="mne.io.RawArray.to_data_frame"><code class="xref py py-obj docutils literal"><span class="pre">to_data_frame</span></code></a>([picks,&nbsp;index,&nbsp;scale_time,&nbsp;...])</td>
<td>Export data in tabular structure as a pandas DataFrame.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mne.io.RawArray.__contains__">
<code class="descname">__contains__</code><span class="sig-paren">(</span><em>ch_type</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Check channel type membership.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_type</strong> : str</p>
<blockquote>
<div><p>Channel type to check for. Can be e.g. &#8216;meg&#8217;, &#8216;eeg&#8217;, &#8216;stim&#8217;, etc.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>in</strong> : bool</p>
<blockquote class="last">
<div><p>Whether or not the instance contains the given channel type.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Channel type membership can be tested as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;meg&#39;</span> <span class="ow">in</span> <span class="n">inst</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;seeg&#39;</span> <span class="ow">in</span> <span class="n">inst</span>  
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get raw data and times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>item</strong> : tuple or array-like</p>
<blockquote>
<div><p>See below for use cases.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>data</strong> : ndarray, shape (n_channels, n_times)</p>
<blockquote>
<div><p>The raw data.</p>
</div></blockquote>
<p><strong>times</strong> : ndarray, shape (n_times,)</p>
<blockquote class="last">
<div><p>The times associated with the data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Generally raw data is accessed as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">time_slice</span><span class="p">]</span>  
</pre></div>
</div>
<p>To get all data, you can thus do either of:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[:]</span>  
</pre></div>
</div>
<p>Which will be equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[:,</span> <span class="p">:]</span>  
</pre></div>
</div>
<p>To get only the good MEG data from 10-20 seconds, you could do:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">picks</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">pick_types</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">meg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="s1">&#39;bads&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_idx</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">time_as_index</span><span class="p">([</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">20.</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">t_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.__hash__">
<code class="descname">__hash__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>hash</strong> : int</p>
<blockquote class="last">
<div><p>The hash</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.__len__">
<code class="descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of time points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>len</strong> : int</p>
<blockquote class="last">
<div><p>The number of time points.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>This can be used as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>  
<span class="go">1000</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.add_channels">
<code class="descname">add_channels</code><span class="sig-paren">(</span><em>add_list</em>, <em>force_update_info=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.add_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Append new channels to the instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>add_list</strong> : list</p>
<blockquote>
<div><p>A list of objects to append to self. Must contain all the same
type as the current object</p>
</div></blockquote>
<p><strong>force_update_info</strong> : bool</p>
<blockquote>
<div><p>If True, force the info for objects to be appended to match the
values in <cite>self</cite>. This should generally only be used when adding
stim channels for which important metadata won&#8217;t be overwritten.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.</span></p>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.add_events">
<code class="descname">add_events</code><span class="sig-paren">(</span><em>events</em>, <em>stim_channel=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.add_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Add events to stim channel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>events</strong> : ndarray, shape (n_events, 3)</p>
<blockquote>
<div><p>Events to add. The first column specifies the sample number of
each event, the second column is ignored, and the third column
provides the event value. If events already exist in the Raw
instance at the given sample numbers, the event values will be
added together.</p>
</div></blockquote>
<p><strong>stim_channel</strong> : str | None</p>
<blockquote class="last">
<div><p>Name of the stim channel to add to. If None, the config variable
&#8216;MNE_STIM_CHANNEL&#8217; is used. If this is not found, it will default
to &#8216;STI 014&#8217;.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Data must be preloaded in order to add events.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.add_proj">
<code class="descname">add_proj</code><span class="sig-paren">(</span><em>projs</em>, <em>remove_existing=False</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.add_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Add SSP projection vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>projs</strong> : list</p>
<blockquote>
<div><p>List with projection vectors.</p>
</div></blockquote>
<p><strong>remove_existing</strong> : bool</p>
<blockquote>
<div><p>Remove the projection vectors currently in the file.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
<blockquote class="last">
<div><p>The data container.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mne.io.RawArray.annotations">
<code class="descname">annotations</code><a class="headerlink" href="#mne.io.RawArray.annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotations for marking segments of data.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.anonymize">
<code class="descname">anonymize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.anonymize" title="Permalink to this definition">¶</a></dt>
<dd><p>Anonymize measurement information in place.</p>
<p>Reset &#8216;subject_info&#8217;, &#8216;meas_date&#8217;, &#8216;file_id&#8217;, and &#8216;meas_id&#8217; keys if they
exist in <code class="docutils literal"><span class="pre">info</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>info</strong> : instance of Info</p>
<blockquote class="last">
<div><p>Measurement information for the dataset.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Operates in place.</p>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>raws</em>, <em>preload=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate raw instances as if they were continuous.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>raws</strong> : list, or Raw instance</p>
<blockquote>
<div><p>list of Raw instances to concatenate to the current instance
(in order), or a single raw instance to concatenate.</p>
</div></blockquote>
<p><strong>preload</strong> : bool, str, or None (default None)</p>
<blockquote class="last">
<div><p>Preload data into memory for data manipulation and faster indexing.
If True, the data will be preloaded into memory (fast, requires
large amount of memory). If preload is a string, preload is the
file name of a memory-mapped file which is used to store the data
on the hard drive (slower, requires less memory). If preload is
None, preload=True or False is inferred using the preload status
of the raw files passed in.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.apply_function">
<code class="descname">apply_function</code><span class="sig-paren">(</span><em>fun</em>, <em>picks</em>, <em>dtype</em>, <em>n_jobs</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.apply_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function to a subset of channels.</p>
<p>The function &#8220;fun&#8221; is applied to the channels defined in &#8220;picks&#8221;. The
data of the Raw object is modified inplace. If the function returns
a different data type (e.g. numpy.complex) it must be specified using
the dtype parameter, which causes the data type used for representing
the raw data to change.</p>
<p>The Raw object has to have the data loaded e.g. with <code class="docutils literal"><span class="pre">preload=True</span></code>
or <code class="docutils literal"><span class="pre">self.load_data()</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If n_jobs &gt; 1, more memory is required as
<code class="docutils literal"><span class="pre">len(picks)</span> <span class="pre">*</span> <span class="pre">n_times</span></code> additional time points need to
be temporaily stored in memory.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the data type changes (dtype != None), more memory is
required since the original and the converted data needs
to be stored in memory.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fun</strong> : function</p>
<blockquote>
<div><p>A function to be applied to the channels. The first argument of
fun has to be a timeseries (numpy.ndarray). The function must
return an numpy.ndarray with the same size as the input.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>Indices of channels to apply the function to. If None, all
M-EEG channels are used.</p>
</div></blockquote>
<p><strong>dtype</strong> : numpy.dtype</p>
<blockquote>
<div><p>Data type to use for raw data after applying the function. If None
the data type is not modified.</p>
</div></blockquote>
<p><strong>n_jobs: int</strong></p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
<p><strong>*args :</strong></p>
<blockquote>
<div><p>Additional positional arguments to pass to fun (first pos. argument
of fun is the timeseries of a channel).</p>
</div></blockquote>
<p><strong>**kwargs :</strong></p>
<blockquote class="last">
<div><p>Keyword arguments to pass to fun. Note that if &#8220;verbose&#8221; is passed
as a member of <code class="docutils literal"><span class="pre">kwargs</span></code>, it will be consumed and will override
the default mne-python verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.apply_gradient_compensation">
<code class="descname">apply_gradient_compensation</code><span class="sig-paren">(</span><em>grade</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.apply_gradient_compensation" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply CTF gradient compensation.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The compensation matrices are stored with single
precision, so repeatedly switching between different
of compensation (e.g., 0-&gt;1-&gt;3-&gt;2) can increase
numerical noise, especially if data are saved to
disk in between changing grades. It is thus best to
only use a single gradient compensation level in
final analyses.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>grade</strong> : int</p>
<blockquote>
<div><p>CTF gradient compensation level.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw</strong> : instance of Raw</p>
<blockquote class="last">
<div><p>The modified Raw instance. Works in-place.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.apply_hilbert">
<code class="descname">apply_hilbert</code><span class="sig-paren">(</span><em>picks</em>, <em>envelope=False</em>, <em>n_jobs=1</em>, <em>n_fft='auto'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.apply_hilbert" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute analytic signal or envelope for a subset of channels.</p>
<p>If envelope=False, the analytic signal for the channels defined in
&#8220;picks&#8221; is computed and the data of the Raw object is converted to
a complex representation (the analytic signal is complex valued).</p>
<p>If envelope=True, the absolute value of the analytic signal for the
channels defined in &#8220;picks&#8221; is computed, resulting in the envelope
signal.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If envelope=False, more memory is required since the
original raw data as well as the analytic signal have
temporarily to be stored in memory.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If n_jobs &gt; 1, more memory is required as
<code class="docutils literal"><span class="pre">len(picks)</span> <span class="pre">*</span> <span class="pre">n_times</span></code> additional time points need to
be temporaily stored in memory.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int</p>
<blockquote>
<div><p>Indices of channels to apply the function to.</p>
</div></blockquote>
<p><strong>envelope</strong> : bool (default: False)</p>
<blockquote>
<div><p>Compute the envelope signal of each channel.</p>
</div></blockquote>
<p><strong>n_jobs: int</strong></p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
<p><strong>n_fft</strong> : int | None | str</p>
<blockquote>
<div><p>Points to use in the FFT for Hilbert transformation. The signal
will be padded with zeros before computing Hilbert, then cut back
to original length. If None, n == self.n_times. If &#8216;auto&#8217;,
the next highest fast FFT length will be use.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The analytic signal &#8220;x_a(t)&#8221; of &#8220;x(t)&#8221; is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x_a</span> <span class="o">=</span> <span class="n">F</span><span class="o">^</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">}(</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="mi">2</span><span class="n">U</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">i</span> <span class="n">y</span>
</pre></div>
</div>
<p>where &#8220;F&#8221; is the Fourier transform, &#8220;U&#8221; the unit step function,
and &#8220;y&#8221; the Hilbert transform of &#8220;x&#8221;. One usage of the analytic
signal is the computation of the envelope signal, which is given by
&#8220;e(t) = abs(x_a(t))&#8221;. Due to the linearity of Hilbert transform and the
MNE inverse solution, the enevlope in source space can be obtained
by computing the analytic signal in sensor space, applying the MNE
inverse, and computing the envelope in source space.</p>
<p>Also note that the n_fft parameter will allow you to pad the signal
with zeros before performing the Hilbert transform. This padding
is cut off, but it may result in a slightly different result
(particularly around the edges). Use at your own risk.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.apply_proj">
<code class="descname">apply_proj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.apply_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the signal space projection (SSP) operators to the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
<blockquote class="last">
<div><p>The instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Once the projectors have been applied, they can no longer be
removed. It is usually not recommended to apply the projectors at
too early stages, as they are applied automatically later on
(e.g. when computing inverse solutions).
Hint: using the copy method individual projection vectors
can be tested without affecting the original data.
With evoked data, consider the following example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">projs_a</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_proj</span><span class="p">(</span><span class="s1">&#39;proj_a.fif&#39;</span><span class="p">)</span>
<span class="n">projs_b</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_proj</span><span class="p">(</span><span class="s1">&#39;proj_b.fif&#39;</span><span class="p">)</span>
<span class="c1"># add the first, copy, apply and see ...</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">add_proj</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c1"># add the second, copy, apply and see ...</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">add_proj</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c1"># drop the first and see again</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">del_proj</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span>  <span class="c1"># finally keep both</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mne.io.RawArray.ch_names">
<code class="descname">ch_names</code><a class="headerlink" href="#mne.io.RawArray.ch_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Channel names.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up the object.</p>
<p>Does nothing for objects that close their file descriptors.
Things like RawFIF will override this method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.io.RawArray.compensation_grade">
<code class="descname">compensation_grade</code><a class="headerlink" href="#mne.io.RawArray.compensation_grade" title="Permalink to this definition">¶</a></dt>
<dd><p>The current gradient compensation grade.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return copy of Raw instance.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.crop">
<code class="descname">crop</code><span class="sig-paren">(</span><em>tmin=0.0</em>, <em>tmax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop raw data file.</p>
<p>Limit the data from the raw file to go between specific times. Note
that the new tmin is assumed to be t=0 for all subsequently called
functions (e.g., time_as_index, or Epochs). New first_samp and
last_samp are set accordingly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tmin</strong> : float</p>
<blockquote>
<div><p>New start time in seconds (must be &gt;= 0).</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote>
<div><p>New end time in seconds of the data (cannot exceed data duration).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw</strong> : instance of Raw</p>
<blockquote class="last">
<div><p>The cropped raw object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.del_proj">
<code class="descname">del_proj</code><span class="sig-paren">(</span><em>idx</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.del_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove SSP projection vector.</p>
<dl class="docutils">
<dt>Note: The projection vector can only be removed if it is inactive</dt>
<dd>(has not been applied to the data).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>idx</strong> : int</p>
<blockquote>
<div><p>Index of the projector to remove.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.drop_channels">
<code class="descname">drop_channels</code><span class="sig-paren">(</span><em>ch_names</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.drop_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop some channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_names</strong> : list</p>
<blockquote>
<div><p>List of the names of the channels to remove.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.io.RawArray.pick_channels" title="mne.io.RawArray.pick_channels"><code class="xref py py-obj docutils literal"><span class="pre">pick_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.estimate_rank">
<code class="descname">estimate_rank</code><span class="sig-paren">(</span><em>tstart=0.0</em>, <em>tstop=30.0</em>, <em>tol=0.0001</em>, <em>return_singular=False</em>, <em>picks=None</em>, <em>scalings='norm'</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.estimate_rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate rank of the raw data.</p>
<p>This function is meant to provide a reasonable estimate of the rank.
The true rank of the data depends on many factors, so use at your
own risk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tstart</strong> : float</p>
<blockquote>
<div><p>Start time to use for rank estimation. Default is 0.0.</p>
</div></blockquote>
<p><strong>tstop</strong> : float | None</p>
<blockquote>
<div><p>End time to use for rank estimation. Default is 30.0.
If None, the end time of the raw file is used.</p>
</div></blockquote>
<p><strong>tol</strong> : float</p>
<blockquote>
<div><p>Tolerance for singular values to consider non-zero in
calculating the rank. The singular values are calculated
in this method such that independent data are expected to
have singular value around one.</p>
</div></blockquote>
<p><strong>return_singular</strong> : bool</p>
<blockquote>
<div><p>If True, also return the singular values that were used
to determine the rank.</p>
</div></blockquote>
<p><strong>picks</strong> : array_like of int, shape (n_selected_channels,)</p>
<blockquote>
<div><p>The channels to be considered for rank estimation.
If None (default) meg and eeg channels are included.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | &#8216;norm&#8217;</p>
<blockquote>
<div><p>To achieve reliable rank estimation on multiple sensors,
sensors have to be rescaled. This parameter controls the
rescaling. If dict, it will update the
following dict of defaults:</p>
<blockquote>
<div><p>dict(mag=1e11, grad=1e9, eeg=1e5)</p>
</div></blockquote>
<p>If &#8216;norm&#8217; data will be scaled by internally computed
channel-wise norms.
Defaults to &#8216;norm&#8217;.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rank</strong> : int</p>
<blockquote>
<div><p>Estimated rank of the data.</p>
</div></blockquote>
<p><strong>s</strong> : array</p>
<blockquote class="last">
<div><p>If return_singular is True, the singular values that were
thresholded to determine the rank are also returned.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If data are not pre-loaded, the appropriate data will be loaded
by this function (can be memory intensive).</p>
<p>Projectors are not taken into account unless they have been applied
to the data using apply_proj(), since it is not always possible
to tell whether or not projectors have been applied previously.</p>
<p>Bad channels will be excluded from calculations.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>l_freq</em>, <em>h_freq</em>, <em>picks=None</em>, <em>filter_length='auto'</em>, <em>l_trans_bandwidth='auto'</em>, <em>h_trans_bandwidth='auto'</em>, <em>n_jobs=1</em>, <em>method='fir'</em>, <em>iir_params=None</em>, <em>phase='zero'</em>, <em>fir_window='hamming'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter a subset of channels.</p>
<p>Applies a zero-phase low-pass, high-pass, band-pass, or band-stop
filter to the channels selected by <code class="docutils literal"><span class="pre">picks</span></code>. By default the data
of the Raw object is modified inplace.</p>
<p>The Raw object has to have the data loaded e.g. with <code class="docutils literal"><span class="pre">preload=True</span></code>
or <code class="docutils literal"><span class="pre">self.load_data()</span></code>.</p>
<p><code class="docutils literal"><span class="pre">l_freq</span></code> and <code class="docutils literal"><span class="pre">h_freq</span></code> are the frequencies below which and above
which, respectively, to filter out of the data. Thus the uses are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">l_freq</span> <span class="pre">&lt;</span> <span class="pre">h_freq</span></code>: band-pass filter</li>
<li><code class="docutils literal"><span class="pre">l_freq</span> <span class="pre">&gt;</span> <span class="pre">h_freq</span></code>: band-stop filter</li>
<li><code class="docutils literal"><span class="pre">l_freq</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span> <span class="pre">and</span> <span class="pre">h_freq</span> <span class="pre">is</span> <span class="pre">None</span></code>: high-pass filter</li>
<li><code class="docutils literal"><span class="pre">l_freq</span> <span class="pre">is</span> <span class="pre">None</span> <span class="pre">and</span> <span class="pre">h_freq</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code>: low-pass filter</li>
</ul>
</div></blockquote>
<p><code class="docutils literal"><span class="pre">self.info['lowpass']</span></code> and <code class="docutils literal"><span class="pre">self.info['highpass']</span></code> are only
updated with picks=None.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If n_jobs &gt; 1, more memory is required as
<code class="docutils literal"><span class="pre">len(picks)</span> <span class="pre">*</span> <span class="pre">n_times</span></code> additional time points need to
be temporaily stored in memory.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>l_freq</strong> : float | None</p>
<blockquote>
<div><p>Low cut-off frequency in Hz. If None the data are only low-passed.</p>
</div></blockquote>
<p><strong>h_freq</strong> : float | None</p>
<blockquote>
<div><p>High cut-off frequency in Hz. If None the data are only
high-passed.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>Indices of channels to filter. If None only the data (MEG/EEG)
channels will be filtered.</p>
</div></blockquote>
<p><strong>filter_length</strong> : str | int</p>
<blockquote>
<div><p>Length of the FIR filter to use (if applicable):</p>
<blockquote>
<div><ul class="simple">
<li>int: specified length in samples.</li>
<li>&#8216;auto&#8217; (default): the filter length is chosen based
on the size of the transition regions (6.6 times the
reciprocal of the shortest transition band for
fir_window=&#8217;hamming&#8217;).</li>
<li>str: a human-readable time in
units of &#8220;s&#8221; or &#8220;ms&#8221; (e.g., &#8220;10s&#8221; or &#8220;5500ms&#8221;) will be
converted to that number of samples if <code class="docutils literal"><span class="pre">phase=&quot;zero&quot;</span></code>, or
the shortest power-of-two length at least that duration for
<code class="docutils literal"><span class="pre">phase=&quot;zero-double&quot;</span></code>.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>l_trans_bandwidth</strong> : float | str</p>
<blockquote>
<div><p>Width of the transition band at the low cut-off frequency in Hz
(high pass or cutoff 1 in bandpass). Can be &#8220;auto&#8221;
(default) to use a multiple of <code class="docutils literal"><span class="pre">l_freq</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">l_freq</span> <span class="o">*</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">l_freq</span><span class="p">)</span>
</pre></div>
</div>
<p>Only used for <code class="docutils literal"><span class="pre">method='fir'</span></code>.</p>
</div></blockquote>
<p><strong>h_trans_bandwidth</strong> : float | str</p>
<blockquote>
<div><p>Width of the transition band at the high cut-off frequency in Hz
(low pass or cutoff 2 in bandpass). Can be &#8220;auto&#8221;
(default) to use a multiple of <code class="docutils literal"><span class="pre">h_freq</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">h_freq</span> <span class="o">*</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">-</span> <span class="n">h_freq</span><span class="p">)</span>
</pre></div>
</div>
<p>Only used for <code class="docutils literal"><span class="pre">method='fir'</span></code>.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int | str</p>
<blockquote>
<div><p>Number of jobs to run in parallel. Can be &#8216;cuda&#8217; if scikits.cuda
is installed properly, CUDA is initialized, and method=&#8217;fir&#8217;.</p>
</div></blockquote>
<p><strong>method</strong> : str</p>
<blockquote>
<div><p>&#8216;fir&#8217; will use overlap-add FIR filtering, &#8216;iir&#8217; will use IIR
forward-backward filtering (via filtfilt).</p>
</div></blockquote>
<p><strong>iir_params</strong> : dict | None</p>
<blockquote>
<div><p>Dictionary of parameters to use for IIR filtering.
See mne.filter.construct_iir_filter for details. If iir_params
is None and method=&#8221;iir&#8221;, 4th order Butterworth will be used.</p>
</div></blockquote>
<p><strong>phase</strong> : str</p>
<blockquote>
<div><p>Phase of the filter, only used if <code class="docutils literal"><span class="pre">method='fir'</span></code>.
By default, a symmetric linear-phase FIR filter is constructed.
If <code class="docutils literal"><span class="pre">phase='zero'</span></code> (default), the delay of this filter
is compensated for. If <code class="docutils literal"><span class="pre">phase=='zero-double'</span></code>, then this
filter is applied twice, once forward, and once backward.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.13.</span></p>
</div>
</div></blockquote>
<p><strong>fir_window</strong> : str</p>
<blockquote>
<div><p>The window to use in FIR design, can be &#8220;hamming&#8221; (default),
&#8220;hann&#8221; (default in 0.13), or &#8220;blackman&#8221;.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.13.</span></p>
</div>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw</strong> : instance of Raw</p>
<blockquote class="last">
<div><p>The raw instance with filtered data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.Epochs.html#mne.Epochs.savgol_filter" title="mne.Epochs.savgol_filter"><code class="xref py py-obj docutils literal"><span class="pre">mne.Epochs.savgol_filter</span></code></a>, <a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.notch_filter" title="mne.io.Raw.notch_filter"><code class="xref py py-obj docutils literal"><span class="pre">mne.io.Raw.notch_filter</span></code></a>, <a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.resample" title="mne.io.Raw.resample"><code class="xref py py-obj docutils literal"><span class="pre">mne.io.Raw.resample</span></code></a>, <a class="reference internal" href="mne.filter.filter_data.html#mne.filter.filter_data" title="mne.filter.filter_data"><code class="xref py py-obj docutils literal"><span class="pre">mne.filter.filter_data</span></code></a>, <a class="reference internal" href="mne.filter.construct_iir_filter.html#mne.filter.construct_iir_filter" title="mne.filter.construct_iir_filter"><code class="xref py py-obj docutils literal"><span class="pre">mne.filter.construct_iir_filter</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>For more information, see the tutorials <a class="reference internal" href="../auto_tutorials/plot_background_filtering.html#tut-background-filtering"><span class="std std-ref">Background information on filtering</span></a>
and <a class="reference internal" href="../auto_tutorials/plot_artifacts_correction_filtering.html#tut-artifacts-filter"><span class="std std-ref">Filtering and resampling data</span></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.io.RawArray.first_samp">
<code class="descname">first_samp</code><a class="headerlink" href="#mne.io.RawArray.first_samp" title="Permalink to this definition">¶</a></dt>
<dd><p>The first data sample.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.interpolate_bads">
<code class="descname">interpolate_bads</code><span class="sig-paren">(</span><em>reset_bads=True</em>, <em>mode='accurate'</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.interpolate_bads" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate bad MEG and EEG channels.</p>
<p>Operates in place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reset_bads</strong> : bool</p>
<blockquote>
<div><p>If True, remove the bads from info.</p>
</div></blockquote>
<p><strong>mode</strong> : str</p>
<blockquote>
<div><p>Either <cite>&#8216;accurate&#8217;</cite> or <cite>&#8216;fast&#8217;</cite>, determines the quality of the
Legendre polynomial expansion used for interpolation of MEG
channels.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mne.io.RawArray.last_samp">
<code class="descname">last_samp</code><a class="headerlink" href="#mne.io.RawArray.last_samp" title="Permalink to this definition">¶</a></dt>
<dd><p>The last data sample.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.load_bad_channels">
<code class="descname">load_bad_channels</code><span class="sig-paren">(</span><em>bad_file=None</em>, <em>force=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.load_bad_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark channels as bad from a text file.</p>
<p>This function operates mostly in the style of the C function
<code class="docutils literal"><span class="pre">mne_mark_bad_channels</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bad_file</strong> : string</p>
<blockquote>
<div><p>File name of the text file containing bad channels
If bad_file = None, bad channels are cleared, but this
is more easily done directly as raw.info[&#8216;bads&#8217;] = [].</p>
</div></blockquote>
<p><strong>force</strong> : boolean</p>
<blockquote class="last">
<div><p>Whether or not to force bad channel marking (of those
that exist) if channels are not found, instead of
raising an error.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.load_data">
<code class="descname">load_data</code><span class="sig-paren">(</span><em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.load_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Load raw data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw</strong> : instance of Raw</p>
<blockquote class="last">
<div><p>The raw object with data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function will load raw data if it was not already preloaded.
If data were already preloaded, it will do nothing.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mne.io.RawArray.n_times">
<code class="descname">n_times</code><a class="headerlink" href="#mne.io.RawArray.n_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of time points.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.notch_filter">
<code class="descname">notch_filter</code><span class="sig-paren">(</span><em>freqs</em>, <em>picks=None</em>, <em>filter_length='auto'</em>, <em>notch_widths=None</em>, <em>trans_bandwidth=1.0</em>, <em>n_jobs=1</em>, <em>method='fft'</em>, <em>iir_params=None</em>, <em>mt_bandwidth=None</em>, <em>p_value=0.05</em>, <em>phase='zero'</em>, <em>fir_window='hamming'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.notch_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Notch filter a subset of channels.</p>
<p>Applies a zero-phase notch filter to the channels selected by
&#8220;picks&#8221;. By default the data of the Raw object is modified inplace.</p>
<p>The Raw object has to have the data loaded e.g. with <code class="docutils literal"><span class="pre">preload=True</span></code>
or <code class="docutils literal"><span class="pre">self.load_data()</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If n_jobs &gt; 1, more memory is required as
<code class="docutils literal"><span class="pre">len(picks)</span> <span class="pre">*</span> <span class="pre">n_times</span></code> additional time points need to
be temporaily stored in memory.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>freqs</strong> : float | array of float | None</p>
<blockquote>
<div><p>Specific frequencies to filter out from data, e.g.,
np.arange(60, 241, 60) in the US or np.arange(50, 251, 50) in
Europe. None can only be used with the mode &#8216;spectrum_fit&#8217;,
where an F test is used to find sinusoidal components.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>Indices of channels to filter. If None only the data (MEG/EEG)
channels will be filtered.</p>
</div></blockquote>
<p><strong>filter_length</strong> : str | int</p>
<blockquote>
<div><p>Length of the FIR filter to use (if applicable):</p>
<blockquote>
<div><ul class="simple">
<li>int: specified length in samples.</li>
<li>&#8216;auto&#8217; (default): the filter length is chosen based
on the size of the transition regions (6.6 times the
reciprocal of the shortest transition band for
fir_window=&#8217;hamming&#8217;).</li>
<li>str: a human-readable time in
units of &#8220;s&#8221; or &#8220;ms&#8221; (e.g., &#8220;10s&#8221; or &#8220;5500ms&#8221;) will be
converted to that number of samples if <code class="docutils literal"><span class="pre">phase=&quot;zero&quot;</span></code>, or
the shortest power-of-two length at least that duration for
<code class="docutils literal"><span class="pre">phase=&quot;zero-double&quot;</span></code>.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>notch_widths</strong> : float | array of float | None</p>
<blockquote>
<div><p>Width of each stop band (centred at each freq in freqs) in Hz.
If None, freqs / 200 is used.</p>
</div></blockquote>
<p><strong>trans_bandwidth</strong> : float</p>
<blockquote>
<div><p>Width of the transition band in Hz.
Only used for <code class="docutils literal"><span class="pre">method='fir'</span></code>.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int | str</p>
<blockquote>
<div><p>Number of jobs to run in parallel. Can be &#8216;cuda&#8217; if scikits.cuda
is installed properly, CUDA is initialized, and method=&#8217;fir&#8217;.</p>
</div></blockquote>
<p><strong>method</strong> : str</p>
<blockquote>
<div><p>&#8216;fir&#8217; will use overlap-add FIR filtering, &#8216;iir&#8217; will use IIR
forward-backward filtering (via filtfilt). &#8216;spectrum_fit&#8217; will
use multi-taper estimation of sinusoidal components.</p>
</div></blockquote>
<p><strong>iir_params</strong> : dict | None</p>
<blockquote>
<div><p>Dictionary of parameters to use for IIR filtering.
See mne.filter.construct_iir_filter for details. If iir_params
is None and method=&#8221;iir&#8221;, 4th order Butterworth will be used.</p>
</div></blockquote>
<p><strong>mt_bandwidth</strong> : float | None</p>
<blockquote>
<div><p>The bandwidth of the multitaper windowing function in Hz.
Only used in &#8216;spectrum_fit&#8217; mode.</p>
</div></blockquote>
<p><strong>p_value</strong> : float</p>
<blockquote>
<div><p>p-value to use in F-test thresholding to determine significant
sinusoidal components to remove when method=&#8217;spectrum_fit&#8217; and
freqs=None. Note that this will be Bonferroni corrected for the
number of frequencies, so large p-values may be justified.</p>
</div></blockquote>
<p><strong>phase</strong> : str</p>
<blockquote>
<div><p>Phase of the filter, only used if <code class="docutils literal"><span class="pre">method='fir'</span></code>.
By default, a symmetric linear-phase FIR filter is constructed.
If <code class="docutils literal"><span class="pre">phase='zero'</span></code> (default), the delay of this filter
is compensated for. If <code class="docutils literal"><span class="pre">phase=='zero-double'</span></code> then this filter
is applied twice, once forward, and once backward.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.13.</span></p>
</div>
</div></blockquote>
<p><strong>fir_window</strong> : str</p>
<blockquote>
<div><p>The window to use in FIR design, can be &#8220;hamming&#8221; (default),
&#8220;hann&#8221;, or &#8220;blackman&#8221;.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.13.</span></p>
</div>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw</strong> : instance of Raw</p>
<blockquote class="last">
<div><p>The raw instance with filtered data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.filter" title="mne.io.Raw.filter"><code class="xref py py-obj docutils literal"><span class="pre">mne.io.Raw.filter</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>For details, see <a class="reference internal" href="mne.filter.notch_filter.html#mne.filter.notch_filter" title="mne.filter.notch_filter"><code class="xref py py-func docutils literal"><span class="pre">mne.filter.notch_filter()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.pick_channels">
<code class="descname">pick_channels</code><span class="sig-paren">(</span><em>ch_names</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.pick_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_names</strong> : list</p>
<blockquote>
<div><p>The list of channels to select.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.io.RawArray.drop_channels" title="mne.io.RawArray.drop_channels"><code class="xref py py-obj docutils literal"><span class="pre">drop_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.pick_types">
<code class="descname">pick_types</code><span class="sig-paren">(</span><em>meg=True</em>, <em>eeg=False</em>, <em>stim=False</em>, <em>eog=False</em>, <em>ecg=False</em>, <em>emg=False</em>, <em>ref_meg='auto'</em>, <em>misc=False</em>, <em>resp=False</em>, <em>chpi=False</em>, <em>exci=False</em>, <em>ias=False</em>, <em>syst=False</em>, <em>seeg=False</em>, <em>dipole=False</em>, <em>gof=False</em>, <em>bio=False</em>, <em>ecog=False</em>, <em>fnirs=False</em>, <em>include=[]</em>, <em>exclude='bads'</em>, <em>selection=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.pick_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels by type and names.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>meg</strong> : bool | str</p>
<blockquote>
<div><p>If True include all MEG channels. If False include None
If string it can be &#8216;mag&#8217;, &#8216;grad&#8217;, &#8216;planar1&#8217; or &#8216;planar2&#8217; to select
only magnetometers, all gradiometers, or a specific type of
gradiometer.</p>
</div></blockquote>
<p><strong>eeg</strong> : bool</p>
<blockquote>
<div><p>If True include EEG channels.</p>
</div></blockquote>
<p><strong>stim</strong> : bool</p>
<blockquote>
<div><p>If True include stimulus channels.</p>
</div></blockquote>
<p><strong>eog</strong> : bool</p>
<blockquote>
<div><p>If True include EOG channels.</p>
</div></blockquote>
<p><strong>ecg</strong> : bool</p>
<blockquote>
<div><p>If True include ECG channels.</p>
</div></blockquote>
<p><strong>emg</strong> : bool</p>
<blockquote>
<div><p>If True include EMG channels.</p>
</div></blockquote>
<p><strong>ref_meg: bool | str</strong></p>
<blockquote>
<div><p>If True include CTF / 4D reference channels. If &#8216;auto&#8217;, the
reference channels are only included if compensations are present.</p>
</div></blockquote>
<p><strong>misc</strong> : bool</p>
<blockquote>
<div><p>If True include miscellaneous analog channels.</p>
</div></blockquote>
<p><strong>resp</strong> : bool</p>
<blockquote>
<div><p>If True include response-trigger channel. For some MEG systems this
is separate from the stim channel.</p>
</div></blockquote>
<p><strong>chpi</strong> : bool</p>
<blockquote>
<div><p>If True include continuous HPI coil channels.</p>
</div></blockquote>
<p><strong>exci</strong> : bool</p>
<blockquote>
<div><p>Flux excitation channel used to be a stimulus channel.</p>
</div></blockquote>
<p><strong>ias</strong> : bool</p>
<blockquote>
<div><p>Internal Active Shielding data (maybe on Triux only).</p>
</div></blockquote>
<p><strong>syst</strong> : bool</p>
<blockquote>
<div><p>System status channel information (on Triux systems only).</p>
</div></blockquote>
<p><strong>seeg</strong> : bool</p>
<blockquote>
<div><p>Stereotactic EEG channels.</p>
</div></blockquote>
<p><strong>dipole</strong> : bool</p>
<blockquote>
<div><p>Dipole time course channels.</p>
</div></blockquote>
<p><strong>gof</strong> : bool</p>
<blockquote>
<div><p>Dipole goodness of fit channels.</p>
</div></blockquote>
<p><strong>bio</strong> : bool</p>
<blockquote>
<div><p>Bio channels.</p>
</div></blockquote>
<p><strong>ecog</strong> : bool</p>
<blockquote>
<div><p>Electrocorticography channels.</p>
</div></blockquote>
<p><strong>fnirs</strong> : bool | str</p>
<blockquote>
<div><p>Functional near-infrared spectroscopy channels. If True include all
fNIRS channels. If False (default) include none. If string it can
be &#8216;hbo&#8217; (to include channels measuring oxyhemoglobin) or &#8216;hbr&#8217; (to
include channels measuring deoxyhemoglobin).</p>
</div></blockquote>
<p><strong>include</strong> : list of string</p>
<blockquote>
<div><p>List of additional channels to include. If empty do not include
any.</p>
</div></blockquote>
<p><strong>exclude</strong> : list of string | str</p>
<blockquote>
<div><p>List of channels to exclude. If &#8216;bads&#8217; (default), exclude channels
in <code class="docutils literal"><span class="pre">info['bads']</span></code>.</p>
</div></blockquote>
<p><strong>selection</strong> : list of string</p>
<blockquote>
<div><p>Restrict sensor channels (MEG, EEG) to this list of channel names.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>events=None</em>, <em>duration=10.0</em>, <em>start=0.0</em>, <em>n_channels=20</em>, <em>bgcolor='w'</em>, <em>color=None</em>, <em>bad_color=(0.8</em>, <em>0.8</em>, <em>0.8)</em>, <em>event_color='cyan'</em>, <em>scalings=None</em>, <em>remove_dc=True</em>, <em>order='type'</em>, <em>show_options=False</em>, <em>title=None</em>, <em>show=True</em>, <em>block=False</em>, <em>highpass=None</em>, <em>lowpass=None</em>, <em>filtorder=4</em>, <em>clipping=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot raw data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>events</strong> : array | None</p>
<blockquote>
<div><p>Events to show with vertical bars.</p>
</div></blockquote>
<p><strong>duration</strong> : float</p>
<blockquote>
<div><p>Time window (sec) to plot. The lesser of this value and the duration
of the raw file will be used.</p>
</div></blockquote>
<p><strong>start</strong> : float</p>
<blockquote>
<div><p>Initial time to show (can be changed dynamically once plotted).</p>
</div></blockquote>
<p><strong>n_channels</strong> : int</p>
<blockquote>
<div><p>Number of channels to plot at once. Defaults to 20. Has no effect if
<code class="docutils literal"><span class="pre">order</span></code> is &#8216;position&#8217; or &#8216;selection&#8217;.</p>
</div></blockquote>
<p><strong>bgcolor</strong> : color object</p>
<blockquote>
<div><p>Color of the background.</p>
</div></blockquote>
<p><strong>color</strong> : dict | color object | None</p>
<blockquote>
<div><p>Color for the data traces. If None, defaults to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">dict</span><span class="p">(</span><span class="n">mag</span><span class="o">=</span><span class="s1">&#39;darkblue&#39;</span><span class="p">,</span> <span class="n">grad</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">eeg</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ecg</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span>
     <span class="n">emg</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ref_meg</span><span class="o">=</span><span class="s1">&#39;steelblue&#39;</span><span class="p">,</span> <span class="n">misc</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
     <span class="n">resp</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">chpi</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>bad_color</strong> : color object</p>
<blockquote>
<div><p>Color to make bad channels.</p>
</div></blockquote>
<p><strong>event_color</strong> : color object | dict</p>
<blockquote>
<div><p>Color to use for events. Can also be a dict with
<code class="docutils literal"><span class="pre">{event_number:</span> <span class="pre">color}</span></code> pairings. Use <code class="docutils literal"><span class="pre">event_number==-1</span></code> for
any event numbers in the events list that are not in the dictionary.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>Scaling factors for the traces. If any fields in scalings are &#8216;auto&#8217;,
the scaling factor is set to match the 99.5th percentile of a subset of
the corresponding data. If scalings == &#8216;auto&#8217;, all scalings fields are
set to &#8216;auto&#8217;. If any fields are &#8216;auto&#8217; and data is not preloaded, a
subset of times up to 100mb will be loaded. If None, defaults to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">dict</span><span class="p">(</span><span class="n">mag</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="n">grad</span><span class="o">=</span><span class="mi">4</span><span class="n">e</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="n">eeg</span><span class="o">=</span><span class="mi">20</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="mi">150</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="n">ecg</span><span class="o">=</span><span class="mi">5</span><span class="n">e</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span>
     <span class="n">emg</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">ref_meg</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="n">misc</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
     <span class="n">resp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">chpi</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>remove_dc</strong> : bool</p>
<blockquote>
<div><p>If True remove DC component when plotting data.</p>
</div></blockquote>
<p><strong>order</strong> : str | array of int</p>
<blockquote>
<div><p>Order in which to plot data. &#8216;type&#8217; groups by channel type, &#8216;original&#8217;
plots in the order of ch_names, &#8216;selection&#8217; uses Elekta&#8217;s channel
groupings (only works for Neuromag data), &#8216;position&#8217; groups the
channels by the positions of the sensors. &#8216;selection&#8217; and &#8216;position&#8217;
modes allow custom selections by using lasso selector on the topomap.
Pressing <code class="docutils literal"><span class="pre">ctrl</span></code> key while selecting allows appending to the current
selection. If array, only the channels in the array are plotted in the
given order. Defaults to &#8216;type&#8217;.</p>
</div></blockquote>
<p><strong>show_options</strong> : bool</p>
<blockquote>
<div><p>If True, a dialog for options related to projection is shown.</p>
</div></blockquote>
<p><strong>title</strong> : str | None</p>
<blockquote>
<div><p>The title of the window. If None, and either the filename of the
raw object or &#8216;&lt;unknown&gt;&#8217; will be displayed as title.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True.</p>
</div></blockquote>
<p><strong>block</strong> : bool</p>
<blockquote>
<div><p>Whether to halt program execution until the figure is closed.
Useful for setting bad channels on the fly by clicking on a line.
May not work on all systems / platforms.</p>
</div></blockquote>
<p><strong>highpass</strong> : float | None</p>
<blockquote>
<div><p>Highpass to apply when displaying data.</p>
</div></blockquote>
<p><strong>lowpass</strong> : float | None</p>
<blockquote>
<div><p>Lowpass to apply when displaying data.</p>
</div></blockquote>
<p><strong>filtorder</strong> : int</p>
<blockquote>
<div><p>Filtering order. Note that for efficiency and simplicity,
filtering during plotting uses forward-backward IIR filtering,
so the effective filter order will be twice <code class="docutils literal"><span class="pre">filtorder</span></code>.
Filtering the lines for display may also produce some edge
artifacts (at the left and right edges) of the signals
during display. Filtering requires scipy &gt;= 0.10.</p>
</div></blockquote>
<p><strong>clipping</strong> : str | None</p>
<blockquote>
<div><p>If None, channels are allowed to exceed their designated bounds in
the plot. If &#8220;clamp&#8221;, then values are clamped to the appropriate
range for display, creating step-like artifacts. If &#8220;transparent&#8221;,
then excessive values are not shown, creating gaps in the traces.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Instance of matplotlib.figure.Figure</p>
<blockquote class="last">
<div><p>Raw traces.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The arrow keys (up/down/left/right) can typically be used to navigate
between channels and time ranges, but this depends on the backend
matplotlib is configured to use (e.g., mpl.use(&#8216;TkAgg&#8217;) should work). The
scaling can be adjusted with - and + (or =) keys. The viewport dimensions
can be adjusted with page up/page down and home/end keys. Full screen mode
can be to toggled with f11 key. To mark or un-mark a channel as bad, click
on the rather flat segments of a channel&#8217;s time series. The changes will be
reflected immediately in the raw object&#8217;s <code class="docutils literal"><span class="pre">raw.info['bads']</span></code> entry.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.plot_projs_topomap">
<code class="descname">plot_projs_topomap</code><span class="sig-paren">(</span><em>ch_type=None</em>, <em>layout=None</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.plot_projs_topomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot SSP vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_type</strong> : &#8216;mag&#8217; | &#8216;grad&#8217; | &#8216;planar1&#8217; | &#8216;planar2&#8217; | &#8216;eeg&#8217; | None | List</p>
<blockquote>
<div><p>The channel type to plot. For &#8216;grad&#8217;, the gradiometers are collec-
ted in pairs and the RMS for each pair is plotted. If None
(default), it will return all channel types present. If a list of
ch_types is provided, it will return multiple figures.</p>
</div></blockquote>
<p><strong>layout</strong> : None | Layout | List of Layouts</p>
<blockquote>
<div><p>Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct
layout file is inferred from the data; if no appropriate layout
file was found, the layout is automatically generated from the
sensor locations. Or a list of Layout if projections
are from different sensor types.</p>
</div></blockquote>
<p><strong>axes</strong> : instance of Axes | list | None</p>
<blockquote>
<div><p>The axes to plot to. If list, the list must be a list of Axes of
the same length as the number of projectors. If instance of Axes,
there must be only one projector. Defaults to None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure distributing one image per channel across sensor topography.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.plot_psd">
<code class="descname">plot_psd</code><span class="sig-paren">(</span><em>tmin=0.0</em>, <em>tmax=60.0</em>, <em>fmin=0</em>, <em>fmax=inf</em>, <em>proj=False</em>, <em>n_fft=2048</em>, <em>picks=None</em>, <em>ax=None</em>, <em>color='black'</em>, <em>area_mode='std'</em>, <em>area_alpha=0.33</em>, <em>n_overlap=0</em>, <em>dB=True</em>, <em>show=True</em>, <em>n_jobs=1</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.plot_psd" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the power spectral density across channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tmin</strong> : float</p>
<blockquote>
<div><p>Start time for calculations.</p>
</div></blockquote>
<p><strong>tmax</strong> : float</p>
<blockquote>
<div><p>End time for calculations.</p>
</div></blockquote>
<p><strong>fmin</strong> : float</p>
<blockquote>
<div><p>Start frequency to consider.</p>
</div></blockquote>
<p><strong>fmax</strong> : float</p>
<blockquote>
<div><p>End frequency to consider.</p>
</div></blockquote>
<p><strong>proj</strong> : bool</p>
<blockquote>
<div><p>Apply projection.</p>
</div></blockquote>
<p><strong>n_fft</strong> : int</p>
<blockquote>
<div><p>Number of points to use in Welch FFT calculations.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>List of channels to use. Cannot be None if <cite>ax</cite> is supplied. If both
<cite>picks</cite> and <cite>ax</cite> are None, separate subplots will be created for
each standard channel type (<cite>mag</cite>, <cite>grad</cite>, and <cite>eeg</cite>).</p>
</div></blockquote>
<p><strong>ax</strong> : instance of matplotlib Axes | None</p>
<blockquote>
<div><p>Axes to plot into. If None, axes will be created.</p>
</div></blockquote>
<p><strong>color</strong> : str | tuple</p>
<blockquote>
<div><p>A matplotlib-compatible color to use.</p>
</div></blockquote>
<p><strong>area_mode</strong> : str | None</p>
<blockquote>
<div><p>Mode for plotting area. If &#8216;std&#8217;, the mean +/- 1 STD (across channels)
will be plotted. If &#8216;range&#8217;, the min and max (across channels) will be
plotted. Bad channels will be excluded from these calculations.
If None, no area will be plotted.</p>
</div></blockquote>
<p><strong>area_alpha</strong> : float</p>
<blockquote>
<div><p>Alpha for the area.</p>
</div></blockquote>
<p><strong>n_overlap</strong> : int</p>
<blockquote>
<div><p>The number of points of overlap between blocks. The default value
is 0 (no overlap).</p>
</div></blockquote>
<p><strong>dB</strong> : bool</p>
<blockquote>
<div><p>If True, transform data to decibels.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int</p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure with frequency spectra of the data channels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.plot_psd_topo">
<code class="descname">plot_psd_topo</code><span class="sig-paren">(</span><em>tmin=0.0</em>, <em>tmax=None</em>, <em>fmin=0</em>, <em>fmax=100</em>, <em>proj=False</em>, <em>n_fft=2048</em>, <em>n_overlap=0</em>, <em>layout=None</em>, <em>color='w'</em>, <em>fig_facecolor='k'</em>, <em>axis_facecolor='k'</em>, <em>dB=True</em>, <em>show=True</em>, <em>block=False</em>, <em>n_jobs=1</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.plot_psd_topo" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot channel-wise frequency spectra as topography.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tmin</strong> : float</p>
<blockquote>
<div><p>Start time for calculations. Defaults to zero.</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote>
<div><p>End time for calculations. If None (default), the end of data is used.</p>
</div></blockquote>
<p><strong>fmin</strong> : float</p>
<blockquote>
<div><p>Start frequency to consider. Defaults to zero.</p>
</div></blockquote>
<p><strong>fmax</strong> : float</p>
<blockquote>
<div><p>End frequency to consider. Defaults to 100.</p>
</div></blockquote>
<p><strong>proj</strong> : bool</p>
<blockquote>
<div><p>Apply projection. Defaults to False.</p>
</div></blockquote>
<p><strong>n_fft</strong> : int</p>
<blockquote>
<div><p>Number of points to use in Welch FFT calculations. Defaults to 2048.</p>
</div></blockquote>
<p><strong>n_overlap</strong> : int</p>
<blockquote>
<div><p>The number of points of overlap between blocks. Defaults to 0
(no overlap).</p>
</div></blockquote>
<p><strong>layout</strong> : instance of Layout | None</p>
<blockquote>
<div><p>Layout instance specifying sensor positions (does not need to be
specified for Neuromag data). If None (default), the correct layout is
inferred from the data.</p>
</div></blockquote>
<p><strong>color</strong> : str | tuple</p>
<blockquote>
<div><p>A matplotlib-compatible color to use for the curves. Defaults to white.</p>
</div></blockquote>
<p><strong>fig_facecolor</strong> : str | tuple</p>
<blockquote>
<div><p>A matplotlib-compatible color to use for the figure background.
Defaults to black.</p>
</div></blockquote>
<p><strong>axis_facecolor</strong> : str | tuple</p>
<blockquote>
<div><p>A matplotlib-compatible color to use for the axis background.
Defaults to black.</p>
</div></blockquote>
<p><strong>dB</strong> : bool</p>
<blockquote>
<div><p>If True, transform data to decibels. Defaults to True.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True. Defaults to True.</p>
</div></blockquote>
<p><strong>block</strong> : bool</p>
<blockquote>
<div><p>Whether to halt program execution until the figure is closed.
May not work on all systems / platforms. Defaults to False.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int</p>
<blockquote>
<div><p>Number of jobs to run in parallel. Defaults to 1.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure distributing one image per channel across sensor topography.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.plot_sensors">
<code class="descname">plot_sensors</code><span class="sig-paren">(</span><em>kind='topomap'</em>, <em>ch_type=None</em>, <em>title=None</em>, <em>show_names=False</em>, <em>ch_groups=None</em>, <em>axes=None</em>, <em>block=False</em>, <em>show=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.plot_sensors" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot sensor positions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kind</strong> : str</p>
<blockquote>
<div><p>Whether to plot the sensors as 3d, topomap or as an interactive
sensor selection dialog. Available options &#8216;topomap&#8217;, &#8216;3d&#8217;,
&#8216;select&#8217;. If &#8216;select&#8217;, a set of channels can be selected
interactively by using lasso selector or clicking while holding
control key. The selected channels are returned along with the
figure instance. Defaults to &#8216;topomap&#8217;.</p>
</div></blockquote>
<p><strong>ch_type</strong> : None | str</p>
<blockquote>
<div><p>The channel type to plot. Available options &#8216;mag&#8217;, &#8216;grad&#8217;, &#8216;eeg&#8217;,
&#8216;seeg&#8217;, &#8216;ecog&#8217;, &#8216;all&#8217;. If <code class="docutils literal"><span class="pre">'all'</span></code>, all the available mag, grad,
eeg, seeg and ecog channels are plotted. If None (default), then
channels are chosen in the order given above.</p>
</div></blockquote>
<p><strong>title</strong> : str | None</p>
<blockquote>
<div><p>Title for the figure. If None (default), equals to <code class="docutils literal"><span class="pre">'Sensor</span>
<span class="pre">positions</span> <span class="pre">(%s)'</span> <span class="pre">%</span> <span class="pre">ch_type</span></code>.</p>
</div></blockquote>
<p><strong>show_names</strong> : bool</p>
<blockquote>
<div><p>Whether to display all channel names. Defaults to False.</p>
</div></blockquote>
<p><strong>ch_groups</strong> : &#8216;position&#8217; | array of shape (ch_groups, picks) | None</p>
<blockquote>
<div><p>Channel groups for coloring the sensors. If None (default), default
coloring scheme is used. If &#8216;position&#8217;, the sensors are divided
into 8 regions. See <code class="docutils literal"><span class="pre">order</span></code> kwarg of <a class="reference internal" href="mne.viz.plot_raw.html#mne.viz.plot_raw" title="mne.viz.plot_raw"><code class="xref py py-func docutils literal"><span class="pre">mne.viz.plot_raw()</span></code></a>. If
array, the channels are divided by picks given in the array.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</div></blockquote>
<p><strong>axes</strong> : instance of Axes | instance of Axes3D | None</p>
<blockquote>
<div><p>Axes to draw the sensors to. If <code class="docutils literal"><span class="pre">kind='3d'</span></code>, axes must be an
instance of Axes3D. If None (default), a new axes will be created.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</div></blockquote>
<p><strong>block</strong> : bool</p>
<blockquote>
<div><p>Whether to halt program execution until the figure is closed.
Defaults to False.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True. Defaults to True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote>
<div><p>Figure containing the sensor topography.</p>
</div></blockquote>
<p><strong>selection</strong> : list</p>
<blockquote class="last">
<div><p>A list of selected channels. Only returned if <code class="docutils literal"><span class="pre">kind=='select'</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.viz.plot_layout.html#mne.viz.plot_layout" title="mne.viz.plot_layout"><code class="xref py py-obj docutils literal"><span class="pre">mne.viz.plot_layout</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This function plots the sensor locations from the info structure using
matplotlib. For drawing the sensors using mayavi see
<a class="reference internal" href="mne.viz.plot_trans.html#mne.viz.plot_trans" title="mne.viz.plot_trans"><code class="xref py py-func docutils literal"><span class="pre">mne.viz.plot_trans()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.0.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mne.io.RawArray.proj">
<code class="descname">proj</code><a class="headerlink" href="#mne.io.RawArray.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether or not projections are active.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.rename_channels">
<code class="descname">rename_channels</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.rename_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mapping</strong> : dict | callable</p>
<blockquote class="last">
<div><p>a dictionary mapping the old channel to a new channel name
e.g. {&#8216;EEG061&#8217; : &#8216;EEG161&#8217;}. Can also be a callable function
that takes and returns a string (new in version 0.10.0).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.resample">
<code class="descname">resample</code><span class="sig-paren">(</span><em>sfreq</em>, <em>npad='auto'</em>, <em>window='boxcar'</em>, <em>stim_picks=None</em>, <em>n_jobs=1</em>, <em>events=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample all channels.</p>
<p>The Raw object has to have the data loaded e.g. with <code class="docutils literal"><span class="pre">preload=True</span></code>
or <code class="docutils literal"><span class="pre">self.load_data()</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>The intended purpose of this function is primarily to
speed up computations (e.g., projection calculation) when
precise timing of events is not required, as downsampling
raw data effectively jitters trigger timings. It is
generally recommended not to epoch downsampled data,
but instead epoch and then downsample, as epoching
downsampled data jitters triggers.
For more, see
<a class="reference external" href="https://gist.github.com/Eric89GXL/01642cb3789992fbca59">this illustrative gist</a>.</p>
<p class="last">If resampling the continuous data is desired, it is
recommended to construct events using the original data.
The event onsets can be jointly resampled with the raw
data using the &#8216;events&#8217; parameter.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sfreq</strong> : float</p>
<blockquote>
<div><p>New sample rate to use.</p>
</div></blockquote>
<p><strong>npad</strong> : int | str</p>
<blockquote>
<div><p>Amount to pad the start and end of the data.
Can also be &#8220;auto&#8221; to use a padding that will result in
a power-of-two size (can be much faster).</p>
</div></blockquote>
<p><strong>window</strong> : string or tuple</p>
<blockquote>
<div><p>Frequency-domain window to use in resampling.
See <a class="reference external" href="http://scipy.github.io/devdocs/generated/scipy.signal.resample.html#scipy.signal.resample" title="(in SciPy v0.19.0.dev0+996ff11)"><code class="xref py py-func docutils literal"><span class="pre">scipy.signal.resample()</span></code></a>.</p>
</div></blockquote>
<p><strong>stim_picks</strong> : array of int | None</p>
<blockquote>
<div><p>Stim channels. These channels are simply subsampled or
supersampled (without applying any filtering). This reduces
resampling artifacts in stim channels, but may lead to missing
triggers. If None, stim channels are automatically chosen using
<a class="reference internal" href="mne.pick_types.html#mne.pick_types" title="mne.pick_types"><code class="xref py py-func docutils literal"><span class="pre">mne.pick_types()</span></code></a>.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int | str</p>
<blockquote>
<div><p>Number of jobs to run in parallel. Can be &#8216;cuda&#8217; if scikits.cuda
is installed properly and CUDA is initialized.</p>
</div></blockquote>
<p><strong>events</strong> : 2D array, shape (n_events, 3) | None</p>
<blockquote>
<div><p>An optional event matrix. When specified, the onsets of the events
are resampled jointly with the data.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw</strong> : instance of Raw</p>
<blockquote class="last">
<div><p>The resampled version of the raw object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.filter" title="mne.io.Raw.filter"><code class="xref py py-obj docutils literal"><span class="pre">mne.io.Raw.filter</span></code></a>, <a class="reference internal" href="mne.Epochs.html#mne.Epochs.resample" title="mne.Epochs.resample"><code class="xref py py-obj docutils literal"><span class="pre">mne.Epochs.resample</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>For some data, it may be more accurate to use <code class="docutils literal"><span class="pre">npad=0</span></code> to reduce
artifacts. This is dataset dependent &#8211; check your data!</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>fname</em>, <em>picks=None</em>, <em>tmin=0</em>, <em>tmax=None</em>, <em>buffer_size_sec=None</em>, <em>drop_small_buffer=False</em>, <em>proj=False</em>, <em>fmt='single'</em>, <em>overwrite=False</em>, <em>split_size='2GB'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save raw data to file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fname</strong> : string</p>
<blockquote>
<div><p>File name of the new dataset. This has to be a new filename
unless data have been preloaded. Filenames should end with
raw.fif, raw.fif.gz, raw_sss.fif, raw_sss.fif.gz, raw_tsss.fif
or raw_tsss.fif.gz.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>Indices of channels to include. If None all channels are kept.</p>
</div></blockquote>
<p><strong>tmin</strong> : float | None</p>
<blockquote>
<div><p>Time in seconds of first sample to save. If None first sample
is used.</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote>
<div><p>Time in seconds of last sample to save. If None last sample
is used.</p>
</div></blockquote>
<p><strong>buffer_size_sec</strong> : float | None</p>
<blockquote>
<div><p>Size of data chunks in seconds. If None (default), the buffer
size of the original file is used.</p>
</div></blockquote>
<p><strong>drop_small_buffer</strong> : bool</p>
<blockquote>
<div><p>Drop or not the last buffer. It is required by maxfilter (SSS)
that only accepts raw files with buffers of the same size.</p>
</div></blockquote>
<p><strong>proj</strong> : bool</p>
<blockquote>
<div><p>If True the data is saved with the projections applied (active).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <code class="docutils literal"><span class="pre">apply_proj()</span></code> was used to apply the projections,
the projectons will be active even if <code class="docutils literal"><span class="pre">proj</span></code> is False.</p>
</div>
</div></blockquote>
<p><strong>fmt</strong> : str</p>
<blockquote>
<div><p>Format to use to save raw data. Valid options are &#8216;double&#8217;,
&#8216;single&#8217;, &#8216;int&#8217;, and &#8216;short&#8217; for 64- or 32-bit float, or 32- or
16-bit integers, respectively. It is <strong>strongly</strong> recommended to
use &#8216;single&#8217;, as this is backward-compatible, and is standard for
maintaining precision. Note that using &#8216;short&#8217; or &#8216;int&#8217; may result
in loss of precision, complex data cannot be saved as &#8216;short&#8217;,
and neither complex data types nor real data stored as &#8216;double&#8217;
can be loaded with the MNE command-line tools. See raw.orig_format
to determine the format the original data were stored in.</p>
</div></blockquote>
<p><strong>overwrite</strong> : bool</p>
<blockquote>
<div><p>If True, the destination file (if it exists) will be overwritten.
If False (default), an error will be raised if the file exists.</p>
</div></blockquote>
<p><strong>split_size</strong> : string | int</p>
<blockquote>
<div><p>Large raw files are automatically split into multiple pieces. This
parameter specifies the maximum size of each piece. If the
parameter is an integer, it specifies the size in Bytes. It is
also possible to pass a human-readable string, e.g., 100MB.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Due to FIFF file limitations, the maximum split
size is 2GB.</p>
</div>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If Raw is a concatenation of several raw files, <strong>be warned</strong> that
only the measurement information from the first raw file is stored.
This likely means that certain operations with external tools may not
work properly on a saved concatenated file (e.g., probably some
or all forms of SSS). It is recommended not to concatenate and
then save raw files for this reason.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.set_channel_types">
<code class="descname">set_channel_types</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.set_channel_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the sensor type of channels.</p>
<dl class="docutils">
<dt>Note: The following sensor types are accepted:</dt>
<dd>ecg, eeg, emg, eog, exci, ias, misc, resp, seeg, stim, syst, ecog,
hbo, hbr</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mapping</strong> : dict</p>
<blockquote class="last">
<div><p>a dictionary mapping a channel to a sensor type (str)
{&#8216;EEG061&#8217;: &#8216;eog&#8217;}.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.set_eeg_reference">
<code class="descname">set_eeg_reference</code><span class="sig-paren">(</span><em>ref_channels=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.set_eeg_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Rereference EEG channels to new reference channel(s).</p>
<p>If multiple reference channels are specified, they will be averaged. If
no reference channels are specified, an average reference will be
applied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_channels</strong> : list of str | None</p>
<blockquote>
<div><p>The names of the channels to use to construct the reference. If
None (default), an average reference will be added as an SSP
projector but not immediately applied to the data. If an empty list
is specified, the data is assumed to already have a proper
reference and MNE will not attempt any re-referencing of the data.
Defaults to an average reference (None).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw | Epochs | Evoked</p>
<blockquote class="last">
<div><p>Data with EEG channels re-referenced. For <code class="docutils literal"><span class="pre">ref_channels=None</span></code>,
an average projector will be added instead of directly subtarcting
data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.set_bipolar_reference.html#mne.set_bipolar_reference" title="mne.set_bipolar_reference"><code class="xref py py-obj docutils literal"><span class="pre">mne.set_bipolar_reference</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li>If a reference is requested that is not the average reference, this
function removes any pre-existing average reference projections.</li>
<li>During source localization, the EEG signal should have an average
reference.</li>
<li>In order to apply a reference other than an average reference, the
data must be preloaded.</li>
</ol>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.set_montage">
<code class="descname">set_montage</code><span class="sig-paren">(</span><em>montage</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.set_montage" title="Permalink to this definition">¶</a></dt>
<dd><p>Set EEG sensor configuration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>montage</strong> : instance of Montage or DigMontage</p>
<blockquote>
<div><p>The montage to use.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Operates in place.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.time_as_index">
<code class="descname">time_as_index</code><span class="sig-paren">(</span><em>times</em>, <em>use_rounding=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.time_as_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert time to indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : list-like | float | int</p>
<blockquote>
<div><p>List of numbers or a number representing points in time.</p>
</div></blockquote>
<p><strong>use_rounding</strong> : boolean</p>
<blockquote>
<div><p>If True, use rounding (instead of truncation) when converting
times to indices. This can help avoid non-unique indices.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>index</strong> : ndarray</p>
<blockquote class="last">
<div><p>Indices corresponding to the times supplied.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mne.io.RawArray.times">
<code class="descname">times</code><a class="headerlink" href="#mne.io.RawArray.times" title="Permalink to this definition">¶</a></dt>
<dd><p>Time points.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.to_data_frame">
<code class="descname">to_data_frame</code><span class="sig-paren">(</span><em>picks=None</em>, <em>index=None</em>, <em>scale_time=1000.0</em>, <em>scalings=None</em>, <em>copy=True</em>, <em>start=None</em>, <em>stop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.io.RawArray.to_data_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Export data in tabular structure as a pandas DataFrame.</p>
<p>Columns and indices will depend on the object being converted.
Generally this will include as much relevant information as
possible for the data type being converted. This makes it easy
to convert data for use in packages that utilize dataframes,
such as statsmodels or seaborn.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>If None only MEG and EEG channels are kept
otherwise the channels indices in picks are kept.</p>
</div></blockquote>
<p><strong>index</strong> : tuple of str | None</p>
<blockquote>
<div><p>Column to be used as index for the data. Valid string options
are &#8216;epoch&#8217;, &#8216;time&#8217; and &#8216;condition&#8217;. If None, all three info
columns will be included in the table as categorial data.</p>
</div></blockquote>
<p><strong>scale_time</strong> : float</p>
<blockquote>
<div><p>Scaling to be applied to time units.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>Scaling to be applied to the channels picked. If None, defaults to
<code class="docutils literal"><span class="pre">scalings=dict(eeg=1e6,</span> <span class="pre">grad=1e13,</span> <span class="pre">mag=1e15,</span> <span class="pre">misc=1.0)</span></code>.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>If true, data will be copied. Else data may be modified in place.</p>
</div></blockquote>
<p><strong>start</strong> : int | None</p>
<blockquote>
<div><p>If it is a Raw object, this defines a starting index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</div></blockquote>
<p><strong>stop</strong> : int | None</p>
<blockquote>
<div><p>If it is a Raw object, this defines a stop index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>df</strong> : instance of pandas.core.DataFrame</p>
<blockquote class="last">
<div><p>A dataframe suitable for usage with other
statistical/plotting/analysis packages. Column/Index values will
depend on the object type being converted, but should be
human-readable.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2012-2016, MNE Developers. Last updated on 2016-10-24.<br/>
    </p>
  </div>
</footer>
  </body>
</html>