<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>mne.SourceEstimate &#8212; MNE 0.18.dev0 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" href="../_static/reset-syntax.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />

    <script type="text/javascript" src="../_static/copybutton.js"></script>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>


    <link rel="stylesheet" href="../_static/style.css " type="text/css" />
    <link rel="stylesheet" href="../_static/font-awesome.css" type="text/css" />
    <link rel="stylesheet" href="../_static/flag-icon.css" type="text/css" />



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>


  </head><body>

<div class="row devbar alert alert-danger">
This documentation is for <strong>development version 0.18.dev0</strong>.
</div>





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/mne_logo_small.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.18.dev0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../getting_started.html">Install</a></li>
                <li><a href="../documentation.html">Documentation</a></li>
                <li><a href="../python_reference.html">API</a></li>
                <li><a href="../glossary.html">Glossary</a></li>
                <li><a href="../auto_examples/index.html">Examples</a></li>
                <li><a href="../contributing.html">Contribute</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
<div class="navbar-form navbar-right navbar-btn dropdown btn-group-sm" style="margin-left: 20px; margin-top: 5px; margin-bottom: 5px">
  <button type="button" class="btn btn-danger navbar-btn dropdown-toggle" id="dropdownMenu1" data-toggle="dropdown">
    v0.18.dev0
    <span class="caret"></span>
  </button>
  <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
    <li><a href="https://mne-tools.github.io/dev/index.html">Development</a></li>
    <li><a href="https://mne-tools.github.io/stable/index.html">v0.17 (stable)</a></li>
    <li><a href="https://mne-tools.github.io/0.16/index.html">v0.16</a></li>
    <li><a href="https://mne-tools.github.io/0.15/index.html">v0.15</a></li>
    <li><a href="https://mne-tools.github.io/0.14/index.html">v0.14</a></li>
    <li><a href="https://mne-tools.github.io/0.13/index.html">v0.13</a></li>
    <li><a href="https://mne-tools.github.io/0.12/index.html">v0.12</a></li>
    <li><a href="https://mne-tools.github.io/0.11/index.html">v0.11</a></li>
  </ul>
</div>


            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          

        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/mne_logo_small.png" alt="Logo"/>
            </a></p><ul>
<li><a class="reference internal" href="#">mne.SourceEstimate</a></li>
</ul>

<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="mne-sourceestimate">
<h1>mne.SourceEstimate<a class="headerlink" href="#mne-sourceestimate" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="mne.SourceEstimate">
<em class="property">class </em><code class="descclassname">mne.</code><code class="descname">SourceEstimate</code><span class="sig-paren">(</span><em>data</em>, <em>vertices=None</em>, <em>tmin=None</em>, <em>tstep=None</em>, <em>subject=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L1345-L1637"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for surface source estimates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array of shape (n_dipoles, n_times) | tuple, shape (2,)</span></dt><dd><p>The data in source space. The data can either be a single array or
a tuple with two arrays: “kernel” shape (n_vertices, n_sensors) and
“sens_data” shape (n_sensors, n_times). In this case, the source
space data corresponds to “numpy.dot(kernel, sens_data)”.</p>
</dd>
<dt><strong>vertices</strong><span class="classifier">list of shape (2,)</span></dt><dd><p>Vertex numbers corresponding to the data.</p>
</dd>
<dt><strong>tmin</strong><span class="classifier">scalar</span></dt><dd><p>Time point of the first sample in data.</p>
</dd>
<dt><strong>tstep</strong><span class="classifier">scalar</span></dt><dd><p>Time step between successive samples in data.</p>
</dd>
<dt><strong>subject</strong><span class="classifier">str | None</span></dt><dd><p>The subject name. While not necessary, it is safer to set the
subject parameter to avoid analysis errors.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, str, int, or None</span></dt><dd><p>If not None, override default verbose level (see <a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a>
and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a> for more).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="mne.VectorSourceEstimate.html#mne.VectorSourceEstimate" title="mne.VectorSourceEstimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VectorSourceEstimate</span></code></a></dt><dd><p>A container for vector source estimates.</p>
</dd>
<dt><a class="reference internal" href="mne.VolSourceEstimate.html#mne.VolSourceEstimate" title="mne.VolSourceEstimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VolSourceEstimate</span></code></a></dt><dd><p>A container for volume source estimates.</p>
</dd>
<dt><a class="reference internal" href="mne.MixedSourceEstimate.html#mne.MixedSourceEstimate" title="mne.MixedSourceEstimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MixedSourceEstimate</span></code></a></dt><dd><p>A container for mixed surface + volume source estimates.</p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>subject</strong><span class="classifier">str | None</span></dt><dd><p>The subject name.</p>
</dd>
<dt><a class="reference internal" href="#mne.SourceEstimate.times" title="mne.SourceEstimate.times"><code class="xref py py-obj docutils literal notranslate"><span class="pre">times</span></code></a><span class="classifier">array of shape (n_times,)</span></dt><dd><p>A timestamp for each sample.</p>
</dd>
<dt><strong>vertices</strong><span class="classifier">list of shape (2,)</span></dt><dd><p>The indices of the dipoles in the left and right source space.</p>
</dd>
<dt><a class="reference internal" href="#mne.SourceEstimate.data" title="mne.SourceEstimate.data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></a><span class="classifier">array of shape (n_dipoles, n_times)</span></dt><dd><p>Numpy array of source estimate data.</p>
</dd>
<dt><a class="reference internal" href="#mne.SourceEstimate.shape" title="mne.SourceEstimate.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a><span class="classifier">tuple</span></dt><dd><p>Shape of the data.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mne.SourceEstimate.__add__" title="mne.SourceEstimate.__add__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__add__</span></code></a>(a)</p></td>
<td><p>Add source estimates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mne.SourceEstimate.__div__" title="mne.SourceEstimate.__div__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__div__</span></code></a>(a)</p></td>
<td><p>Divide source estimates.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mne.SourceEstimate.__hash__" title="mne.SourceEstimate.__hash__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__hash__</span></code></a>($self, /)</p></td>
<td><p>Return hash(self).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mne.SourceEstimate.__mul__" title="mne.SourceEstimate.__mul__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__mul__</span></code></a>(a)</p></td>
<td><p>Multiply source estimates.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mne.SourceEstimate.__neg__" title="mne.SourceEstimate.__neg__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__neg__</span></code></a>()</p></td>
<td><p>Negate the source estimate.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mne.SourceEstimate.__sub__" title="mne.SourceEstimate.__sub__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__sub__</span></code></a>(a)</p></td>
<td><p>Subtract source estimates.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mne.SourceEstimate.bin" title="mne.SourceEstimate.bin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bin</span></code></a>(width[, tstart, tstop, func])</p></td>
<td><p>Return a source estimate object with data summarized over time bins.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mne.SourceEstimate.center_of_mass" title="mne.SourceEstimate.center_of_mass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">center_of_mass</span></code></a>([subject, hemi, …])</p></td>
<td><p>Compute the center of mass of activity.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mne.SourceEstimate.copy" title="mne.SourceEstimate.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</p></td>
<td><p>Return copy of source estimate instance.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mne.SourceEstimate.crop" title="mne.SourceEstimate.crop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crop</span></code></a>([tmin, tmax])</p></td>
<td><p>Restrict SourceEstimate to a time interval.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mne.SourceEstimate.expand" title="mne.SourceEstimate.expand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand</span></code></a>(vertices)</p></td>
<td><p>Expand SourceEstimate to include more vertices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mne.SourceEstimate.extract_label_time_course" title="mne.SourceEstimate.extract_label_time_course"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_label_time_course</span></code></a>(labels, src[, …])</p></td>
<td><p>Extract label time courses for lists of labels.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mne.SourceEstimate.get_peak" title="mne.SourceEstimate.get_peak"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_peak</span></code></a>([hemi, tmin, tmax, mode, …])</p></td>
<td><p>Get location and latency of peak amplitude.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mne.SourceEstimate.in_label" title="mne.SourceEstimate.in_label"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_label</span></code></a>(label)</p></td>
<td><p>Get a source estimate object restricted to a label.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mne.SourceEstimate.mean" title="mne.SourceEstimate.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>()</p></td>
<td><p>Make a summary stc file with mean over time points.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mne.SourceEstimate.plot" title="mne.SourceEstimate.plot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code></a>([subject, surface, hemi, colormap, …])</p></td>
<td><p>Plot SourceEstimate with PySurfer.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mne.SourceEstimate.resample" title="mne.SourceEstimate.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a>(sfreq[, npad, window, n_jobs, verbose])</p></td>
<td><p>Resample data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mne.SourceEstimate.save" title="mne.SourceEstimate.save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code></a>(fname[, ftype, verbose])</p></td>
<td><p>Save the source estimates to a file.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mne.SourceEstimate.sqrt" title="mne.SourceEstimate.sqrt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sqrt</span></code></a>()</p></td>
<td><p>Take the square root.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mne.SourceEstimate.sum" title="mne.SourceEstimate.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code></a>()</p></td>
<td><p>Make a summary stc file with sum over time points.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mne.SourceEstimate.time_as_index" title="mne.SourceEstimate.time_as_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">time_as_index</span></code></a>(times[, use_rounding])</p></td>
<td><p>Convert time to indices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mne.SourceEstimate.to_data_frame" title="mne.SourceEstimate.to_data_frame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_data_frame</span></code></a>([picks, index, scaling_time, …])</p></td>
<td><p>Export data in tabular structure as a pandas DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mne.SourceEstimate.to_original_src" title="mne.SourceEstimate.to_original_src"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_original_src</span></code></a>(src_orig[, subject_orig, …])</p></td>
<td><p>Get a source estimate from morphed source to the original subject.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mne.SourceEstimate.transform" title="mne.SourceEstimate.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(func[, idx, tmin, tmax, copy])</p></td>
<td><p>Apply linear transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mne.SourceEstimate.transform_data" title="mne.SourceEstimate.transform_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform_data</span></code></a>(func[, idx, tmin_idx, tmax_idx])</p></td>
<td><p>Get data after a linear (time) transform has been applied.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mne.SourceEstimate.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L727-L731"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>Add source estimates.</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.__div__">
<code class="descname">__div__</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L789-L793"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.__div__" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide source estimates.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.SourceEstimate.__hash__">
<code class="descname">__hash__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.SourceEstimate.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.__mul__">
<code class="descname">__mul__</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L807-L811"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply source estimates.</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.__neg__">
<code class="descname">__neg__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L844-L849"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate the source estimate.</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.__sub__">
<code class="descname">__sub__</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L771-L775"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract source estimates.</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.bin">
<code class="descname">bin</code><span class="sig-paren">(</span><em>width</em>, <em>tstart=None</em>, <em>tstop=None</em>, <em>func=&lt;function mean&gt;</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L882-L926"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a source estimate object with data summarized over time bins.</p>
<p>Time bins of <code class="docutils literal notranslate"><span class="pre">width</span></code> seconds. This method is intended for
visualization only. No filter is applied to the data before binning,
making the method inappropriate as a tool for downsampling data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">scalar</span></dt><dd><p>Width of the individual bins in seconds.</p>
</dd>
<dt><strong>tstart</strong><span class="classifier">scalar | None</span></dt><dd><p>Time point where the first bin starts. The default is the first
time point of the stc.</p>
</dd>
<dt><strong>tstop</strong><span class="classifier">scalar | None</span></dt><dd><p>Last possible time point contained in a bin (if the last bin would
be shorter than width it is dropped). The default is the last time
point of the stc.</p>
</dd>
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><p>Function that is applied to summarize the data. Needs to accept a
numpy.array as first input and an <code class="docutils literal notranslate"><span class="pre">axis</span></code> keyword argument.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stc</strong><span class="classifier">SourceEstimate | VectorSourceEstimate</span></dt><dd><p>The binned source estimate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.center_of_mass">
<code class="descname">center_of_mass</code><span class="sig-paren">(</span><em>subject=None</em>, <em>hemi=None</em>, <em>restrict_vertices=False</em>, <em>subjects_dir=None</em>, <em>surf='sphere'</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L1549-L1637"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.center_of_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the center of mass of activity.</p>
<p>This function computes the spatial center of mass on the surface
as well as the temporal center of mass as in <a class="reference internal" href="#rf9d93a5fe24c-1" id="id1">[1]</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All activity must occur in a single hemisphere, otherwise
an error is raised. The “mass” of each point in space for
computing the spatial center of mass is computed by summing
across time, and vice-versa for each point in time in
computing the temporal center of mass. This is useful for
quantifying spatio-temporal cluster locations, especially
when combined with <a class="reference internal" href="mne.vertex_to_mni.html#mne.vertex_to_mni" title="mne.vertex_to_mni"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.vertex_to_mni()</span></code></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>subject</strong><span class="classifier">string | None</span></dt><dd><p>The subject the stc is defined for.</p>
</dd>
<dt><strong>hemi</strong><span class="classifier">int, or None</span></dt><dd><p>Calculate the center of mass for the left (0) or right (1)
hemisphere. If None, one of the hemispheres must be all zeroes,
and the center of mass will be calculated for the other
hemisphere (useful for getting COM for clusters).</p>
</dd>
<dt><strong>restrict_vertices</strong><span class="classifier">bool | array of int | instance of SourceSpaces</span></dt><dd><p>If True, returned vertex will be one from stc. Otherwise, it could
be any vertex from surf. If an array of int, the returned vertex
will come from that array. If instance of SourceSpaces (as of
0.13), the returned vertex will be from the given source space.
For most accuruate estimates, do not restrict vertices.</p>
</dd>
<dt><strong>subjects_dir</strong><span class="classifier">str, or None</span></dt><dd><p>Path to the SUBJECTS_DIR. If None, the path is obtained by using
the environment variable SUBJECTS_DIR.</p>
</dd>
<dt><strong>surf</strong><span class="classifier">str</span></dt><dd><p>The surface to use for Euclidean distance center of mass
finding. The default here is “sphere”, which finds the center
of mass on the spherical surface to help avoid potential issues
with cortical folding.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vertex</strong><span class="classifier">int</span></dt><dd><p>Vertex of the spatial center of mass for the inferred hemisphere,
with each vertex weighted by the sum of the stc across time. For a
boolean stc, then, this would be weighted purely by the duration
each vertex was active.</p>
</dd>
<dt><strong>hemi</strong><span class="classifier">int</span></dt><dd><p>Hemisphere the vertex was taken from.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>Time of the temporal center of mass (weighted by the sum across
source vertices).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="mne.Label.html#mne.Label.center_of_mass" title="mne.Label.center_of_mass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mne.Label.center_of_mass</span></code></a>, <a class="reference internal" href="mne.vertex_to_mni.html#mne.vertex_to_mni" title="mne.vertex_to_mni"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mne.vertex_to_mni</span></code></a></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rf9d93a5fe24c-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>)</span></dt>
<dd><p>Larson and Lee, “The cortical dynamics underlying effective
switching of auditory spatial attention”, NeuroImage 2012.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L878-L880"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return copy of source estimate instance.</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.crop">
<code class="descname">crop</code><span class="sig-paren">(</span><em>tmin=None</em>, <em>tmax=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L594-L611"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Restrict SourceEstimate to a time interval.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tmin</strong><span class="classifier">float | None</span></dt><dd><p>The first time point in seconds. If None the first present is used.</p>
</dd>
<dt><strong>tmax</strong><span class="classifier">float | None</span></dt><dd><p>The last time point in seconds. If None the last present is used.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="mne.SourceEstimate.data">
<code class="descname">data</code><a class="headerlink" href="#mne.SourceEstimate.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy array of source estimate data.</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.expand">
<code class="descname">expand</code><span class="sig-paren">(</span><em>vertices</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L1264-L1302"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand SourceEstimate to include more vertices.</p>
<p>This will add rows to stc.data (zero-filled) and modify stc.vertices
to include all vertices in stc.vertices and the input vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices</strong><span class="classifier">list of array</span></dt><dd><p>New vertices to add. Can also contain old values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stc</strong><span class="classifier">SourceEstimate | VectorSourceEstimate</span></dt><dd><p>The modified stc (note: method operates inplace).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.extract_label_time_course">
<code class="descname">extract_label_time_course</code><span class="sig-paren">(</span><em>labels</em>, <em>src</em>, <em>mode='mean_flip'</em>, <em>allow_empty=False</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L1448-L1505"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.extract_label_time_course" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract label time courses for lists of labels.</p>
<p>This function will extract one time course for each label. The way the
time courses are extracted depends on the mode parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">Label | BiHemiLabel | list of Label or BiHemiLabel</span></dt><dd><p>The labels for which to extract the time courses.</p>
</dd>
<dt><strong>src</strong><span class="classifier">list</span></dt><dd><p>Source spaces for left and right hemisphere.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str</span></dt><dd><p>Extraction mode, see explanation below.</p>
</dd>
<dt><strong>allow_empty</strong><span class="classifier">bool</span></dt><dd><p>Instead of emitting an error, return all-zero time course for
labels that do not have any vertices in the source estimate.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, str, int, or None</span></dt><dd><p>If not None, override default verbose level (see <a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a>
and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a> for more). Defaults to self.verbose.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>label_tc</strong><span class="classifier">array, shape=(n_labels, n_times)</span></dt><dd><p>Extracted time course for each label.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="mne.extract_label_time_course.html#mne.extract_label_time_course" title="mne.extract_label_time_course"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_label_time_course</span></code></a></dt><dd><p>extract time courses for multiple STCs</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Valid values for mode are:</p>
<ul class="simple">
<li><dl class="simple">
<dt>‘mean’</dt><dd><p>Average within each label.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘mean_flip’</dt><dd><p>Average within each label with sign flip depending
on source orientation.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘pca_flip’</dt><dd><p>Apply an SVD to the time courses within each label
and use the scaled and sign-flipped first right-singular vector
as the label time course. The scaling is performed such that the
power of the label time course is the same as the average
per-vertex time course power within the label. The sign of the
resulting time course is adjusted by multiplying it with
“sign(dot(u, flip))” where u is the first left-singular vector,
and flip is a sing-flip vector based on the vertex normals. This
procedure assures that the phase does not randomly change by 180
degrees from one stc to the next.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘max’</dt><dd><p>Max value within each label.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.get_peak">
<code class="descname">get_peak</code><span class="sig-paren">(</span><em>hemi=None</em>, <em>tmin=None</em>, <em>tmax=None</em>, <em>mode='abs'</em>, <em>vert_as_index=False</em>, <em>time_as_index=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L1507-L1547"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.get_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Get location and latency of peak amplitude.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hemi</strong><span class="classifier">{‘lh’, ‘rh’, None}</span></dt><dd><p>The hemi to be considered. If None, the entire source space is
considered.</p>
</dd>
<dt><strong>tmin</strong><span class="classifier">float | None</span></dt><dd><p>The minimum point in time to be considered for peak getting.</p>
</dd>
<dt><strong>tmax</strong><span class="classifier">float | None</span></dt><dd><p>The maximum point in time to be considered for peak getting.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘pos’, ‘neg’, ‘abs’}</span></dt><dd><p>How to deal with the sign of the data. If ‘pos’ only positive
values will be considered. If ‘neg’ only negative values will
be considered. If ‘abs’ absolute values will be considered.
Defaults to ‘abs’.</p>
</dd>
<dt><strong>vert_as_index</strong><span class="classifier">bool</span></dt><dd><p>whether to return the vertex index instead of of its ID.
Defaults to False.</p>
</dd>
<dt><strong>time_as_index</strong><span class="classifier">bool</span></dt><dd><p>Whether to return the time index instead of the latency.
Defaults to False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pos</strong><span class="classifier">int</span></dt><dd><p>The vertex exhibiting the maximum response, either ID or index.</p>
</dd>
<dt><strong>latency</strong><span class="classifier">float | int</span></dt><dd><p>The time point of the maximum response, either latency in seconds
or index.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.in_label">
<code class="descname">in_label</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L1218-L1262"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.in_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a source estimate object restricted to a label.</p>
<p>SourceEstimate contains the time course of
activation of all sources inside the label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">Label | BiHemiLabel</span></dt><dd><p>The label (as created for example by mne.read_label). If the label
does not match any sources in the SourceEstimate, a ValueError is
raised.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stc</strong><span class="classifier">SourceEstimate | VectorSourceEstimate</span></dt><dd><p>The source estimate restricted to the given label.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="mne.SourceEstimate.lh_data">
<code class="descname">lh_data</code><a class="headerlink" href="#mne.SourceEstimate.lh_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Left hemisphere data.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.SourceEstimate.lh_vertno">
<code class="descname">lh_vertno</code><a class="headerlink" href="#mne.SourceEstimate.lh_vertno" title="Permalink to this definition">¶</a></dt>
<dd><p>Left hemisphere vertno.</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.mean">
<code class="descname">mean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L742-L752"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a summary stc file with mean over time points.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>stc</strong><span class="classifier">SourceEstimate | VectorSourceEstimate</span></dt><dd><p>The modified stc.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>subject=None</em>, <em>surface='inflated'</em>, <em>hemi='lh'</em>, <em>colormap='auto'</em>, <em>time_label='auto'</em>, <em>smoothing_steps=10</em>, <em>transparent=True</em>, <em>alpha=1.0</em>, <em>time_viewer=False</em>, <em>subjects_dir=None</em>, <em>figure=None</em>, <em>views='lat'</em>, <em>colorbar=True</em>, <em>clim='auto'</em>, <em>cortex='classic'</em>, <em>size=800</em>, <em>background='black'</em>, <em>foreground='white'</em>, <em>initial_time=None</em>, <em>time_unit='s'</em>, <em>backend='auto'</em>, <em>spacing='oct6'</em>, <em>title=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L1429-L1446"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot SourceEstimate with PySurfer.</p>
<p>By default this function uses <a class="reference external" href="http://docs.enthought.com/mayavi/mayavi/auto/mlab_reference.html#module-mayavi.mlab" title="(in mayavi v4.6.2)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mayavi.mlab</span></code></a> to plot the source
estimates. If Mayavi is not installed, the plotting is done with
<a class="reference external" href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.html#module-matplotlib.pyplot" title="(in Matplotlib v3.0.3)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code></a> (much slower, decimated source space by default).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>subject</strong><span class="classifier">str | None</span></dt><dd><p>The subject name corresponding to FreeSurfer environment
variable SUBJECT. If None stc.subject will be used. If that
is None, the environment will be used.</p>
</dd>
<dt><strong>surface</strong><span class="classifier">str</span></dt><dd><p>The type of surface (inflated, white etc.).</p>
</dd>
<dt><strong>hemi</strong><span class="classifier">str, ‘lh’ | ‘rh’ | ‘split’ | ‘both’</span></dt><dd><p>The hemisphere to display.</p>
</dd>
<dt><strong>colormap</strong><span class="classifier">str | np.ndarray of float, shape(n_colors, 3 | 4)</span></dt><dd><p>Name of colormap to use or a custom look up table. If array, must
be (n x 3) or (n x 4) array for with RGB or RGBA values between
0 and 255. The default (‘auto’) uses ‘hot’ for one-sided data and
‘mne’ for two-sided data.</p>
</dd>
<dt><strong>time_label</strong><span class="classifier">str | callable | None</span></dt><dd><p>Format of the time label (a format string, a function that maps
floating point time values to strings, or None for no label). The
default is <code class="docutils literal notranslate"><span class="pre">time=%0.2f</span> <span class="pre">ms</span></code>.</p>
</dd>
<dt><strong>smoothing_steps</strong><span class="classifier">int</span></dt><dd><p>The amount of smoothing</p>
</dd>
<dt><strong>transparent</strong><span class="classifier">bool</span></dt><dd><p>If True, use a linear transparency between fmin and fmid.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>Alpha value to apply globally to the overlay. Has no effect with mpl
backend.</p>
</dd>
<dt><strong>time_viewer</strong><span class="classifier">bool</span></dt><dd><p>Display time viewer GUI.</p>
</dd>
<dt><strong>subjects_dir</strong><span class="classifier">str</span></dt><dd><p>The path to the freesurfer subjects reconstructions.
It corresponds to Freesurfer environment variable SUBJECTS_DIR.</p>
</dd>
<dt><strong>figure</strong><span class="classifier">instance of mayavi.core.api.Scene | instance of matplotlib.figure.Figure | list | int | None</span></dt><dd><p>If None, a new figure will be created. If multiple views or a
split view is requested, this must be a list of the appropriate
length. If int is provided it will be used to identify the Mayavi
figure by it’s id or create a new figure with the given id. If an
instance of matplotlib figure, mpl backend is used for plotting.</p>
</dd>
<dt><strong>views</strong><span class="classifier">str | list</span></dt><dd><p>View to use. See <a class="reference external" href="https://pysurfer.github.io/generated/surfer.Brain.html#surfer.Brain" title="(in PySurfer v0.9.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">surfer.Brain</span></code></a>. Supported views: [‘lat’, ‘med’, ‘ros’,
‘cau’, ‘dor’ ‘ven’, ‘fro’, ‘par’]. Using multiple views is not
supported for mpl backend.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool</span></dt><dd><p>If True, display colorbar on scene.</p>
</dd>
<dt><strong>clim</strong><span class="classifier">str | dict</span></dt><dd><p>Colorbar properties specification. If ‘auto’, set clim automatically
based on data percentiles. If dict, should contain:</p>
<blockquote>
<div><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">kind</span></code><span class="classifier">‘value’ | ‘percent’</span></dt><dd><p>Flag to specify type of limits.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lims</span></code><span class="classifier">list | np.ndarray | tuple of float, 3 elements</span></dt><dd><p>Left, middle, and right bound for colormap.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pos_lims</span></code><span class="classifier">list | np.ndarray | tuple of float, 3 elements</span></dt><dd><p>Left, middle, and right bound for colormap. Positive values
will be mirrored directly across zero during colormap
construction to obtain negative control points.</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only sequential colormaps should be used with <code class="docutils literal notranslate"><span class="pre">lims</span></code>, and
only divergent colormaps should be used with <code class="docutils literal notranslate"><span class="pre">pos_lims</span></code>.</p>
</div>
</dd>
<dt><strong>cortex</strong><span class="classifier">str or tuple</span></dt><dd><p>Specifies how binarized curvature values are rendered.
Either the name of a preset PySurfer cortex colorscheme (one of
‘classic’, ‘bone’, ‘low_contrast’, or ‘high_contrast’), or the name of
mayavi colormap, or a tuple with values (colormap, min, max, reverse)
to fully specify the curvature colors. Has no effect with mpl backend.</p>
</dd>
<dt><strong>size</strong><span class="classifier">float or tuple of float</span></dt><dd><p>The size of the window, in pixels. can be one number to specify
a square window, or the (width, height) of a rectangular window.
Has no effect with mpl backend.</p>
</dd>
<dt><strong>background</strong><span class="classifier">matplotlib color</span></dt><dd><p>Color of the background of the display window.</p>
</dd>
<dt><strong>foreground</strong><span class="classifier">matplotlib color</span></dt><dd><p>Color of the foreground of the display window. Has no effect with mpl
backend.</p>
</dd>
<dt><strong>initial_time</strong><span class="classifier">float | None</span></dt><dd><p>The time to display on the plot initially. <code class="docutils literal notranslate"><span class="pre">None</span></code> to display the
first time sample (default).</p>
</dd>
<dt><strong>time_unit</strong><span class="classifier">‘s’ | ‘ms’</span></dt><dd><p>Whether time is represented in seconds (“s”, default) or
milliseconds (“ms”).</p>
</dd>
<dt><strong>backend</strong><span class="classifier">‘auto’ | ‘mayavi’ | ‘matplotlib’</span></dt><dd><p>Which backend to use. If <code class="docutils literal notranslate"><span class="pre">'auto'</span></code> (default), tries to plot with
mayavi, but resorts to matplotlib if mayavi is not available.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.15.0.</span></p>
</div>
</dd>
<dt><strong>spacing</strong><span class="classifier">str</span></dt><dd><p>The spacing to use for the source space. Can be <code class="docutils literal notranslate"><span class="pre">'ico#'</span></code> for a
recursively subdivided icosahedron, <code class="docutils literal notranslate"><span class="pre">'oct#'</span></code> for a recursively
subdivided octahedron, or <code class="docutils literal notranslate"><span class="pre">'all'</span></code> for all points. In general, you can
speed up the plotting by selecting a sparser source space. Has no
effect with mayavi backend. Defaults  to ‘oct6’.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.15.0.</span></p>
</div>
</dd>
<dt><strong>title</strong><span class="classifier">str | None</span></dt><dd><p>Title for the figure. If None, the subject name will be used.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17.0.</span></p>
</div>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, str, int, or None</span></dt><dd><p>If not None, override default verbose level (see <a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a>
and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a> for more).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>figure</strong><span class="classifier">instance of surfer.Brain | matplotlib.figure.Figure</span></dt><dd><p>An instance of <a class="reference external" href="https://pysurfer.github.io/generated/surfer.Brain.html#surfer.Brain" title="(in PySurfer v0.9.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">surfer.Brain</span></code></a> from PySurfer or
matplotlib figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.resample">
<code class="descname">resample</code><span class="sig-paren">(</span><em>sfreq</em>, <em>npad='auto'</em>, <em>window='boxcar'</em>, <em>n_jobs=1</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L613-L648"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sfreq</strong><span class="classifier">float</span></dt><dd><p>New sample rate to use.</p>
</dd>
<dt><strong>npad</strong><span class="classifier">int | str</span></dt><dd><p>Amount to pad the start and end of the data.
Can also be “auto” to use a padding that will result in
a power-of-two size (can be much faster).</p>
</dd>
<dt><strong>window</strong><span class="classifier">string or tuple</span></dt><dd><p>Window to use in resampling. See scipy.signal.resample.</p>
</dd>
<dt><strong>n_jobs</strong><span class="classifier">int</span></dt><dd><p>Number of jobs to run in parallel.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, str, int, or None</span></dt><dd><p>If not None, override default verbose level (see <a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a>
and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a> for more). Defaults to self.verbose.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For some data, it may be more accurate to use npad=0 to reduce
artifacts. This is dataset dependent – check your data!</p>
<p>Note that the sample rate of the original data is inferred from tstep.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.SourceEstimate.rh_data">
<code class="descname">rh_data</code><a class="headerlink" href="#mne.SourceEstimate.rh_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Right hemisphere data.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.SourceEstimate.rh_vertno">
<code class="descname">rh_vertno</code><a class="headerlink" href="#mne.SourceEstimate.rh_vertno" title="Permalink to this definition">¶</a></dt>
<dd><p>Right hemisphere vertno.</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>fname</em>, <em>ftype='stc'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L1387-L1427"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the source estimates to a file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fname</strong><span class="classifier">string</span></dt><dd><p>The stem of the file name. The file names used for surface source
spaces are obtained by adding “-lh.stc” and “-rh.stc” (or “-lh.w”
and “-rh.w”) to the stem provided, for the left and the right
hemisphere, respectively.</p>
</dd>
<dt><strong>ftype</strong><span class="classifier">string</span></dt><dd><p>File format to use. Allowed values are “stc” (default), “w”,
and “h5”. The “w” format only supports a single time point.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, str, int, or None</span></dt><dd><p>If not None, override default verbose level (see <a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a>
and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a> for more). Defaults to self.verbose.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="mne.SourceEstimate.sfreq">
<code class="descname">sfreq</code><a class="headerlink" href="#mne.SourceEstimate.sfreq" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample rate of the data.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.SourceEstimate.shape">
<code class="descname">shape</code><a class="headerlink" href="#mne.SourceEstimate.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Shape of the data.</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.sqrt">
<code class="descname">sqrt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L868-L876"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the square root.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>stc</strong><span class="classifier">instance of SourceEstimate</span></dt><dd><p>A copy of the SourceEstimate with sqrt(data).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.sum">
<code class="descname">sum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L754-L769"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a summary stc file with sum over time points.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>stc</strong><span class="classifier">SourceEstimate | VectorSourceEstimate</span></dt><dd><p>The modified stc.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.time_as_index">
<code class="descname">time_as_index</code><span class="sig-paren">(</span><em>times</em>, <em>use_rounding=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/io/base.py#L203-L227"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.time_as_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert time to indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>times</strong><span class="classifier">list-like | float | int</span></dt><dd><p>List of numbers or a number representing points in time.</p>
</dd>
<dt><strong>use_rounding</strong><span class="classifier">boolean</span></dt><dd><p>If True, use rounding (instead of truncation) when converting
times to indices. This can help avoid non-unique indices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>index</strong><span class="classifier">ndarray</span></dt><dd><p>Indices corresponding to the times supplied.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="mne.SourceEstimate.times">
<code class="descname">times</code><a class="headerlink" href="#mne.SourceEstimate.times" title="Permalink to this definition">¶</a></dt>
<dd><p>A timestamp for each sample.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.SourceEstimate.tmin">
<code class="descname">tmin</code><a class="headerlink" href="#mne.SourceEstimate.tmin" title="Permalink to this definition">¶</a></dt>
<dd><p>The first timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.to_data_frame">
<code class="descname">to_data_frame</code><span class="sig-paren">(</span><em>picks=None</em>, <em>index=None</em>, <em>scaling_time=1000.0</em>, <em>scalings=None</em>, <em>copy=True</em>, <em>start=None</em>, <em>stop=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/io/base.py#L55-L196"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.to_data_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Export data in tabular structure as a pandas DataFrame.</p>
<p>Columns and indices will depend on the object being converted.
Generally this will include as much relevant information as
possible for the data type being converted. This makes it easy
to convert data for use in packages that utilize dataframes,
such as statsmodels or seaborn.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>picks</strong><span class="classifier">str | list | slice | None</span></dt><dd><p>Channels to include. Slices and lists of integers will be
interpreted as channel indices. In lists, channel <em>type</em> strings
(e.g., <code class="docutils literal notranslate"><span class="pre">['meg',</span> <span class="pre">'eeg']</span></code>) will pick channels of those
types, channel <em>name</em> strings (e.g., <code class="docutils literal notranslate"><span class="pre">['MEG0111',</span> <span class="pre">'MEG2623']</span></code>
will pick the given channels. Can also be the string values
“all” to pick all channels, or “data” to pick data channels.
None (default) will pick all channels.</p>
</dd>
<dt><strong>index</strong><span class="classifier">tuple of str | None</span></dt><dd><p>Column to be used as index for the data. Valid string options
are ‘epoch’, ‘time’ and ‘condition’. If None, all three info
columns will be included in the table as categorial data.</p>
</dd>
<dt><strong>scaling_time</strong><span class="classifier">float</span></dt><dd><p>Scaling to be applied to time units.</p>
</dd>
<dt><strong>scalings</strong><span class="classifier">dict | None</span></dt><dd><p>Scaling to be applied to the channels picked. If None, defaults to
<code class="docutils literal notranslate"><span class="pre">scalings=dict(eeg=1e6,</span> <span class="pre">grad=1e13,</span> <span class="pre">mag=1e15,</span> <span class="pre">misc=1.0)</span></code>.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool</span></dt><dd><p>If true, data will be copied. Else data may be modified in place.</p>
</dd>
<dt><strong>start</strong><span class="classifier">int | None</span></dt><dd><p>If it is a Raw object, this defines a starting index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</dd>
<dt><strong>stop</strong><span class="classifier">int | None</span></dt><dd><p>If it is a Raw object, this defines a stop index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">instance of pandas.DataFrame</span></dt><dd><p>A dataframe suitable for usage with other
statistical/plotting/analysis packages. Column/Index values will
depend on the object type being converted, but should be
human-readable.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.to_original_src">
<code class="descname">to_original_src</code><span class="sig-paren">(</span><em>src_orig</em>, <em>subject_orig=None</em>, <em>subjects_dir=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L1304-L1341"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.to_original_src" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a source estimate from morphed source to the original subject.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src_orig</strong><span class="classifier">instance of SourceSpaces</span></dt><dd><p>The original source spaces that were morphed to the current
subject.</p>
</dd>
<dt><strong>subject_orig</strong><span class="classifier">str | None</span></dt><dd><p>The original subject. For most source spaces this shouldn’t need
to be provided, since it is stored in the source space itself.</p>
</dd>
<dt><strong>subjects_dir</strong><span class="classifier">string, or None</span></dt><dd><p>Path to SUBJECTS_DIR if it is not set in the environment.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, str, int, or None</span></dt><dd><p>If not None, override default verbose level (see <a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a>
and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a> for more). Defaults to self.verbose.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stc</strong><span class="classifier">SourceEstimate | VectorSourceEstimate</span></dt><dd><p>The transformed source estimate.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="mne.morph_source_spaces.html#mne.morph_source_spaces" title="mne.morph_source_spaces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">morph_source_spaces</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.10.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>func</em>, <em>idx=None</em>, <em>tmin=None</em>, <em>tmax=None</em>, <em>copy=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L1004-L1100"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply linear transform.</p>
<p>The transform is applied to each source time course independently.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><p>The transform to be applied, including parameters (see, e.g.,
<a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.partial" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>). The first parameter of the function is
the input data. The first two dimensions of the transformed data
should be (i) vertices and (ii) time.  See Notes for details.</p>
</dd>
<dt><strong>idx</strong><span class="classifier">array | None</span></dt><dd><p>Indices of source time courses for which to compute transform.
If None, all time courses are used.</p>
</dd>
<dt><strong>tmin</strong><span class="classifier">float | int | None</span></dt><dd><p>First time point to include (ms). If None, self.tmin is used.</p>
</dd>
<dt><strong>tmax</strong><span class="classifier">float | int | None</span></dt><dd><p>Last time point to include (ms). If None, self.tmax is used.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool</span></dt><dd><p>If True, return a new instance of SourceEstimate instead of
modifying the input inplace.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stcs</strong><span class="classifier">SourceEstimate | VectorSourceEstimate | list</span></dt><dd><p>The transformed stc or, in the case of transforms which yield
N-dimensional output (where N &gt; 2), a list of stcs. For a list,
copy must be True.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Transforms which yield 3D
output (e.g. time-frequency transforms) are valid, so long as the
first two dimensions are vertices and time.  In this case, the
copy parameter must be True and a list of
SourceEstimates, rather than a single instance of SourceEstimate,
will be returned, one for each index of the 3rd dimension of the
transformed data.  In the case of transforms yielding 2D output
(e.g. filtering), the user has the option of modifying the input
inplace (copy = False) or returning a new instance of
SourceEstimate (copy = True) with the transformed data.</p>
<p>Applying transforms can be significantly faster if the
SourceEstimate object was created using “(kernel, sens_data)”, for
the “data” parameter as the transform is applied in sensor space.
Inverse methods, e.g., “apply_inverse_epochs”, or “apply_lcmv_epochs”
do this automatically (if possible).</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.transform_data">
<code class="descname">transform_data</code><span class="sig-paren">(</span><em>func</em>, <em>idx=None</em>, <em>tmin_idx=None</em>, <em>tmax_idx=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/master/mne/source_estimate.py#L928-L1002"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.SourceEstimate.transform_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Get data after a linear (time) transform has been applied.</p>
<p>The transform is applied to each source time course independently.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><p>The transform to be applied, including parameters (see, e.g.,
<a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.partial" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>). The first parameter of the function is
the input data. The first return value is the transformed data,
remaining outputs are ignored. The first dimension of the
transformed data has to be the same as the first dimension of the
input data.</p>
</dd>
<dt><strong>idx</strong><span class="classifier">array | None</span></dt><dd><p>Indicices of source time courses for which to compute transform.
If None, all time courses are used.</p>
</dd>
<dt><strong>tmin_idx</strong><span class="classifier">int | None</span></dt><dd><p>Index of first time point to include. If None, the index of the
first time point is used.</p>
</dd>
<dt><strong>tmax_idx</strong><span class="classifier">int | None</span></dt><dd><p>Index of the first time point not to include. If None, time points
up to (and including) the last time point are included.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data_t</strong><span class="classifier">ndarray</span></dt><dd><p>The transformed data.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Applying transforms can be significantly faster if the
SourceEstimate object was created using “(kernel, sens_data)”, for
the “data” parameter as the transform is applied in sensor space.
Inverse methods, e.g., “apply_inverse_epochs”, or “apply_lcmv_epochs”
do this automatically (if possible).</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.SourceEstimate.tstep">
<code class="descname">tstep</code><a class="headerlink" href="#mne.SourceEstimate.tstep" title="Permalink to this definition">¶</a></dt>
<dd><p>The change in time between two consecutive samples (1 / sfreq).</p>
</dd></dl>

</dd></dl>

</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container"><img src="../_static/institutions.png" alt="Institutions"></div>
  <div class="container">
    <ul class="list-inline">
      <li><a href="https://github.com/mne-tools/mne-python">GitHub</a></li>
      <li>·</li>
      <li><a href="https://mail.nmr.mgh.harvard.edu/mailman/listinfo/mne_analysis">Mailing list</a></li>
      <li>·</li>
      <li><a href="https://gitter.im/mne-tools/mne-python">Gitter</a></li>
      <li>·</li>
      <li><a href="whats_new.html">What's new</a></li>
      <li>·</li>
      <li><a href="faq.html#cite">Cite MNE</a></li>
      <li class="pull-right"><a href="#">Back to top</a></li>
    </ul>
    <p>&copy; Copyright 2012-2019, MNE Developers. Last updated on 2019-04-01.</p>
  </div>
</footer>
  </body>
</html>